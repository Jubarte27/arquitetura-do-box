Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:33:33
							     First Pass 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					WRITEMatrix proto near, NOME:ptr byte
					PrintMatrix proto near
				;====================================================================
				; Memory
						.stack
 0000						.data
					
					CMD_NONE  EQU 0
					CMD_MUL   EQU 1
					CMD_DIV   EQU 2
					CMD_ADD   EQU 3
					CMD_SUB   EQU 4
					CMD_UNDO  EQU 5
					CMD_WRITE EQU 6
					CR            equ 0dh
					LF            equ 0ah
					QUOT          equ 22h
					SEMI          equ 3Bh
					COL_SEPARATOR equ SEMI
					SPACE         equ 20h
					COLUMN_SEP db ";",0
					CRLF       db CR, LF, 0
					BuffSize       equ 100              ; tam. mÃ¡ximo dos dados lidos no buffer
					FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
					FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
					FileHandle     dw  0                ; Handler do arquivo
					FileIsOpen     db  0                ; closed at the start
					FileNameBuffer db  150 dup (?)
					caractere      db  0
					CommandBuffer       db 254
					CommandBufferLength db 0          ; max length, actual length
					CommandBufferString db 254 dup(0)
					LastCommand   db 0
					LastCommand@a dw 0
					LastCommand@b sword 0
					LastCommand@exists db 0
					NonTerminalErrorBuffer db 255 dup(0)
					@Comando      db "Comando",0
					@espera       db "espera",0
					@como         db "como",0
					@parametro    db "parametro",0
					@@parametro   db "Parametro",0
					@desconhecido db "desconhecido",0
					@space        db " ",0
					@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
					@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
					@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
					
					COLON_SPACE db ": ",0
					ExplanationSeparator textequ <COLON_SPACE>
					; Used on PeekChar
					PeekBuffer        db ?
					; Used when reporting the error
					TheUnexpectedChar db 0,QUOT,0
					; used in main
					FileCol           dw 1
					FileLine          dw 1
					Row      byte 0
					Col      byte 0
					TotalRow byte 0
					TotalCol byte 0
					N        byte 0
					NPlusOne byte 0
					; should be at most 7x7
					Matrix   sword (7 * 7) dup (?)
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
					OPEN_DELIMITER    textequ <!<>
					CLOSE_DELIMITER   textequ <!>>
					REG_SET_DELIMITER textequ <|>
					regStack textequ <> ; starts empty
					__popRegs macro
						regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else
							regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif
						exitm regs
					endm
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else
							regStack catstr regs, REG_SET_DELIMITER, regStack
						endif
					endm
					SaveRegs macro regs:vararg
						comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
					RestoreRegs macro
					%	for reg, __popRegs(regStack) 
							pop reg
						endm
					endm
					RegsInvokeUses textequ <ax bx cx dx bp>
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
						SaveRegs ax, dx
						mov      ah, 02h
						mov      dl, c
						int      21h
						RestoreRegs
					endm
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h
						forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0
					endm
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif
						ifdifi <dst>, <di>
							lea di, dst
						endif
						.repeat
							mov al,   [si]
							mov [di], al
							inc si
							inc di
						.until (al == 0)
						dec    si
						dec    di
						RestoreRegs
					endm
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> 
						ELSE
							EXITM <0> 
						ENDIF
					ENDM
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif
						for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				;--------------------------------------------------------------------
				; Miscellaneous
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
					endm
					CloseFileHandle macro
						mov ah, 3eh
						mov bx, FileHandle
						int 21h
						
						mov FileIsOpen, 0 ; 0 means it is now closed
					endm
					CurrentIndexToBx macro
						; returns in bx
						SaveRegs ax
						mov      al, TotalCol
						inc      al           ; TotalCol starts at 0
						mov bl, Row
						mov bh, Col
						mul bl
						add al, bh
						; got index, find position in array
						shl ax, 1
						add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				;====================================================================
				; Program
 0000					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
			     1			SaveRegs ax, dx
			     2			??0001     textequ <>
			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0002 catstr <ax>, ??0001, ??0002
			     3				??0001 catstr <, >
			     3				push  dx
			     3				??0002 catstr <dx>, ??0001, ??0002
			     3				??0001 catstr <, >
			     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
			     3				??0005     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)      
			     3				regStack substr regStack, (??0004 + 1)     
			     3			endif
			     3			exitm ??0005
			     2		for ??0003, <dx, ax> 
			     2				pop ??0003
			     2			endm
			     3				pop dx
			     3				pop ax
							putc   LF
			     1			SaveRegs ax, dx
			     2			??0007     textequ <>
			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0008 catstr <ax>, ??0007, ??0008
			     3				??0007 catstr <, >
			     3				push  dx
			     3				??0008 catstr <dx>, ??0007, ??0008
			     3				??0007 catstr <, >
			     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
			     3				??000B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)      
			     3				regStack substr regStack, (??000A + 1)     
			     3			endif
			     3			exitm ??000B
			     2		for ??0009, <dx, ax> 
			     2				pop ??0009
			     2			endm
			     3				pop dx
			     3				pop ax
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
						.if (ax == CMD_ADD)
							call Main@ADD
							jmp  @MainLoopEnd
						.elseif  (ax == CMD_MUL)
							call Main@MUL
							jmp  @MainLoopEnd
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
							jmp  @MainLoopEnd
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							putc CR
			     1			SaveRegs ax, dx
			     2			??000D     textequ <>
			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
			     3				push  ax
			     3				??000E catstr <ax>, ??000D, ??000E
			     3				??000D catstr <, >
			     3				push  dx
			     3				??000E catstr <dx>, ??000D, ??000E
			     3				??000D catstr <, >
			     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
			     3				??0011     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)      
			     3				regStack substr regStack, (??0010 + 1)     
			     3			endif
			     3			exitm ??0011
			     2		for ??000F, <dx, ax> 
			     2				pop ??000F
			     2			endm
			     3				pop dx
			     3				pop ax
							putc LF
			     1			SaveRegs ax, dx
			     2			??0013     textequ <>
			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0014 catstr <ax>, ??0013, ??0014
			     3				??0013 catstr <, >
			     3				push  dx
			     3				??0014 catstr <dx>, ??0013, ??0014
			     3				??0013 catstr <, >
			     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
			     3				??0017     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)      
			     3				regStack substr regStack, (??0016 + 1)     
			     3			endif
			     3			exitm ??0017
			     2		for ??0015, <dx, ax> 
			     2				pop ??0015
			     2			endm
			     3				pop dx
			     3				pop ax
							jmp  @SkipPrint
						.endif
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
			     1			SaveRegs ax, dx
			     2			??0019     textequ <>
			     2			??001A textequ <>
			     2			for       ??0018, <ax,dx>
			     2				push  ??0018
			     2				??001A catstr <??0018>, ??0019, ??001A
			     2				??0019 catstr <, >
			     2			endm
			     3				push  ax
			     3				??001A catstr <ax>, ??0019, ??001A
			     3				??0019 catstr <, >
			     3				push  dx
			     3				??001A catstr <dx>, ??0019, ??001A
			     3				??0019 catstr <, >
			     2			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
			     2			__pushRegs ??001A
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??001A
			     3			else
			     3				regStack catstr ??001A, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??001C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??001C eq 0
			     3				??001D     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??001D substr regStack, 1, (??001C - 1)      
			     3				regStack substr regStack, (??001C + 1)     
			     3			endif
			     3			exitm ??001D
			     2		for ??001B, <dx, ax> 
			     2				pop ??001B
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??001F     textequ <>
			     2			??0020 textequ <>
			     2			for       ??001E, <ax,dx>
			     2				push  ??001E
			     2				??0020 catstr <??001E>, ??001F, ??0020
			     2				??001F catstr <, >
			     2			endm
			     3				push  ax
			     3				??0020 catstr <ax>, ??001F, ??0020
			     3				??001F catstr <, >
			     3				push  dx
			     3				??0020 catstr <dx>, ??001F, ??0020
			     3				??001F catstr <, >
			     2			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
			     2			__pushRegs ??0020
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0020
			     3			else
			     3				regStack catstr ??0020, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0022 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0022 eq 0
			     3				??0023     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0023 substr regStack, 1, (??0022 - 1)      
			     3				regStack substr regStack, (??0022 + 1)     
			     3			endif
			     3			exitm ??0023
			     2		for ??0021, <dx, ax> 
			     2				pop ??0021
			     2			endm
			     3				pop dx
			     3				pop ax
					jmp @whiletrue
 0167					Main@ADD proc near
						mov LastCommand,        CMD_ADD
						mov bh,                 0
						mov LastCommand@a,      bx
						mov ch,                 0
						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
						invoke ADDMatrix, bl, cl
						ret
 018E					Main@ADD endp
 018E					Main@MUL proc near
						mov LastCommand,        CMD_MUL
						mov bh,                 0
						mov LastCommand@a,      bx
						mov LastCommand@b,      sword ptr cx
						mov LastCommand@exists, 1
						invoke MULMatrix, bl, cx
						ret
 01B1					Main@MUL endp
 01B1					Main@UNDO proc near
						mov al, LastCommand@exists
						.if !al
							jmp @MainLoopEnd
						.endif
						mov al,           LastCommand
						mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
						.if (al == CMD_ADD)
							invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
						.elseif (al == CMD_MUL)
							invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
							mov LastCommand, CMD_ADD
						.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
							mov LastCommand, CMD_MUL
						.endif
						ret
 029F					Main@UNDO  endp
 029F					Main@WRITE proc near
						invoke WRITEMatrix, dx
						ret
 02AB					Main@WRITE endp
				;====================================================================
				; MUL
 02AB					MULMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						MULMatrix@Loop:
							mov  ax,             sword ptr [bx]
							imul CONSTANTE
							mov  sword ptr [bx], ax
							add  bx, 2
							loop MULMatrix@Loop
						ret
 02E2					MULMatrix endp
 02E2					DIVMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
							mov ax, sword ptr [bx]
							cwd                    ; extend sign to dx
							
							idiv CONSTANTE
							
							mov sword ptr [bx], ax
							add  bx, 2
							loop DIVMatrix@Loop
						ret
 031A					DIVMatrix endp
				;====================================================================
				; ADD
 031A					ADDMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						ADDMatrix@Loop:
							mov ax,   [di]
							add ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop ADDMatrix@Loop
						ret
 036D					ADDMatrix endp
 036D					SUBMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						SUBMatrix@Loop:
							mov ax,   [di]
							sub ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop SUBMatrix@Loop
						ret
 03C0					SUBMatrix endp
				;====================================================================
				; WRITE
					WriteToFile macro handle:req, offset_buf:req, len:req
						SaveRegs bx, cx, dx
						mov cx, len
						mov bx, handle
						lea dx, offset_buf
						mov ah, 40h
						int 21h
						RestoreRegs
					endm
 03C0					WRITEMatrix proc near uses ax bx cx dx bp di si, NOME:ptr byte
						local buf[7]:byte, handle:word
						mov   ah,          3Dh         ; open
						mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
						jc    create_file              ; if not exists
						mov bx, ax      ; BX = file handle
						jmp file_opened
						create_file:
						mov ah, 3Ch  ; create
						mov cx, 0
						mov dx, NOME
						int 21h
						mov bx, ax
						file_opened:
						mov ah, 42h
						mov al, 02h ; SEEK_END
						xor cx, cx
						xor dx, dx
						int 21h
						.if (carry?)
							ErrorCantOpenNorCreate
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     4			SaveRegs ax
			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0026 catstr <ax>, ??0025, ??0026
			     6				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
			     5			__pushRegs ??0026
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>_po
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0028 eq 0
			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)      
			     6				regStack substr regStack, (??0028 + 1)     
			     6			endif
			     6			exitm ??0029
			     5		for ??0027, <ax> 
			     5				pop ??0027
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??002B     textequ <>
			     5			??002C textequ <>
			     5			for       ??002A, <ax>
			     5				push  ??002A
			     5				??002C catstr <??002A>, ??002B, ??002C
			     5				??002B catstr <, >
			     5			endm
			     6				push  ax
			     6				??002C catstr <ax>, ??002B, ??002C
			     6				??002B catstr <, >
			     5			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
			     5			__pushRegs ??002C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??002C
			     6			else
			     6				regStack catstr ??002C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??002E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??002E eq 0
			     6				??002F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??002F substr regStack, 1, (??002E - 1)      
			     6				regStack substr regStack, (??002E + 1)     
			     6			endif
			     6			exitm ??002F
			     5		for ??002D, <ax> 
			     5				pop ??002D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, diu_cria
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0031     textequ <>
			     5			??0032 textequ <>
			     5			for       ??0030, <ax>
			     5				push  ??0030
			     5				??0032 catstr <??0030>, ??0031, ??0032
			     5				??0031 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0032 catstr <ax>, ??0031, ??0032
			     6				??0031 catstr <, >
			     5			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
			     5			__pushRegs ??0032
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0032
			     6			else
			     6				regStack catstr ??0032, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0034 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0034 eq 0
			     6				??0035     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0035 substr regStack, 1, (??0034 - 1)      
			     6				regStack substr regStack, (??0034 + 1)     
			     6			endif
			     6			exitm ??0035
			     5		for ??0033, <ax> 
			     5				pop ??0033
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, diu_cri
			     3				endif
							stc
							ret
						.endif
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
								jge WRITEMatrix@EndForCol
								.if (bl) ; no longer firstCol?
									WriteToFile handle, COLUMN_SEP, 1
			     1			SaveRegs bx, cx, dx
			     2			??0037     textequ <>
			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0038 catstr <bx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  cx
			     3				??0038 catstr <cx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  dx
			     3				??0038 catstr <dx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 1
			     1			mov bx, handle
			     1			lea dx, COLUMN_SEP
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
			     3				??003B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)ŒL	  
			     3				regStack substr regStack, (??003A + 1)ŒL	 
			     3			endif
			     3			exitm ??003B
			     2		for ??0039, <dx, cx, bx> 
			     2				pop ??0039
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								.endif
								mov ax, sword ptr [di]
								invoke string_from_sword, addr buf, ax ; ax now has length
								WriteToFile handle, buf, ax
			     1			SaveRegs bx, cx, dx
			     2			??003D     textequ <>
			     2			??003E textequ <>
			     2			for       ??003C, <bx,cx,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
			     3				push  bx
			     3				??003E catstr <bx>, ??003D, ??003E
			     3				??003D catstr <, >
			     3				push  cx
			     3				??003E catstr <cx>, ??003D, ??003E
			     3				??003D catstr <, >
			     3				push  dx
			     3				??003E catstr <dx>, ??003D, ??003E
			     3				??003D catstr <, >
			     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, ax
			     1			mov bx, handle
			     1			lea dx, buf
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
			     3				??0041     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)      
			     3				regStack substr regStack, (??0040 + 1)     
			     3			endif
			     3			exitm ??0041
			     2		for ??003F, <dx, cx, bx> 
			     2				pop ??003F
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								add di, 2 ; size in bytes of a sword
								mov bl, 1 ; no longer first col
								inc cl    ; col ++
								
								jmp WRITEMatrix@ForCol
							WRITEMatrix@EndForCol:
							WriteToFile handle, CRLF, 2
			     1			SaveRegs bx, cx, dx
			     2			??0043     textequ <>
			     2			??0044 textequ <>
			     2			for       ??0042, <bx,cx,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0044 catstr <bx>, ??0043, ??0044
			     3				??0043 catstr <, >
			     3				push  cx
			     3				??0044 catstr <cx>, ??0043, ??0044
			     3				??0043 catstr <, >
			     3				push  dx
			     3				??0044 catstr <dx>, ??0043, ??0044
			     3				??0043 catstr <, >
			     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 2
			     1			mov bx, handle
			     1			lea dx, CRLF
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
			     3				??0047     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)      
			     3				regStack substr regStack, (??0046 + 1)     
			     3			endif
			     3			exitm ??0047
			     2		for ??0045, <dx, cx, bx> 
			     2				pop ??0045
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
							inc ch ; row++
							
							jmp WRITEMatrix@ForRow
						WRITEMatrix@EndForRow:
						clc
						ret
 052F					WRITEMatrix endp
				;====================================================================
				; Exiting
 052F					ExitSuccess proc near
						mov al, 0
						jmp ExitAndClose
						ret
 053C					ExitSuccess endp
 053C					ExitFailure proc near
						mov al, 1
						jmp ExitAndClose
						ret
 0549					ExitFailure endp
 0549					ExitAndClose proc near
						.if (FileIsOpen)
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						.endif
						.exit
						ret
 0571					ExitAndClose endp
				;====================================================================
				; Reading input
 0571					ReadCommand proc near uses si
						mov dx, offset CommandBuffer
						mov ah, 0Ah
						int 21h
						mov si, offset CommandBufferString
						mov bh, 0
						mov bl, CommandBufferLength
						
						mov byte ptr [CommandBufferString+bx], 0
						putc CR
			     1			SaveRegs ax, dx
			     2			??0049     textequ <>
			     2			??004A textequ <>
			     2			for       ??0048, <ax,dx>
			     2				push  ??0048
			     2				??004A catstr <??0048>, ??0049, ??004A
			     2				??0049 catstr <, >
			     2			endm
			     3				push  ax
			     3				??004A catstr <ax>, ??0049, ??004A
			     3				??0049 catstr <, >
			     3				push  dx
			     3				??004A catstr <dx>, ??0049, ??004A
			     3				??0049 catstr <, >
			     2			??004A catstr OPEN_DELIMITER, ??004A, CLOSE_DELIMITER
			     2			__pushRegs ??004A
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??004A
			     3			else
			     3				regStack catstr ??004A, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??004C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??004C eq 0
			     3				??004D     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??004D substr regStack, 1, (??004C - 1)      
			     3				regStack substr regStack, (??004C + 1)     
			     3			endif
			     3			exitm ??004D
			     2		for ??004B, <dx, ax> 
			     2				pop ??004B
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??004F     textequ <>
			     2			??0050 textequ <>
			     2			for       ??004E, <ax,dx>
			     2				push  ??004E
			     2				??0050 catstr <??004E>, ??004F, ??0050
			     2				??004F catstr <, >
			     2			endm
			     3				push  ax
			     3				??0050 catstr <ax>, ??004F, ??0050
			     3				??004F catstr <, >
			     3				push  dx
			     3				??0050 catstr <dx>, ??004F, ??0050
			     3				??004F catstr <, >
			     2			??0050 catstr OPEN_DELIMITER, ??0050, CLOSE_DELIMITER
			     2			__pushRegs ??0050
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0050
			     3			else
			     3				regStack catstr ??0050, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0052 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0052 eq 0
			     3				??0053     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0053 substr regStack, 1, (??0052 - 1)      
			     3				regStack substr regStack, (??0052 + 1)     
			     3			endif
			     3			exitm ??0053
			     2		for ??0051, <dx, ax> 
			     2				pop ??0051
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke ParseCommand
						ret
 05A7					ReadCommand endp
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
						SaveRegs ax, bx
						i = 0
						
						mov bx, memString
						
						forc char, <constStr>
							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
							cmp al, '&char'
							jne @@ne
							i = i + 1
						endm 
						mov ax, 1
						jmp @@done
						@@ne:
							mov ax, 0
						@@done:
							cmp ax, 0
							RestoreRegs
					endm
					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw
					endm
					; Return the value read in result, and the end of the string read in si
 05A7					ReadNumFromString proc near uses ax bx cx dx bp, string:ptr byte, result:ptr sword
						mov ax, 0
						mov bx, 0
						mov si, string
						mov cx, 0
						.if byte ptr [si] == '-'
							inc si
							mov cx, 1
						.endif
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
							mov dx, 10
							mul dx
							mov bl, [si]
							sub bl, '0'
							add ax, bx
							inc si
						.endw
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
						.if (cx)
							neg ax
						.endif
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
 0665					ReadNumFromString endp
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)
							stc
						.else
							mov resultReg, numberInMemory
							clc
						.endif
					endm
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
						
						.if (!zero?)
							add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif
					endm
					;   AX = command ID (CMD_*)
					;   BX = param1 (if any)
					;   CX = param2 (if any)
					;   DX = offset of string (WRITE)
 0665					ParseCommand proc near uses si di bp
						local a:sword
						mov si, offset CommandBufferString
						
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
			     1			StartsWith <MUL> si
			     2			SaveRegs ax, bx
			     3			??0059     textequ <>
			     3			??005A textequ <>
			     3			for       ??0058, <ax,bx>
			     3				push  ??0058
			     3				??005A catstr <??0058>, ??0059, ??005A
			     3				??0059 catstr <, >
			     3			endm
			     4				push  ax
			     4				??005A catstr <ax>, ??0059, ??005A
			     4				??0059 catstr <, >
			     4				push  bx
			     4				??005A catstr <bx>, ??0059, ??005A
			     4				??0059 catstr <, >
			     3			??005A catstr OPEN_DELIMITER, ??005A, CLOSE_DELIMITER
			     3			__pushRegs ??005A
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??005A
			     4			else
			     4				regStack catstr ??005A, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0054 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0054]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0056
			     2				??0054 = ??0054 + 1
			     2			endm 
			     3				mov al, [bx+??0054]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'M'
			     3				jne ??0056
			     3	
 = 0001			     3				??0054 = ??0054 + 1
			     3				mov al, [bx+??0054]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??0056
			     3	
 = 0002			     3				??0054 = ??0054 + 1
			     3				mov al, [bx+??0054]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'L'
			     3				jne ??0056
			     3	
 = 0003			     3				??0054 = ??0054 + 1
			     2			mov ax, 1
			     2			jmp ??0057
			     2			??0056:
			     2				mov ax, 0
			     2			??0057:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??005C instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005C eq 0
			     4				??005D     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??005D substr regStack, 1, (??005C - 1)      
			     4				regStack substr regStack, (??005C + 1)     
			     4			endif
			     4			exitm ??005D
			     3		for ??005B, <bx, ax> 
			     3				pop ??005B
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@MUL
			     1			.endif
						jumpIfSIComparesTo <ADD> ParseCommand@ADD
			     1			StartsWith <ADD> si
			     2			SaveRegs ax, bx
			     3			??0063     textequ <>
			     3			??0064 textequ <>
			     3			for       ??0062, <ax,bx>
			     3				push  ??0062
			     3				??0064 catstr <??0062>, ??0063, ??0064
			     3				??0063 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0064 catstr <ax>, ??0063, ??0064
			     4				??0063 catstr <, >
			     4				push  bx
			     4				??0064 catstr <bx>, ??0063, ??0064
			     4				??0063 catstr <, >
			     3			??0064 catstr OPEN_DELIMITER, ??0064, CLOSE_DELIMITER
			     3			__pushRegs ??0064
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0064
			     4			else
			     4				regStack catstr ??0064, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??005E = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??005E]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0060
			     2				??005E = ??005E + 1
			     2			endm 
			     3				mov al, [bx+??005E]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'A'
			     3				jne ??0060
			     3	
 = 0001			     3				??005E = ??005E + 1
			     3				mov al, [bx+??005E]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0060
			     3	
 = 0002			     3				??005E = ??005E + 1
			     3				mov al, [bx+??005E]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0060
			     3	
 = 0003			     3				??005E = ??005E + 1
			     2			mov ax, 1
			     2			jmp ??0061
			     2			??0060:
			     2				mov ax, 0
			     2			??0061:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0066 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0066 eq 0
			     4				??0067     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0067 substr regStack, 1, (??0066 - 1)      
			     4				regStack substr regStack, (??0066 + 1)     
			     4			endif
			     4			exitm ??0067
			     3		for ??0065, <bx, ax> 
			     3				pop ??0065
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@ADD
			     1			.endif
						jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
			     1			StartsWith <UNDO> si
			     2			SaveRegs ax, bx
			     3			??006D     textequ <>
			     3			??006E textequ <>
			     3			for       ??006C, <ax,bx>
			     3				push  ??006C
			     3				??006E catstr <??006C>, ??006D, ??006E
			     3				??006D catstr <, >
			     3			endm
			     4				push  ax
			     4				??006E catstr <ax>, ??006D, ??006E
			     4				??006D catstr <, >
			     4				push  bx
			     4				??006E catstr <bx>, ??006D, ??006E
			     4				??006D catstr <, >
			     3			??006E catstr OPEN_DELIMITER, ??006E, CLOSE_DELIMITER
			     3			__pushRegs ??006E
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??006E
			     4			else
			     4				regStack catstr ??006E, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0068 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??0068]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??006A
			     2				??0068 = ??0068 + 1
			     2			endm 
			     3				mov al, [bx+??0068]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??006A
			     3	
 = 0001			     3				??0068 = ??0068 + 1
			     3				mov al, [bx+??0068]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'N'
			     3				jne ??006A
			     3	
 = 0002			     3				??0068 = ??0068 + 1
			     3				mov al, [bx+??0068]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??006A
			     3	
 = 0003			     3				??0068 = ??0068 + 1
			     3				mov al, [bx+??0068]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'O'
			     3				jne ??006A
			     3	
 = 0004			     3				??0068 = ??0068 + 1
			     2			mov ax, 1
			     2			jmp ??006B
			     2			??006A:
			     2				mov ax, 0
			     2			??006B:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0070 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0070 eq 0
			     4				??0071     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0071 substr regStack, 1, (??0070 - 1)DELIMI
			     4				regStack substr regStack, (??0070 + 1)DELIM
			     4			endif
			     4			exitm ??0071
			     3		for ??006F, <bx, ax> 
			     3				pop ??006F
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@UNDO
			     1			.endif
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
			     1			StartsWith <WRITE> si
			     2			SaveRegs ax, bx
			     3			??0077     textequ <>
			     3			??0078 textequ <>
			     3			for       ??0076, <ax,bx>
			     3				push  ??0076
			     3				??0078 catstr <??0076>, ??0077, ??0078
			     3				??0077 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0078 catstr <ax>, ??0077, ??0078
			     4				??0077 catstr <, >
			     4				push  bx
			     4				??0078 catstr <bx>, ??0077, ??0078
			     4				??0077 catstr <, >
			     3			??0078 catstr OPEN_DELIMITER, ??0078, CLOSE_DELIMITER
			     3			__pushRegs ??0078
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0078
			     4			else
			     4				regStack catstr ??0078, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0072 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0072]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0074
			     2				??0072 = ??0072 + 1
			     2			endm 
			     3				mov al, [bx+??0072]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'W'
			     3				jne ??0074
			     3	
 = 0001			     3				??0072 = ??0072 + 1
			     3				mov al, [bx+??0072]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'R'
			     3				jne ??0074
			     3	
 = 0002			     3				??0072 = ??0072 + 1
			     3				mov al, [bx+??0072]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0074
			     3	
 = 0003			     3				??0072 = ??0072 + 1
			     3				mov al, [bx+??0072]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0074
			     3	
 = 0004			     3				??0072 = ??0072 + 1
			     3				mov al, [bx+??0072]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??0074
			     3	
 = 0005			     3				??0072 = ??0072 + 1
			     2			mov ax, 1
			     2			jmp ??0075
			     2			??0074:
			     2				mov ax, 0
			     2			??0075:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??007A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??007A eq 0
			     4				??007B     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??007B substr regStack, 1, (??007A - 1)R, reg
			     4				regStack substr regStack, (??007A + 1)R, re
			     4			endif
			     4			exitm ??007B
			     3		for ??0079, <bx, ax> 
			     3				pop ??0079
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 05
			     1				jmp ParseCommand@WRITE
			     1			.endif
						jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
			     1			StartsWith <EXIT> si
			     2			SaveRegs ax, bx
			     3			??0081     textequ <>
			     3			??0082 textequ <>
			     3			for       ??0080, <ax,bx>
			     3				push  ??0080
			     3				??0082 catstr <??0080>, ??0081, ??0082
			     3				??0081 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0082 catstr <ax>, ??0081, ??0082
			     4				??0081 catstr <, >
			     4				push  bx
			     4				??0082 catstr <bx>, ??0081, ??0082
			     4				??0081 catstr <, >
			     3			??0082 catstr OPEN_DELIMITER, ??0082, CLOSE_DELIMITER
			     3			__pushRegs ??0082
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0082
			     4			else
			     4				regStack catstr ??0082, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??007C = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??007C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007E
			     2				??007C = ??007C + 1
			     2			endm 
			     3				mov al, [bx+??007C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??007E
			     3	
 = 0001			     3				??007C = ??007C + 1
			     3				mov al, [bx+??007C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'X'
			     3				jne ??007E
			     3	
 = 0002			     3				??007C = ??007C + 1
			     3				mov al, [bx+??007C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??007E
			     3	
 = 0003			     3				??007C = ??007C + 1
			     3				mov al, [bx+??007C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??007E
			     3	
 = 0004			     3				??007C = ??007C + 1
			     2			mov ax, 1
			     2			jmp ??007F
			     2			??007E:
			     2				mov ax, 0
			     2			??007F:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0084 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0084 eq 0
			     4				??0085     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0085 substr regStack, 1, (??0084 - 1)      
			     4				regStack substr regStack, (??0084 + 1)     
			     4			endif
			     4			exitm ??0085
			     3		for ??0083, <bx, ax> 
			     3				pop ??0083
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
						jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
			     1			StartsWith <QUIT> si
			     2			SaveRegs ax, bx
			     3			??008B     textequ <>
			     3			??008C textequ <>
			     3			for       ??008A, <ax,bx>
			     3				push  ??008A
			     3				??008C catstr <??008A>, ??008B, ??008C
			     3				??008B catstr <, >
			     3			endm
			     4				push  ax
			     4				??008C catstr <ax>, ??008B, ??008C
			     4				??008B catstr <, >
			     4				push  bx
			     4				??008C catstr <bx>, ??008B, ??008C
			     4				??008B catstr <, >
			     3			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     3			__pushRegs ??008C
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??008C
			     4			else
			     4				regStack catstr ??008C, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0086 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??0086]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0088
			     2				??0086 = ??0086 + 1
			     2			endm 
			     3				mov al, [bx+??0086]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'Q'
			     3				jne ??0088
			     3	
 = 0001			     3				??0086 = ??0086 + 1
			     3				mov al, [bx+??0086]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??0088
			     3	
 = 0002			     3				??0086 = ??0086 + 1
			     3				mov al, [bx+??0086]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0088
			     3	
 = 0003			     3				??0086 = ??0086 + 1
			     3				mov al, [bx+??0086]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0088
			     3	
 = 0004			     3				??0086 = ??0086 + 1
			     2			mov ax, 1
			     2			jmp ??0089
			     2			??0088:
			     2				mov ax, 0
			     2			??0089:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??008E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??008E eq 0
			     4				??008F     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??008F substr regStack, 1, (??008E - 1)      
			     4				regStack substr regStack, (??008E + 1)     
			     4			endif
			     4			exitm ??008F
			     3		for ??008D, <bx, ax> 
			     3				pop ??008D
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
					
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			??0091     textequ <>
			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0092 catstr <ax>, ??0091, ??0092
			     5				??0091 catstr <, >
			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@Comando>, <si>
			     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>>, 
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
			     5				??0095     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)??0081
			     5				regStack substr regStack, (??0094 + 1)??008
			     5			endif
			     5			exitm ??0095
			     4		for ??0093, <ax> 
			     4				pop ??0093
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di      
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			??0097     textequ <>
			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0098 catstr <ax>, ??0097, ??0098
			     5				??0097 catstr <, >
			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@space>, <si>
			     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii> <s
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
			     5				??009B     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)      
			     5				regStack substr regStack, (??009A + 1)     
			     5			endif
			     5			exitm ??009B
			     4		for ??0099, <ax> 
			     4				pop ??0099
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@space>, dii    
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			??009D     textequ <>
			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
			     5				push  ax
			     5				??009E catstr <ax>, ??009D, ??009E
			     5				??009D catstr <, >
			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
			     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>cid
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
			     5				??00A1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)      
			     5				regStack substr regStack, (??00A0 + 1)     
			     5			endif
			     5			exitm ??00A1
			     4		for ??009F, <ax> 
			     4				pop ??009F
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, di      
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??00A3     textequ <>
			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00A4 catstr <ax>, ??00A3, ??00A4
			     5				??00A3 catstr <, >
			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack2_DEL
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
			     5				??00A7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)      
			     5				regStack substr regStack, (??00A6 + 1)     
			     5			endif
			     5			exitm ??00A7
			     4		for ??00A5, <ax> 
			     4				pop ??00A5
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di      
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??00A9     textequ <>
			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00AA catstr <ax>, ??00A9, ??00AA
			     5				??00A9 catstr <, >
			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
			     5				??00AD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)      
			     5				regStack substr regStack, (??00AC + 1)     
			     5			endif
			     5			exitm ??00AD
			     4		for ??00AB, <ax> 
			     4				pop ??00AB
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di     
			     2				endif
					ParseCommand@error:
						stc
						ret
					ParseCommand@MUL:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.endif
						
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
						mov ax, CMD_MUL
						jmp ParseCommand@success
					ParseCommand@ADD:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
						mov ax, CMD_ADD
						
						jmp ParseCommand@success
					ParseCommand@UNDO:
						mov ax, CMD_UNDO
						jmp ParseCommand@success
					ParseCommand@WRITE:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
							inc si
						.endw
						jmp ParseCommand@success
					ParseCommand@EXIT:
						jmp ParseCommand@success
					ParseCommand@success:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						.if (byte ptr [si] != 0)
						
							strcpy_all                                          NonTerminalErrorBuffer, \
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			??00AF     textequ <>
			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
			     5				push  ax
			     5				??00B0 catstr <ax>, ??00AF, ??00B0
			     5				??00AF catstr <, >
			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
			     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ros
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
			     5				??00B3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)      
			     5				regStack substr regStack, (??00B2 + 1)     
			     5			endif
			     5			exitm ??00B3
			     4		for ??00B1, <ax> 
			     4				pop ??00B1
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di      
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??00B5     textequ <>
			     4			??00B6 textequ <>
			     4			for       ??00B4, <ax>
			     4				push  ??00B4
			     4				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     4				??00B5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00B6 catstr <ax>, ??00B5, ??00B6
			     5				??00B5 catstr <, >
			     4			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
			     4			__pushRegs ??00B6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00B6
			     5			else
			     5				regStack catstr ??00B6, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00B8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B8 eq 0
			     5				??00B9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00B9 substr regStack, 1, (??00B8 - 1)      
			     5				regStack substr regStack, (??00B8 + 1)     
			     5			endif
			     5			exitm ??00B9
			     4		for ??00B7, <ax> 
			     4				pop ??00B7
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, didos_ao
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??00BB     textequ <>
			     4			??00BC textequ <>
			     4			for       ??00BA, <ax>
			     4				push  ??00BA
			     4				??00BC catstr <??00BA>, ??00BB, ??00BC
			     4				??00BB catstr <, >
			     4			endm
			     5				push  ax
			     5				??00BC catstr <ax>, ??00BB, ??00BC
			     5				??00BB catstr <, >
			     4			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
			     4			__pushRegs ??00BC
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00BC
			     5			else
			     5				regStack catstr ??00BC, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00BE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00BE eq 0
			     5				??00BF     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00BF substr regStack, 1, (??00BE - 1)      
			     5				regStack substr regStack, (??00BE + 1)     
			     5			endif
			     5			exitm ??00BF
			     4		for ??00BD, <ax> 
			     4				pop ??00BD
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, didos_a
			     2				endif
							
							jmp ParseCommand@error
						.endif
						clc
						ret
 0D56					ParseCommand endp
 0D56					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C2 catstr <ax>, ??00C1, ??00C2
			     6				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
			     5			__pushRegs ??00C2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00C4 eq 0
			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)0AF ca
			     6				regStack substr regStack, (??00C4 + 1)0AF c
			     6			endif
			     6			exitm ??00C5
			     5		for ??00C3, <ax> 
			     5				pop ??00C3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di 
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>Ã  
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C8 catstr <ax>, ??00C7, ??00C8
			     6				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
			     5			__pushRegs ??00C8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00CA eq 0
			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)      
			     6				regStack substr regStack, (??00CA + 1)     
			     6			endif
			     6			exitm ??00CB
			     5		for ??00C9, <ax> 
			     5				pop ??00C9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , di di 
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00CE catstr <ax>, ??00CD, ??00CE
			     6				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
			     5			__pushRegs ??00CE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D0 eq 0
			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)      
			     6				regStack substr regStack, (??00D0 + 1)     
			     6			endif
			     6			exitm ??00D1
			     5		for ??00CF, <ax> 
			     5				pop ??00CF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, dii   
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , di    
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00D4 catstr <ax>, ??00D3, ??00D4
			     6				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
			     5			__pushRegs ??00D4
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D6 eq 0
			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)      
			     6				regStack substr regStack, (??00D6 + 1)     
			     6			endif
			     6			exitm ??00D7
			     5		for ??00D5, <ax> 
			     5				pop ??00D5
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00DA catstr <ax>, ??00D9, ??00DA
			     6				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
			     5			__pushRegs ??00DA
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00DC eq 0
			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)      
			     6				regStack substr regStack, (??00DC + 1)     
			     6			endif
			     6			exitm ??00DD
			     5		for ??00DB, <ax> 
			     5				pop ??00DB
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E0 catstr <ax>, ??00DF, ??00E0
			     6				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
			     5			__pushRegs ??00E0
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E2 eq 0
			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)kt  
			     6				regStack substr regStack, (??00E2 + 1)kt 
			     6			endif
			     6			exitm ??00E3
			     5		for ??00E1, <ax> 
			     5				pop ??00E1
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0EA2					ParseCommand@LINHA_AUSENTE endp
 0EA2					ParseCommand@CONSTANTE_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E6 catstr <ax>, ??00E5, ??00E6
			     6				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
			     5			__pushRegs ??00E6
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E8 eq 0
			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)      
			     6				regStack substr regStack, (??00E8 + 1)     
			     6			endif
			     6			exitm ??00E9
			     5		for ??00E7, <ax> 
			     5				pop ??00E7
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di     
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>Ú  
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
			     5			endm
			     6				push  ax
			     6				??00EC catstr <ax>, ??00EB, ??00EC
			     6				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
			     5			__pushRegs ??00EC
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00EE eq 0
			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)      
			     6				regStack substr regStack, (??00EE + 1)     
			     6			endif
			     6			exitm ??00EF
			     5		for ??00ED, <ax> 
			     5				pop ??00ED
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di    
			     3				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  CONSTANTE , di    
			     3				else
			     3					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'C'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F2 catstr <ax>, ??00F1, ??00F2
			     6				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
			     5			__pushRegs ??00F2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00F4 eq 0
			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)      
			     6				regStack substr regStack, (??00F4 + 1)     
			     6			endif
			     6			exitm ??00F5
			     5		for ??00F3, <ax> 
			     5				pop ??00F3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi  
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi  
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F8 catstr <ax>, ??00F7, ??00F8
			     6				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
			     5			__pushRegs ??00F8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00FA eq 0
			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)      
			     6				regStack substr regStack, (??00FA + 1)     
			     6			endif
			     6			exitm ??00FB
			     5		for ??00F9, <ax> 
			     5				pop ??00F9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00FE catstr <ax>, ??00FD, ??00FE
			     6				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
			     5			__pushRegs ??00FE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0100 eq 0
			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)0EB ca
			     6				regStack substr regStack, (??0100 + 1)0EB c
			     6			endif
			     6			exitm ??0101
			     5		for ??00FF, <ax> 
			     5				pop ??00FF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0104 catstr <ax>, ??0103, ??0104
			     6				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
			     5			__pushRegs ??0104
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0106 eq 0
			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)DELIMI
			     6				regStack substr regStack, (??0106 + 1)DELIM
			     6			endif
			     6			exitm ??0107
			     5		for ??0105, <ax> 
			     5				pop ??0105
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0FFA					ParseCommand@CONSTANTE_AUSENTE endp
					
 0FFA					ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
			     5			endm
			     6				push  ax
			     6				??010A catstr <ax>, ??0109, ??010A
			     6				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
			     5			__pushRegs ??010A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??010C eq 0
			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)      
			     6				regStack substr regStack, (??010C + 1)     
			     6			endif
			     6			exitm ??010D
			     5		for ??010B, <ax> 
			     5				pop ??010B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, di 
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0110 catstr <ax>, ??010F, ??0110
			     6				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
			     5			__pushRegs ??0110
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0112 eq 0
			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)      
			     6				regStack substr regStack, (??0112 + 1)     
			     6			endif
			     6			exitm ??0113
			     5		for ??0111, <ax> 
			     5				pop ??0111
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , di     
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0116 catstr <ax>, ??0115, ??0116
			     6				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
			     5			__pushRegs ??0116
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0118 eq 0
			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)      
			     6				regStack substr regStack, (??0118 + 1)     
			     6			endif
			     6			exitm ??0119
			     5		for ??0117, <ax> 
			     5				pop ??0117
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , dii    
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>i],
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
			     5			endm
			     6				push  ax
			     6				??011C catstr <ax>, ??011B, ??011C
			     6				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
			     5			__pushRegs ??011C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??011E eq 0
			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)      
			     6				regStack substr regStack, (??011E + 1)     
			     6			endif
			     6			exitm ??011F
			     5		for ??011D, <ax> 
			     5				pop ??011D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0122 catstr <ax>, ??0121, ??0122
			     6				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
			     5			__pushRegs ??0122
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0124 eq 0
			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1){;  
			     6				regStack substr regStack, (??0124 + 1){; 
			     6			endif
			     6			exitm ??0125
			     5		for ??0123, <ax> 
			     5				pop ??0123
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0128 catstr <ax>, ??0127, ??0128
			     6				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
			     5			__pushRegs ??0128
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??012A eq 0
			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1)      
			     6				regStack substr regStack, (??012A + 1)     
			     6			endif
			     6			exitm ??012B
			     5		for ??0129, <ax> 
			     5				pop ??0129
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 1156					ParseCommand@LINHA_DST_AUSENTE endp
 1156					ParseCommand@LINHA_ORG_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
			     5			endm
			     6				push  ax
			     6				??012E catstr <ax>, ??012D, ??012E
			     6				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
			     5			__pushRegs ??012E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0130 eq 0
			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)      
			     6				regStack substr regStack, (??0130 + 1)     
			     6			endif
			     6			exitm ??0131
			     5		for ??012F, <ax> 
			     5				pop ??012F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, di 
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii> 
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0134 catstr <ax>, ??0133, ??0134
			     6				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
			     5			__pushRegs ??0134
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0136 eq 0
			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1)      
			     6				regStack substr regStack, (??0136 + 1)     
			     6			endif
			     6			exitm ??0137
			     5		for ??0135, <ax> 
			     5				pop ??0135
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di     
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
			     5			endm
			     6				push  ax
			     6				??013A catstr <ax>, ??0139, ??013A
			     6				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
			     5			__pushRegs ??013A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??013C eq 0
			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)      
			     6				regStack substr regStack, (??013C + 1)     
			     6			endif
			     6			exitm ??013D
			     5		for ??013B, <ax> 
			     5				pop ??013B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi   
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0140 catstr <ax>, ??013F, ??0140
			     6				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
			     5			__pushRegs ??0140
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0142 eq 0
			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)      
			     6				regStack substr regStack, (??0142 + 1)     
			     6			endif
			     6			exitm ??0143
			     5		for ??0141, <ax> 
			     5				pop ??0141
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0146 catstr <ax>, ??0145, ??0146
			     6				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
			     5			__pushRegs ??0146
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0148 eq 0
			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)      
			     6				regStack substr regStack, (??0148 + 1)     
			     6			endif
			     6			exitm ??0149
			     5		for ??0147, <ax> 
			     5				pop ??0147
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
			     5			endm
			     6				push  ax
			     6				??014C catstr <ax>, ??014B, ??014C
			     6				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
			     5			__pushRegs ??014C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??014E eq 0
			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)R, reg
			     6				regStack substr regStack, (??014E + 1)R, re
			     6			endif
			     6			exitm ??014F
			     5		for ??014D, <ax> 
			     5				pop ??014D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 12AE					ParseCommand@LINHA_ORG_AUSENTE endp
 12AE					ParseCommand@LINHA_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0152 catstr <ax>, ??0151, ??0152
			     6				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
			     5			__pushRegs ??0152
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0154 eq 0
			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)      
			     6				regStack substr regStack, (??0154 + 1)     
			     6			endif
			     6			exitm ??0155
			     5		for ??0153, <ax> 
			     5				pop ??0153
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , diro>, d
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0158 catstr <ax>, ??0157, ??0158
			     6				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
			     5			__pushRegs ??0158
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??015A eq 0
			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)R, reg
			     6				regStack substr regStack, (??015A + 1)R, re
			     6			endif
			     6			exitm ??015B
			     5		for ??0159, <ax> 
			     5				pop ??0159
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
			     5			endm
			     6				push  ax
			     6				??015E catstr <ax>, ??015D, ??015E
			     6				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
			     5			__pushRegs ??015E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0160 eq 0
			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)DELIMI
			     6				regStack substr regStack, (??0160 + 1)DELIM
			     6			endif
			     6			exitm ??0161
			     5		for ??015F, <ax> 
			     5				pop ??015F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0164 catstr <ax>, ??0163, ??0164
			     6				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
			     5			__pushRegs ??0164
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0166 eq 0
			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)      
			     6				regStack substr regStack, (??0166 + 1)     
			     6			endif
			     6			exitm ??0167
			     5		for ??0165, <ax> 
			     5				pop ??0165
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 1366					ParseCommand@LINHA_INVALIDA endp
 1366					ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
			     5			endm
			     6				push  ax
			     6				??016A catstr <ax>, ??0169, ??016A
			     6				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
			     5			__pushRegs ??016A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??016C eq 0
			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)      
			     6				regStack substr regStack, (??016C + 1)     
			     6			endif
			     6			exitm ??016D
			     5		for ??016B, <ax> 
			     5				pop ??016B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , di di  
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0170 catstr <ax>, ??016F, ??0170
			     6				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
			     5			__pushRegs ??0170
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0172 eq 0
			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)      
			     6				regStack substr regStack, (??0172 + 1)     
			     6			endif
			     6			exitm ??0173
			     5		for ??0171, <ax> 
			     5				pop ??0171
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0176 catstr <ax>, ??0175, ??0176
			     6				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
			     5			__pushRegs ??0176
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0178 eq 0
			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)      
			     6				regStack substr regStack, (??0178 + 1)     
			     6			endif
			     6			exitm ??0179
			     5		for ??0177, <ax> 
			     5				pop ??0177
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
			     5			endm
			     6				push  ax
			     6				??017C catstr <ax>, ??017B, ??017C
			     6				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
			     5			__pushRegs ??017C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??017E eq 0
			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)      
			     6				regStack substr regStack, (??017E + 1)     
			     6			endif
			     6			exitm ??017F
			     5		for ??017D, <ax> 
			     5				pop ??017D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 142E					ParseCommand@LINHA_DST_INVALIDA endp
 142E					ParseCommand@LINHA_ORG_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_ORG>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0182 catstr <ax>, ??0181, ??0182
			     6				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
			     5			__pushRegs ??0182
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0184 eq 0
			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)R, reg
			     6				regStack substr regStack, (??0184 + 1)R, re
			     6			endif
			     6			exitm ??0185
			     5		for ??0183, <ax> 
			     5				pop ??0183
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di di  
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0188 catstr <ax>, ??0187, ??0188
			     6				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
			     5			__pushRegs ??0188
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??018A eq 0
			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)181 ca
			     6				regStack substr regStack, (??018A + 1)181 c
			     6			endif
			     6			exitm ??018B
			     5		for ??0189, <ax> 
			     5				pop ??0189
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??018D     textequ <>
			     5			??018E textequ <>
			     5			for       ??018C, <ax>
			     5				push  ??018C
			     5				??018E catstr <??018C>, ??018D, ??018E
			     5				??018D catstr <, >
			     5			endm
			     6				push  ax
			     6				??018E catstr <ax>, ??018D, ??018E
			     6				??018D catstr <, >
			     5			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
			     5			__pushRegs ??018E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??018E
			     6			else
			     6				regStack catstr ??018E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0190 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0190 eq 0
			     6				??0191     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0191 substr regStack, 1, (??0190 - 1)      
			     6				regStack substr regStack, (??0190 + 1)     
			     6			endif
			     6			exitm ??0191
			     5		for ??018F, <ax> 
			     5				pop ??018F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0193     textequ <>
			     5			??0194 textequ <>
			     5			for       ??0192, <ax>
			     5				push  ??0192
			     5				??0194 catstr <??0192>, ??0193, ??0194
			     5				??0193 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0194 catstr <ax>, ??0193, ??0194
			     6				??0193 catstr <, >
			     5			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
			     5			__pushRegs ??0194
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0194
			     6			else
			     6				regStack catstr ??0194, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0196 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0196 eq 0
			     6				??0197     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0197 substr regStack, 1, (??0196 - 1)      
			     6				regStack substr regStack, (??0196 + 1)     
			     6			endif
			     6			exitm ??0197
			     5		for ??0195, <ax> 
			     5				pop ??0195
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 14F6					ParseCommand@LINHA_ORG_INVALIDA endp
				;====================================================================
				; Reading error reporting
					ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??0199     textequ <>
			     2			??019A textequ <>
			     2			for       ??0198, <ax,dx>
			     2				push  ??0198
			     2				??019A catstr <??0198>, ??0199, ??019A
			     2				??0199 catstr <, >
			     2			endm
			     3				push  ax
			     3				??019A catstr <ax>, ??0199, ??019A
			     3				??0199 catstr <, >
			     3				push  dx
			     3				??019A catstr <dx>, ??0199, ??019A
			     3				??0199 catstr <, >
			     2			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     2			__pushRegs ??019A
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??019A
			     3			else
			     3				regStack catstr ??019A, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??019C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??019C eq 0
			     3				??019D     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??019D substr regStack, 1, (??019C - 1)      
			     3				regStack substr regStack, (??019C + 1)     
			     3			endif
			     3			exitm ??019D
			     2		for ??019B, <dx, ax> 
			     2				pop ??019B
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRead:
						printf_c <Erro na leitura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??019F     textequ <>
			     2			??01A0 textequ <>
			     2			for       ??019E, <ax,dx>
			     2				push  ??019E
			     2				??01A0 catstr <??019E>, ??019F, ??01A0
			     2				??019F catstr <, >
			     2			endm
			     3				push  ax
			     3				??01A0 catstr <ax>, ??019F, ??01A0
			     3				??019F catstr <, >
			     3				push  dx
			     3				??01A0 catstr <dx>, ??019F, ??01A0
			     3				??019F catstr <, >
			     2			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     2			__pushRegs ??01A0
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01A0
			     3			else
			     3				regStack catstr ??01A0, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01A2 eq 0
			     3				??01A3     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01A3 substr regStack, 1, (??01A2 - 1)      
			     3				regStack substr regStack, (??01A2 + 1)     
			     3			endif
			     3			exitm ??01A3
			     2		for ??01A1, <dx, ax> 
			     2				pop ??01A1
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorColumnCount:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01A5     textequ <>
			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01A6 catstr <ax>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     5				push  dx
			     5				??01A6 catstr <dx>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack, > ?
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
			     5				??01A9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)      
			     5				regStack substr regStack, (??01A8 + 1)     
			     5			endif
			     5			exitm ??01A9
			     4		for ??01A7, <dx, ax> 
			     4				pop ??01A7
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01AB     textequ <>
			     4			??01AC textequ <>
			     4			for       ??01AA, <ax,dx>
			     4				push  ??01AA
			     4				??01AC catstr <??01AA>, ??01AB, ??01AC
			     4				??01AB catstr <, >
			     4			endm
			     5				push  ax
			     5				??01AC catstr <ax>, ??01AB, ??01AC
			     5				??01AB catstr <, >
			     5				push  dx
			     5				??01AC catstr <dx>, ??01AB, ??01AC
			     5				??01AB catstr <, >
			     4			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     4			__pushRegs ??01AC
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01AC
			     5			else
			     5				regStack catstr ??01AC, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01AE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01AE eq 0
			     5				??01AF     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01AF substr regStack, 1, (??01AE - 1)      
			     5				regStack substr regStack, (??01AE + 1)     
			     5			endif
			     5			exitm ??01AF
			     4		for ??01AD, <dx, ax> 
			     4				pop ??01AD
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01B1     textequ <>
			     4			??01B2 textequ <>
			     4			for       ??01B0, <ax,dx>
			     4				push  ??01B0
			     4				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     4				??01B1 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01B2 catstr <ax>, ??01B1, ??01B2
			     5				??01B1 catstr <, >
			     5				push  dx
			     5				??01B2 catstr <dx>, ??01B1, ??01B2
			     5				??01B1 catstr <, >
			     4			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     4			__pushRegs ??01B2
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01B2
			     5			else
			     5				regStack catstr ??01B2, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01B4 eq 0
			     5				??01B5     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01B5 substr regStack, 1, (??01B4 - 1)      
			     5				regStack substr regStack, (??01B4 + 1)     
			     5			endif
			     5			exitm ??01B5
			     4		for ??01B3, <dx, ax> 
			     4				pop ??01B3
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1			SaveRegs ax,   dx
			     2			??01B7     textequ <>
			     2			??01B8 textequ <>
			     2			for       ??01B6, <ax,dx>
			     2				push  ??01B6
			     2				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     2				??01B7 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01B8 catstr <ax>, ??01B7, ??01B8
			     3				??01B7 catstr <, >
			     3				push  dx
			     3				??01B8 catstr <dx>, ??01B7, ??01B8
			     3				??01B7 catstr <, >
			     2			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     2			__pushRegs ??01B8
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01B8
			     3			else
			     3				regStack catstr ??01B8, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'g'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??01BA instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01BA eq 0
			     3				??01BB     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01BB substr regStack, 1, (??01BA - 1)      
			     3				regStack substr regStack, (??01BA + 1)     
			     3			endif
			     3			exitm ??01BB
			     2		for ??01B9, <dx, ax> 
			     2				pop ??01B9
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRowCount:
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1			SaveRegs ax,   dx
			     2			??01BD     textequ <>
			     2			??01BE textequ <>
			     2			for       ??01BC, <ax,dx>
			     2				push  ??01BC
			     2				??01BE catstr <??01BC>, ??01BD, ??01BE
			     2				??01BD catstr <, >
			     2			endm
			     3				push  ax
			     3				??01BE catstr <ax>, ??01BD, ??01BE
			     3				??01BD catstr <, >
			     3				push  dx
			     3				??01BE catstr <dx>, ??01BD, ??01BE
			     3				??01BD catstr <, >
			     2			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     2			__pushRegs ??01BE
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01BE
			     3			else
			     3				regStack catstr ??01BE, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '1'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'O'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'f'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01C0 eq 0
			     3				??01C1     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01C1 substr regStack, 1, (??01C0 - 1)      
			     3				regStack substr regStack, (??01C0 + 1)     
			     3			endif
			     3			exitm ??01C1
			     2		for ??01BF, <dx, ax> 
			     2				pop ??01BF
			     2			endm
			     3				pop dx
			     3				pop ax
						print_TotalRowCol
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01C3     textequ <>
			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01C4 catstr <ax>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     5				push  dx
			     5				??01C4 catstr <dx>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
			     5				??01C7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)??01C3
			     5				regStack substr regStack, (??01C6 + 1)??01C
			     5			endif
			     5			exitm ??01C7
			     4		for ??01C5, <dx, ax> 
			     4				pop ??01C5
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01C9     textequ <>
			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01CA catstr <ax>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     5				push  dx
			     5				??01CA catstr <dx>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack?01BD,
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
			     5				??01CD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)      
			     5				regStack substr regStack, (??01CC + 1)     
			     5			endif
			     5			exitm ??01CD
			     4		for ??01CB, <dx, ax> 
			     4				pop ??01CB
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01CF     textequ <>
			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D0 catstr <ax>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     5				push  dx
			     5				??01D0 catstr <dx>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStackr <, >
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
			     5				??01D3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)R, reg
			     5				regStack substr regStack, (??01D2 + 1)R, re
			     5			endif
			     5			exitm ??01D3
			     4		for ??01D1, <dx, ax> 
			     4				pop ??01D1
			     4			endm
			     5				pop dx
			     5				pop ax
						jmp      ExitFailure
					ErrorUnexpectedChar:
						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01D5     textequ <>
			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D6 catstr <ax>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     5				push  dx
			     5				??01D6 catstr <dx>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
			     5				??01D9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)      
			     5				regStack substr regStack, (??01D8 + 1)     
			     5			endif
			     5			exitm ??01D9
			     4		for ??01D7, <dx, ax> 
			     4				pop ??01D7
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01DB     textequ <>
			     4			??01DC textequ <>
			     4			for       ??01DA, <ax,dx>
			     4				push  ??01DA
			     4				??01DC catstr <??01DA>, ??01DB, ??01DC
			     4				??01DB catstr <, >
			     4			endm
			     5				push  ax
			     5				??01DC catstr <ax>, ??01DB, ??01DC
			     5				??01DB catstr <, >
			     5				push  dx
			     5				??01DC catstr <dx>, ??01DB, ??01DC
			     5				??01DB catstr <, >
			     4			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     4			__pushRegs ??01DC
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01DC
			     5			else
			     5				regStack catstr ??01DC, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01DE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01DE eq 0
			     5				??01DF     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01DF substr regStack, 1, (??01DE - 1)      
			     5				regStack substr regStack, (??01DE + 1)     
			     5			endif
			     5			exitm ??01DF
			     4		for ??01DD, <dx, ax> 
			     4				pop ??01DD
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01E1     textequ <>
			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01E2 catstr <ax>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     5				push  dx
			     5				??01E2 catstr <dx>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
			     5				??01E5     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)      
			     5				regStack substr regStack, (??01E4 + 1)     
			     5			endif
			     5			exitm ??01E5
			     4		for ??01E3, <dx, ax> 
			     4				pop ??01E3
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: caracter inexperado: ">
			     1			SaveRegs ax,   dx
			     2			??01E7     textequ <>
			     2			??01E8 textequ <>
			     2			for       ??01E6, <ax,dx>
			     2				push  ??01E6
			     2				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     2				??01E7 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01E8 catstr <ax>, ??01E7, ??01E8
			     3				??01E7 catstr <, >
			     3				push  dx
			     3				??01E8 catstr <dx>, ??01E7, ??01E8
			     3				??01E7 catstr <, >
			     2			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     2			__pushRegs ??01E8
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01E8
			     3			else
			     3				regStack catstr ??01E8, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'x'
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '"'
			     2				int 21h
			     1			RestoreRegs
			     3			??01EA instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01EA eq 0
			     3				??01EB     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01EB substr regStack, 1, (??01EA - 1)      
			     3				regStack substr regStack, (??01EA + 1)     
			     3			endif
			     3			exitm ??01EB
			     2		for ??01E9, <dx, ax> 
			     2				pop ??01E9
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr TheUnexpectedChar
						jmp ExitFailure
					ErrorInvalidN:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01ED     textequ <>
			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
			     5				push  ax
			     5				??01EE catstr <ax>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     5				push  dx
			     5				??01EE catstr <dx>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
			     5				??01F1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)      
			     5				regStack substr regStack, (??01F0 + 1)     
			     5			endif
			     5			exitm ??01F1
			     4		for ??01EF, <dx, ax> 
			     4				pop ??01EF
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01F3     textequ <>
			     4			??01F4 textequ <>
			     4			for       ??01F2, <ax,dx>
			     4				push  ??01F2
			     4				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     4				??01F3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01F4 catstr <ax>, ??01F3, ??01F4
			     5				??01F3 catstr <, >
			     5				push  dx
			     5				??01F4 catstr <dx>, ??01F3, ??01F4
			     5				??01F3 catstr <, >
			     4			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     4			__pushRegs ??01F4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01F4
			     5			else
			     5				regStack catstr ??01F4, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F6 eq 0
			     5				??01F7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01F7 substr regStack, 1, (??01F6 - 1)ack  
			     5				regStack substr regStack, (??01F6 + 1)ack 
			     5			endif
			     5			exitm ??01F7
			     4		for ??01F5, <dx, ax> 
			     4				pop ??01F5
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01F9     textequ <>
			     4			??01FA textequ <>
			     4			for       ??01F8, <ax,dx>
			     4				push  ??01F8
			     4				??01FA catstr <??01F8>, ??01F9, ??01FA
			     4				??01F9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01FA catstr <ax>, ??01F9, ??01FA
			     5				??01F9 catstr <, >
			     5				push  dx
			     5				??01FA catstr <dx>, ??01F9, ??01FA
			     5				??01F9 catstr <, >
			     4			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     4			__pushRegs ??01FA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01FA
			     5			else
			     5				regStack catstr ??01FA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01FC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01FC eq 0
			     5				??01FD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01FD substr regStack, 1, (??01FC - 1)      
			     5				regStack substr regStack, (??01FC + 1)     
			     5			endif
			     5			exitm ??01FD
			     4		for ??01FB, <dx, ax> 
			     4				pop ??01FB
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1			SaveRegs ax,   dx
			     2			??01FF     textequ <>
			     2			??0200 textequ <>
			     2			for       ??01FE, <ax,dx>
			     2				push  ??01FE
			     2				??0200 catstr <??01FE>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     2			endm
			     3				push  ax
			     3				??0200 catstr <ax>, ??01FF, ??0200
			     3				??01FF catstr <, >
			     3				push  dx
			     3				??0200 catstr <dx>, ??01FF, ??0200
			     3				??01FF catstr <, >
			     2			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     2			__pushRegs ??0200
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0200
			     3			else
			     3				regStack catstr ??0200, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '2'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '7'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??0202 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0202 eq 0
			     3				??0203     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0203 substr regStack, 1, (??0202 - 1)??01F9
			     3				regStack substr regStack, (??0202 + 1)??01F
			     3			endif
			     3			exitm ??0203
			     2		for ??0201, <dx, ax> 
			     2				pop ??0201
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_u, N
						jmp      ExitFailure
					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
			     1			SaveRegs ax,   dx
			     2			??0205     textequ <>
			     2			??0206 textequ <>
			     2			for       ??0204, <ax,dx>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0206 catstr <ax>, ??0205, ??0206
			     3				??0205 catstr <, >
			     3				push  dx
			     3				??0206 catstr <dx>, ??0205, ??0206
			     3				??0205 catstr <, >
			     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'U'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
			     3				??0209     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)      
			     3				regStack substr regStack, (??0208 + 1)     
			     3			endif
			     3			exitm ??0209
			     2		for ??0207, <dx, ax> 
			     2				pop ??0207
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
				;====================================================================
				; Reading Functions
					HandleCR macro
						invoke PeekChar
						mov    bh, PeekBuffer
						.if    bh != LF
							jmp ErrorUnexpectedChar
						.endif
					endm
					
 1B47					ReadEmptyLines proc near uses ax bx cx dx bp
						invoke ReadChar
						.while ax != 0
							mov bl, FileBuffer
							.if bl == LF
								inc FileLine
								mov FileCol, 1
							.elseif bl == CR
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.else
								jmp ErrorUnexpectedChar
							.endif
							invoke ReadChar
						.endw
						ret
 1BFF					ReadEmptyLines endp
 1BFF					OpenFile proc near
						SaveRegs ax,         dx
			     1			??020B     textequ <>
			     1			??020C textequ <>
			     1			for       ??020A, <ax,dx>
			     1				push  ??020A
			     1				??020C catstr <??020A>, ??020B, ??020C
			     1				??020B catstr <, >
			     1			endm
			     2				push  ax
			     2				??020C catstr <ax>, ??020B, ??020C
			     2				??020B catstr <, >
			     2				push  dx
			     2				??020C catstr <dx>, ??020B, ??020C
			     2				??020B catstr <, >
			     1			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     1			__pushRegs ??020C
			     2			size_s sizestr regStack
			     2			if     size_s eq 0
			     2				regStack catstr ??020C
			     2			else
			     2				regStack catstr ??020C, REG_SET_DELIMITER, regStack      
			     2			endif
						mov      al,         0
						lea      dx,         FileName
						mov      ah,         3dh
						int      21h
						.if (carry?)
							call ErrorOpen
						.endif
						mov      FileHandle, ax
						mov      FileIsOpen, 1
						RestoreRegs
			     2			??020E instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??020E eq 0
			     2				??020F     substr regStack, 1
			     2				regStack textequ <>
			     2			else
			     2				??020F substr regStack, 1, (??020E - 1)      
			     2				regStack substr regStack, (??020E + 1)     
			     2			endif
			     2			exitm ??020F
			     1		for ??020D, <dx, ax> 
			     1				pop ??020D
			     1			endm
			     2				pop dx
			     2				pop ax
						ret
 1C21					OpenFile endp
 1C21					ReadChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
						ret
 1C3D					ReadChar endp
 1C3D					ReadCharTo proc near uses bx cx dx bp, Buffer:ptr byte
						mov dx, Buffer
						mov bx, FileHandle
						mov ah, 3Fh
						mov cx, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						; EOF
						.if ax == 0
							mov bx,           dx
							mov byte ptr[bx], 0
						.endif
						ret
 1C81					ReadCharTo endp
 1C81					MoveBack proc near uses ax bx cx dx bp
						; Move back by one byte
						mov bx, FileHandle
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
						mov al, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						ret
 1CA7					MoveBack endp
 1CA7					PeekChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr PeekBuffer
						invoke MoveBack
						ret
 1CBB					PeekChar endp
 1CBB					ReadNum proc near uses ax bx cx dx bp, result:ptr word
						invoke ReadChar
						mov    ax, 0
						mov    bx, 0
						mov    cx, 10
						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
							mul cx
							sub bl, '0'
							add ax, bx
							push   ax
							invoke ReadChar
							pop    ax
							mov    bl, FileBuffer
						.endw
						invoke MoveBack
						mov bx,           result
						mov word ptr[bx], ax
						ret
 1D2A					ReadNum endp
 1D2A					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
						ReadMatrixLoop:
							invoke ReadChar
							.if    ax == 0  ; EOF
								mov al,       TotalCol
								inc al                 ; TotalCol starts at 0
								mov NPlusOne, al
								dec al                 ; ax = N
								mov N,        al       ; TotalCol starts at 0
								dec al
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
									jmp ErrorInvalidN
								.endif
								jmp EndReading
							.endif
							mov bl, FileBuffer
							.if bl == 3Bh
								inc Col
							.elseif bl == LF
								inc FileLine
								mov FileCol, 1
								;====================================================================
								; On a new line, the number of columns should always be the same
								mov al,      Col
								.if Row == 0
									mov TotalCol, al
								.elseif TotalCol != al
									jmp ErrorColumnCount
								.endif
								;====================================================================
								; If next line is empty, all next lines should be empty
								invoke PeekChar
								mov    bh, PeekBuffer
								.if    bh == LF || bh == CR
									invoke ReadEmptyLines
								;====================================================================
								; Otherwise, next line must have data
								.else
									inc Row
									inc TotalRow
									mov Col, 0
								.endif
							.elseif bl == CR
							; accept CR only before LF
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.elseif (bl == '-')
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??0211     textequ <>
			     2			??0212 textequ <>
			     2			for       ??0210, <ax>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0212 catstr <ax>, ??0211, ??0212
			     3				??0211 catstr <, >
			     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
			     3				??0215     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)      
			     3				regStack substr regStack, (??0214 + 1)     
			     3			endif
			     3			exitm ??0215
			     2		for ??0213, <ax> 
			     2				pop ??0213
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
								neg    sword ptr [bx]
							.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??0217     textequ <>
			     2			??0218 textequ <>
			     2			for       ??0216, <ax>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0218 catstr <ax>, ??0217, ??0218
			     3				??0217 catstr <, >
			     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
			     3				??021B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)      
			     3				regStack substr regStack, (??021A + 1)     
			     3			endif
			     3			exitm ??021B
			     2		for ??0219, <ax> 
			     2				pop ??0219
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
							.else
								jmp ErrorUnexpectedChar
							.endif
							jmp ReadMatrixLoop
						EndReading:
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						ret
 1F85					ReadMatrix endp
				;====================================================================
				; Printf
 1F85					PrintMatrix proc near uses ax bx cx dx bp
						mov      bx, offset Matrix
						mov      dx, 8
						mov      cx, 0             ; High has row, Low has column
						.ForRow:                   ; for (row = 0; row < N; row++)
							cmp ch, N      ; row < N
							jge .EndForRow
							mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
								mov ax, sword ptr [bx]
								invoke printf_d_padded, ax, dx
								add bx, 2 ; size in bytes of a sword
								inc cl      ; col ++
								jmp .ForCol
							.EndForCol:
							putc CR
			     1			SaveRegs ax, dx
			     2			??021D     textequ <>
			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
			     3				push  ax
			     3				??021E catstr <ax>, ??021D, ??021E
			     3				??021D catstr <, >
			     3				push  dx
			     3				??021E catstr <dx>, ??021D, ??021E
			     3				??021D catstr <, >
			     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
			     3				??0221     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)      
			     3				regStack substr regStack, (??0220 + 1)     
			     3			endif
			     3			exitm ??0221
			     2		for ??021F, <dx, ax> 
			     2				pop ??021F
			     2			endm
			     3				pop dx
			     3				pop ax
							putc LF
			     1			SaveRegs ax, dx
			     2			??0223     textequ <>
			     2			??0224 textequ <>
			     2			for       ??0222, <ax,dx>
			     2				push  ??0222
			     2				??0224 catstr <??0222>, ??0223, ??0224
			     2				??0223 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0224 catstr <ax>, ??0223, ??0224
			     3				??0223 catstr <, >
			     3				push  dx
			     3				??0224 catstr <dx>, ??0223, ??0224
			     3				??0223 catstr <, >
			     2			??0224 catstr OPEN_DELIMITER, ??0224, CLOSE_DELIMITER
			     2			__pushRegs ??0224
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0224
			     3			else
			     3				regStack catstr ??0224, REG_SET_DELIMITER, regStack, > ?
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0226 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0226 eq 0
			     3				??0227     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0227 substr regStack, 1, (??0226 - 1)??021D
			     3				regStack substr regStack, (??0226 + 1)??021
			     3			endif
			     3			exitm ??0227
			     2		for ??0225, <dx, ax> 
			     2				pop ??0225
			     2			endm
			     3				pop dx
			     3				pop ax
							inc ch      ; row++
							jmp .ForRow
						.EndForRow:
						ret
 1FE0					PrintMatrix endp
 1FE0					printf_s proc near uses ax bx cx dx bp, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
							mov ah, 2
							mov dl, [bx]
							int 21H
							inc bx
						.endw
						ret
 201B					printf_s endp
 201B					printf_u proc near uses ax bx cx dx bp, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
						invoke printf_s, addr buf
						ret
 2049					printf_u endp
 2049					printf_d proc near uses ax bx cx dx bp, number:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						invoke printf_s, addr buf
						ret
 2077					printf_d endp
					
 2077					printf_d_padded proc near uses ax bx cx dx bp, number:sword, padTo:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						; string_from_sword gives length on AX
						mov    cx, padTo
						sub    cx, ax
						.WHILE (sword ptr cx > 0)
							putc SPACE
			     1			SaveRegs ax, dx
			     2			??0229     textequ <>
			     2			??022A textequ <>
			     2			for       ??0228, <ax,dx>
			     2				push  ??0228
			     2				??022A catstr <??0228>, ??0229, ??022A
			     2				??0229 catstr <, >
			     2			endm
			     3				push  ax
			     3				??022A catstr <ax>, ??0229, ??022A
			     3				??0229 catstr <, >
			     3				push  dx
			     3				??022A catstr <dx>, ??0229, ??022A
			     3				??0229 catstr <, >
			     2			??022A catstr OPEN_DELIMITER, ??022A, CLOSE_DELIMITER
			     2			__pushRegs ??022A
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??022A
			     3			else
			     3				regStack catstr ??022A, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, SPACE
			     1			int      21h
			     1			RestoreRegs
			     3			??022C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??022C eq 0
			     3				??022D     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??022D substr regStack, 1, (??022C - 1)      
			     3				regStack substr regStack, (??022C + 1)     
			     3			endif
			     3			exitm ??022D
			     2		for ??022B, <dx, ax> 
			     2				pop ??022B
			     2			endm
			     3				pop dx
			     3				pop ax
							dec  cx
						.ENDW
						invoke printf_s, addr buf
						ret
 20D5					printf_d_padded endp
					; length of string goes to ax (including sign)
 20D5					string_from_sword proc near uses bx cx dx bp, string:ptr byte, number:sword
						mov dx, number
						mov bx, string
						mov cx, 0
						.if (sword ptr dx < 0)
							mov byte ptr[bx], '-'
							inc bx
							inc cx
							neg dx
						.endif
						invoke string_from_word, bx, dx
						add ax, cx
						ret
 2118					string_from_sword endp
					; length of string goes to ax
 2118					string_from_word proc near uses bx cx dx bp si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
						mov divisor, 10000
						mov first,   1     ; anything not 0 is true
						mov ax,    number
						mov value, ax
						mov bx, string
						mov cx, 5
						.repeat
							mov dx,    0
							mov ax,    value
							div divisor
							mov value, dx
							.if (ax != 0) || (!first) ; no zeroes on the left
								add al,            '0'
								mov byte ptr [bx], al
								inc bx
								mov first,         0
							.endif
							mov dx,      0
							mov ax,      divisor
							mov si,      10
							div si
							mov divisor, ax
						.untilcxz
						.if (first)
							mov byte ptr [bx], '0'
							inc bx
						.endif
						mov cx, string
						mov ax, bx
						sub ax, cx     ; ax = bx - string = len
						mov byte ptr [bx], 0
						ret
 21BA					string_from_word endp
				;--------------------------------------------------------------------
				end
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:33:33
main.asm						     Page 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
				
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
				
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
				
				
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
				
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
				
					WRITEMatrix proto near, NOME:ptr byte
				
					PrintMatrix proto near
				
				;====================================================================
				; Memory
						.stack
 0000						.data
					
				
 = 0000					CMD_NONE  EQU 0
 = 0001					CMD_MUL   EQU 1
 = 0002					CMD_DIV   EQU 2
 = 0003					CMD_ADD   EQU 3
 = 0004					CMD_SUB   EQU 4
 = 0005					CMD_UNDO  EQU 5
 = 0006					CMD_WRITE EQU 6
				
 = 000D					CR            equ 0dh
 = 000A					LF            equ 0ah
 = 0022					QUOT          equ 22h
 = 003B					SEMI          equ 3Bh
 = SEMI					COL_SEPARATOR equ SEMI
 = 0020					SPACE         equ 20h
				
 0000 3B 00				COLUMN_SEP db ";",0
 0002 0D 0A 00				CRLF       db CR, LF, 0
				
 = 0064					BuffSize       equ 100              ; tam. mÃ¡ximo dos dados lidos no buffer
 0005 4D 41 54 2E 74 78			FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
       74 00
 000D  0064 [				FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
        00
       ]
 0071 0000				FileHandle     dw  0                ; Handler do arquivo
 0073 00				FileIsOpen     db  0                ; closed at the start
 0074  0096 [				FileNameBuffer db  150 dup (?)
        00
       ]
 010A 00				caractere      db  0
				
 010B FE				CommandBuffer       db 254
 010C 00				CommandBufferLength db 0          ; max length, actual length
 010D  00FE [				CommandBufferString db 254 dup(0)
        00
       ]
				
 020B 00				LastCommand   db 0
 020C 0000				LastCommand@a dw 0
 020E 0000				LastCommand@b sword 0
 0210 00				LastCommand@exists db 0
				
				
 0211  00FF [				NonTerminalErrorBuffer db 255 dup(0)
        00
       ]
				
 0310 43 6F 6D 61 6E 64			@Comando      db "Comando",0
       6F 00
 0318 65 73 70 65 72 61			@espera       db "espera",0
       00
 031F 63 6F 6D 6F 00			@como         db "como",0
 0324 70 61 72 61 6D 65			@parametro    db "parametro",0
       74 72 6F 00
 032E 50 61 72 61 6D 65			@@parametro   db "Parametro",0
       74 72 6F 00
 0338 64 65 73 63 6F 6E			@desconhecido db "desconhecido",0
       68 65 63 69 64 6F
       00
 0345 20 00				@space        db " ",0
				
 0347 64 65 76 65 20 65			@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
       73 74 61 72 20 65
       6E 74 72 65 20 31
       20 65 20 4E 00
 035E 4E 61 6F 20 66 6F			@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
       69 20 70 6F 73 73
       69 76 65 6C 20 61
       62 72 69 72 20 6F
       75 20 63 72 69 61
       72 20 6F 20 61 72
       71 75 69 76 6F 00
 0388 50 61 72 61 6D 65			@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
       74 72 6F 73 20 6E
       61 6F 20 72 65 63
       6F 6E 68 65 63 69
       64 6F 73 20 61 6F
       20 66 69 6E 61 6C
       20 64 6F 20 63 6F
       6D 61 6E 64 6F 00
					
 03B8 3A 20 00				COLON_SPACE db ": ",0
				
 = COLON_SPACE				ExplanationSeparator textequ <COLON_SPACE>
				
				
					; Used on PeekChar
 03BB 00				PeekBuffer        db ?
					; Used when reporting the error
 03BC 00 22 00				TheUnexpectedChar db 0,QUOT,0
					; used in main
 03BF 0001				FileCol           dw 1
 03C1 0001				FileLine          dw 1
				
 03C3 00				Row      byte 0
 03C4 00				Col      byte 0
 03C5 00				TotalRow byte 0
 03C6 00				TotalCol byte 0
				
 03C7 00				N        byte 0
 03C8 00				NPlusOne byte 0
					; should be at most 7x7
 03C9  0031 [				Matrix   sword (7 * 7) dup (?)
        0000
       ]
				
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
 = <					OPEN_DELIMITER    textequ <!<>
 = >					CLOSE_DELIMITER   textequ <!>>
 = |					REG_SET_DELIMITER textequ <|>
				
 = 					regStack textequ <> ; starts empty
				
					__popRegs macro
						local regs_end, regs		regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else			regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif		exitm regs
					endm
				
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else			regStack catstr regs, REG_SET_DELIMITER, regStack
						endif	endm
				
					SaveRegs macro regs:vararg
						local reg, comma, regpushed		comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
				
					RestoreRegs macro
						local reg	%	for reg, __popRegs(regStack) ;; Pop each register
							pop reg
						endm
					endm
				
					RegsInvokeUses textequ <ax bx cx dx bp>
				
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
 = ax bx cx dx bp				SaveRegs ax, dx
						mov      ah, 02h		mov      dl, c
 = bx cx dx bp					int      21h		RestoreRegs
 = ax cx dx bp				endm
				
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h		forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
				
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0	endm
				
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif		ifdifi <dst>, <di>
							lea di, dst
						endif		.repeat			mov al,   [si]			mov [di], al			inc si			inc di		.until (al == 0)		dec    si		dec    di		RestoreRegs
					endm
				
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> ; True
						ELSE			EXITM <0> ; False
						ENDIF	ENDM
				
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif		for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
				
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
				
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
				
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				
				;--------------------------------------------------------------------
				; Miscellaneous
				
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@Comando, !< &command !>, @espera, !< &paramName !>, @como, !< &positionName !>, @parametro, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@@parametro, !< &paramName !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
						<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
					endm
				
					CloseFileHandle macro
						mov ah, 3eh		mov bx, FileHandle		int 21h				mov FileIsOpen, 0 ; 0 means it is now closed	endm
				
					CurrentIndexToBx macro
						; returns in bx		SaveRegs ax
						mov      al, TotalCol		inc      al           ; TotalCol starts at 0
						mov bl, Row		mov bh, Col
						mul bl		add al, bh
						; got index, find position in array
						shl ax, 1		add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				
				;====================================================================
				; Program
					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
							putc   LF
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
				
						.if (ax == CMD_ADD)
							call Main@ADD
							jmp  @MainLoopEnd
						.elseif  (ax == CMD_MUL)
							call Main@MUL
							jmp  @MainLoopEnd
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
							jmp  @MainLoopEnd
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							putc CR
							putc LF
							jmp  @SkipPrint
						.endif
				
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
						putc LF
					jmp @whiletrue
				
 0000					Main@ADD proc near
						mov LastCommand,        CMD_ADD
 0000			   *@Startup:
 0000  BA ---- R	   *	    mov    dx, DGROUP
 0003  8E DA		   *	    mov    ds, dx
 0005  8C D3		   *	    mov    bx, ss
 0007  2B DA		   *	    sub    bx, dx
 0009  D1 E3		   *	    shl    bx, 001h
 000B  D1 E3		   *	    shl    bx, 001h
 000D  D1 E3		   *	    shl    bx, 001h
 000F  D1 E3		   *	    shl    bx, 001h
 0011  FA		   *	    cli    
 0012  8E D2		   *	    mov    ss, dx
 0014  03 E3		   *	    add    sp, bx
 0016  FB		   *	    sti    
						mov bh,                 0
 0017  E8 1323		   *	    call   ReadMatrix
 001A						mov LastCommand@a,      bx
						mov ch,                 0
 001A  E8 1436		   *	    call   PrintMatrix
 001D						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
 001D  E8 0359		   *	    call   ReadCommand
 0020				
 0020  73 28					invoke ADDMatrix, bl, cl
				
 0022  8D 06 0211 R	   *	    lea    ax, NonTerminalErrorBuffer
 0026  50		   *	    push   ax
 0027  E8 1471		   *	    call   printf_s
 002A  8D 1E 0211 R				ret
 002E  C6 07 00				Main@ADD endp
					Main@MUL proc near
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0001     textequ <>
 = 			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
 0031  50		     3				push  ax
 = ax			     3				??0002 catstr <ax>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 0032  52		     3				push  dx
 = dx, ax		     3				??0002 catstr <dx>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 = <dx, ax>		     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack
			     3			endif
 0033  B4 02		     1			mov      ah, 02h
 0035  B2 0D		     1			mov      dl, CR
 0037  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
 = <dx, ax>		     3				??0005     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)
			     3				regStack substr regStack, (??0004 + 1)
			     3			endif
			     3			exitm ??0005
			     2		%	for ??0003, __popRegs(regStack) 
			     2				pop ??0003
			     2			endm
 0039  5A		     3				pop dx
 003A  58		     3				pop ax
						mov LastCommand,        CMD_MUL
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0007     textequ <>
 = 			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
 003B  50		     3				push  ax
 = ax			     3				??0008 catstr <ax>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 003C  52		     3				push  dx
 = dx, ax		     3				??0008 catstr <dx>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 = <dx, ax>		     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack
			     3			endif
 003D  B4 02		     1			mov      ah, 02h
 003F  B2 0A		     1			mov      dl, LF
 0041  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
 = <dx, ax>		     3				??000B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)
			     3				regStack substr regStack, (??000A + 1)
			     3			endif
			     3			exitm ??000B
			     2		%	for ??0009, __popRegs(regStack) 
			     2				pop ??0009
			     2			endm
 0043  5A		     3				pop dx
 0044  58		     3				pop ax
						mov bh,                 0
 0045  E8 0331		   *	    call   ReadCommand
 0048  EB D6					mov LastCommand@a,      bx
 004A						mov LastCommand@b,      sword ptr cx
						mov LastCommand@exists, 1
				
 004A  83 F8 03		   *	    cmp    ax, CMD_ADD
 004D  75 07		   *	    jne    @C0001
 004F  E8 0054					invoke MULMatrix, bl, cx
 0052  EB 3B					ret
					Main@MUL endp
 0054  EB 36		   *	    jmp    @C0003
 0056			   *@C0001:
 0056  83 F8 01		   *	    cmp    ax, CMD_MUL
 0059  75 07		   *	    jne    @C0004
 005B  E8 0068				Main@UNDO proc near
 005E  EB 2F					mov al, LastCommand@exists
						.if !al
 0060  EB 2A		   *	    jmp    @C0006
 0062			   *@C0004:
 0062  83 F8 05		   *	    cmp    ax, CMD_UNDO
 0065  75 07		   *	    jne    @C0007
 0067  E8 0078						jmp @MainLoopEnd
 006A  EB 23					.endif
						mov al,           LastCommand
 006C  EB 1E		   *	    jmp    @C0009
 006E			   *@C0007:
 006E  83 F8 06		   *	    cmp    ax, CMD_WRITE
 0071  75 19		   *	    jne    @C000A
 0073  E8 00CB					mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??000D     textequ <>
 = 			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
 0076  50		     3				push  ax
 = ax			     3				??000E catstr <ax>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 0077  52		     3				push  dx
 = dx, ax		     3				??000E catstr <dx>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 = <dx, ax>		     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack
			     3			endif
 0078  B4 02		     1			mov      ah, 02h
 007A  B2 0D		     1			mov      dl, CR
 007C  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
 = <dx, ax>		     3				??0011     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)
			     3				regStack substr regStack, (??0010 + 1)
			     3			endif
			     3			exitm ??0011
			     2		%	for ??000F, __popRegs(regStack) 
			     2				pop ??000F
			     2			endm
 007E  5A		     3				pop dx
 007F  58		     3				pop ax
						.if (al == CMD_ADD)
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0013     textequ <>
 = 			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
 0080  50		     3				push  ax
 = ax			     3				??0014 catstr <ax>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 0081  52		     3				push  dx
 = dx, ax		     3				??0014 catstr <dx>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 = <dx, ax>		     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack
			     3			endif
 0082  B4 02		     1			mov      ah, 02h
 0084  B2 0A		     1			mov      dl, LF
 0086  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
 = <dx, ax>		     3				??0017     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)
			     3				regStack substr regStack, (??0016 + 1)
			     3			endif
			     3			exitm ??0017
			     2		%	for ??0015, __popRegs(regStack) 
			     2				pop ??0015
			     2			endm
 0088  5A		     3				pop dx
 0089  58		     3				pop ax
 008A  EB 91						invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
 008C			   *@C000A:
 008C			   *@C0009:
 008C			   *@C0006:
 008C			   *@C0003:
						.elseif (al == CMD_MUL)
 008C  E9 02C7						invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
 008F						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0019     textequ <>
 = 			     2			??001A textequ <>
			     2			for       ??0018, <ax,dx>
			     2				push  ??0018
			     2				??001A catstr <??0018>, ??0019, ??001A
			     2				??0019 catstr <, >
			     2			endm
 008F  50		     3				push  ax
 = ax			     3				??001A catstr <ax>, ??0019, ??001A
 = , 			     3				??0019 catstr <, >
 0090  52		     3				push  dx
 = dx, ax		     3				??001A catstr <dx>, ??0019, ??001A
 = , 			     3				??0019 catstr <, >
 = <dx, ax>		     2			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
			     2			__pushRegs ??001A
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??001A
			     3			else
			     3				regStack catstr ??001A, REG_SET_DELIMITER, regStack
			     3			endif
 0091  B4 02		     1			mov      ah, 02h
 0093  B2 0D		     1			mov      dl, CR
 0095  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??001C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??001C eq 0
 = <dx, ax>		     3				??001D     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??001D substr regStack, 1, (??001C - 1)
			     3				regStack substr regStack, (??001C + 1)
			     3			endif
			     3			exitm ??001D
			     2		%	for ??001B, __popRegs(regStack) 
			     2				pop ??001B
			     2			endm
 0097  5A		     3				pop dx
 0098  58		     3				pop ax
							mov LastCommand, CMD_ADD
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??001F     textequ <>
 = 			     2			??0020 textequ <>
			     2			for       ??001E, <ax,dx>
			     2				push  ??001E
			     2				??0020 catstr <??001E>, ??001F, ??0020
			     2				??001F catstr <, >
			     2			endm
 0099  50		     3				push  ax
 = ax			     3				??0020 catstr <ax>, ??001F, ??0020
 = , 			     3				??001F catstr <, >
 009A  52		     3				push  dx
 = dx, ax		     3				??0020 catstr <dx>, ??001F, ??0020
 = , 			     3				??001F catstr <, >
 = <dx, ax>		     2			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
			     2			__pushRegs ??0020
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0020
			     3			else
			     3				regStack catstr ??0020, REG_SET_DELIMITER, regStack
			     3			endif
 009B  B4 02		     1			mov      ah, 02h
 009D  B2 0A		     1			mov      dl, LF
 009F  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0022 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0022 eq 0
 = <dx, ax>		     3				??0023     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0023 substr regStack, 1, (??0022 - 1)
			     3				regStack substr regStack, (??0022 + 1)
			     3			endif
			     3			exitm ??0023
			     2		%	for ??0021, __popRegs(regStack) 
			     2				pop ??0021
			     2			endm
 00A1  5A		     3				pop dx
 00A2  58		     3				pop ax
 00A3  E9 FF74					.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
 00A6							mov LastCommand, CMD_MUL
 00A6  C6 06 020B R 03				.endif
 00AB  B7 00					ret
 00AD  89 1E 020C R			Main@UNDO  endp
 00B1  B5 00				Main@WRITE proc near
 00B3  89 0E 020E R				invoke WRITEMatrix, dx
 00B7  C6 06 0210 R 01				ret
					Main@WRITE endp
				
 00BC  8A C1		   *	    mov    al, cl
 00BE  50		   *	    push   ax
 00BF  8A C3		   *	    mov    al, bl
 00C1  50		   *	    push   ax
 00C2  E8 00F0		   *	    call   ADDMatrix
				
 00C5  C3			;====================================================================
 00C6				; MUL
 00C6					MULMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
 00C6  C6 06 020B R 01				mov al, LINHA
 00CB  B7 00					dec al
 00CD  89 1E 020C R				mov bl, TotalCol
 00D1  89 0E 020E R				inc bl
 00D5  C6 06 0210 R 01				mul bl
				
						shl ax, 1
 00DA  51		   *	    push   cx
 00DB  8A C3		   *	    mov    al, bl
 00DD  50		   *	    push   ax
 00DE  E8 0065		   *	    call   MULMatrix
 00E1  C3			
 00E2						mov bx, offset Matrix
 00E2						add bx, ax
 00E2  A0 0210 R		
						mov ch, 0
 00E5  0A C0		   *	    or	al, al
 00E7  75 02		   *	    jne    @C000C
 00E9  EB A4					mov cl, NPlusOne
				
 00EB			   *@C000C:
 00EB  A0 020B R				MULMatrix@Loop:
 00EE  8B 1E 020C R					mov  ax,             sword ptr [bx]
 00F2  8B 0E 020E R					imul CONSTANTE
							mov  sword ptr [bx], ax
 00F6  3C 03		   *	    cmp    al, CMD_ADD
 00F8  75 10		   *	    jne    @C000E
				
 00FA  8A C1		   *	    mov    al, cl
 00FC  50		   *	    push   ax
 00FD  8A C3		   *	    mov    al, bl
 00FF  50		   *	    push   ax
 0100  E8 0105		   *	    call   SUBMatrix
 0103  C6 06 020B R 04					add  bx, 2
							loop MULMatrix@Loop
 0108  EB 36		   *	    jmp    @C0010
 010A			   *@C000E:
 010A  3C 01		   *	    cmp    al, CMD_MUL
 010C  75 0E		   *	    jne    @C0011
				
 010E  51		   *	    push   cx
 010F  8A C3		   *	    mov    al, bl
 0111  50		   *	    push   ax
 0112  E8 0068		   *	    call   DIVMatrix
 0115  C6 06 020B R 02				ret
					MULMatrix endp
 011A  EB 24		   *	    jmp    @C0013
 011C			   *@C0011:
 011C  3C 04		   *	    cmp    al, CMD_SUB
 011E  75 10		   *	    jne    @C0014
				
 0120  8A C1		   *	    mov    al, cl
 0122  50		   *	    push   ax
 0123  8A C3		   *	    mov    al, bl
 0125  50		   *	    push   ax
 0126  E8 008C		   *	    call   ADDMatrix
 0129  C6 06 020B R 03			DIVMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
 012E  EB 10		   *	    jmp    @C0016
 0130			   *@C0014:
 0130  3C 02		   *	    cmp    al, CMD_DIV
 0132  75 0C		   *	    jne    @C0017
						dec al
 0134  51		   *	    push   cx
 0135  8A C3		   *	    mov    al, bl
 0137  50		   *	    push   ax
 0138  E8 000B		   *	    call   MULMatrix
 013B  C6 06 020B R 01				mov bl, TotalCol
						inc bl
 0140			   *@C0017:
 0140			   *@C0016:
 0140			   *@C0013:
 0140			   *@C0010:
 0140  C3					mul bl
 0141				
 0141						shl ax, 1
				
 0141  52		   *	    push   dx
 0142  E8 0116		   *	    call   WRITEMatrix
 0145  C3					mov bx, offset Matrix
 0146						add bx, ax
				
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
 0146							mov ax, sword ptr [bx]
 0146  55		   *	    push   bp
 0147  8B EC		   *	    mov    bp, sp
 0149  50		   *	    push   ax
 014A  53		   *	    push   bx
 014B  51		   *	    push   cx
 014C  52		   *	    push   dx
 014D  55		   *	    push   bp
 014E  8A 46 04						cwd                    ; extend sign to dx
 0151  FE C8						
 0153  8A 1E 03C6 R					idiv CONSTANTE
 0157  FE C3						
 0159  F6 E3						mov sword ptr [bx], ax
				
 015B  D1 E0						add  bx, 2
							loop DIVMatrix@Loop
 015D  BB 03C9 R		
 0160  03 D8					ret
					DIVMatrix endp
 0162  B5 00			
 0164  8A 0E 03C8 R		;====================================================================
				; ADD
 0168					ADDMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
 0168  8B 07			
 016A  F7 6E 06					mov al, LINHA_DST
 016D  89 07					dec al
						mov bl, TotalCol
 016F  83 C3 02					inc bl
 0172  E2 F4					mul bl
						shl ax, 1
						
 0174  5D		   *	    pop    bp
 0175  5A		   *	    pop    dx
 0176  59		   *	    pop    cx
 0177  5B		   *	    pop    bx
 0178  58		   *	    pop    ax
 0179  5D		   *	    pop    bp
 017A  C2 0004		   *	    ret    00004h
 017D						lea di, Matrix
						add di, ax
 017D				
 017D  55		   *	    push   bp
 017E  8B EC		   *	    mov    bp, sp
 0180  50		   *	    push   ax
 0181  53		   *	    push   bx
 0182  51		   *	    push   cx
 0183  52		   *	    push   dx
 0184  55		   *	    push   bp
 0185  8A 46 04			
 0188  FE C8					mov al, LINHA_ORG
 018A  8A 1E 03C6 R				dec al
 018E  FE C3					mov bl, TotalCol
 0190  F6 E3					inc bl
						mul bl
 0192  D1 E0					shl ax, 1
				
 0194  BB 03C9 R				lea si, Matrix
 0197  03 D8					add si, ax
				
 0199  B5 00					mov ch, 0
 019B  8A 0E 03C8 R				mov cl, NPlusOne
 019F						ADDMatrix@Loop:
 019F  8B 07						mov ax,   [di]
 01A1  99						add ax,   [si]
							mov [di], ax
 01A2  F7 7E 06			
							add  di, 2
 01A5  89 07						add  si, 2
							loop ADDMatrix@Loop
 01A7  83 C3 02			
 01AA  E2 F3					ret
					ADDMatrix endp
				
 01AC  5D		   *	    pop    bp
 01AD  5A		   *	    pop    dx
 01AE  59		   *	    pop    cx
 01AF  5B		   *	    pop    bx
 01B0  58		   *	    pop    ax
 01B1  5D		   *	    pop    bp
 01B2  C2 0004		   *	    ret    00004h
 01B5					SUBMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
				
						mov al, LINHA_DST
						dec al
 01B5						mov bl, TotalCol
						inc bl
 01B5  55		   *	    push   bp
 01B6  8B EC		   *	    mov    bp, sp
 01B8  50		   *	    push   ax
 01B9  53		   *	    push   bx
 01BA  51		   *	    push   cx
 01BB  52		   *	    push   dx
 01BC  55		   *	    push   bp
 01BD  57		   *	    push   di
 01BE  56		   *	    push   si
 01BF  8A 46 04					mul bl
 01C2  FE C8					shl ax, 1
 01C4  8A 1E 03C6 R				
 01C8  FE C3					lea di, Matrix
 01CA  F6 E3					add di, ax
 01CC  D1 E0			
				
 01CE  8D 3E 03C9 R				mov al, LINHA_ORG
 01D2  03 F8					dec al
						mov bl, TotalCol
						inc bl
 01D4  8A 46 06					mul bl
 01D7  FE C8					shl ax, 1
 01D9  8A 1E 03C6 R		
 01DD  FE C3					lea si, Matrix
 01DF  F6 E3					add si, ax
 01E1  D1 E0			
						mov ch, 0
 01E3  8D 36 03C9 R				mov cl, NPlusOne
 01E7  03 F0					SUBMatrix@Loop:
							mov ax,   [di]
 01E9  B5 00						sub ax,   [si]
 01EB  8A 0E 03C8 R					mov [di], ax
 01EF				
 01EF  8B 05						add  di, 2
 01F1  03 04						add  si, 2
 01F3  89 05						loop SUBMatrix@Loop
				
 01F5  83 C7 02					ret
 01F8  83 C6 02				SUBMatrix endp
 01FB  E2 F2			
				;====================================================================
				; WRITE
 01FD  5E		   *	    pop    si
 01FE  5F		   *	    pop    di
 01FF  5D		   *	    pop    bp
 0200  5A		   *	    pop    dx
 0201  59		   *	    pop    cx
 0202  5B		   *	    pop    bx
 0203  58		   *	    pop    ax
 0204  5D		   *	    pop    bp
 0205  C2 0004		   *	    ret    00004h
 0208				
					WriteToFile macro handle:req, offset_buf:req, len:req
 0208						SaveRegs bx, cx, dx
						mov cx, len
 0208  55		   *	    push   bp
 0209  8B EC		   *	    mov    bp, sp
 020B  50		   *	    push   ax
 020C  53		   *	    push   bx
 020D  51		   *	    push   cx
 020E  52		   *	    push   dx
 020F  55		   *	    push   bp
 0210  57		   *	    push   di
 0211  56		   *	    push   si
 0212  8A 46 04					mov bx, handle
 0215  FE C8					lea dx, offset_buf
 0217  8A 1E 03C6 R				mov ah, 40h		int 21h
 021B  FE C3					RestoreRegs
 021D  F6 E3				endm
 021F  D1 E0				WRITEMatrix proc near uses RegsInvokeUses di si, NOME:ptr byte
						local buf[7]:byte, handle:word
 0221  8D 3E 03C9 R				mov   ah,          3Dh         ; open
 0225  03 F8					mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
 0227  8A 46 06					jc    create_file              ; if not exists
 022A  FE C8			
 022C  8A 1E 03C6 R				mov bx, ax      ; BX = file handle
 0230  FE C3					jmp file_opened
 0232  F6 E3			
 0234  D1 E0					create_file:
						mov ah, 3Ch  ; create
 0236  8D 36 03C9 R				mov cx, 0
 023A  03 F0					mov dx, NOME
						int 21h
 023C  B5 00					mov bx, ax
 023E  8A 0E 03C8 R		
 0242						file_opened:
 0242  8B 05					mov ah, 42h
 0244  2B 04					mov al, 02h ; SEEK_END
 0246  89 05					xor cx, cx
						xor dx, dx
 0248  83 C7 02					int 21h
 024B  83 C6 02			
 024E  E2 F2					.if (carry?)
							ErrorCantOpenNorCreate
							stc
 0250  5E		   *	    pop    si
 0251  5F		   *	    pop    di
 0252  5D		   *	    pop    bp
 0253  5A		   *	    pop    dx
 0254  59		   *	    pop    cx
 0255  5B		   *	    pop    bx
 0256  58		   *	    pop    ax
 0257  5D		   *	    pop    bp
 0258  C2 0004		   *	    ret    00004h
 025B							ret
						.endif
				
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
				
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
				
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
 025B							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
 025B  55		   *	    push   bp
 025C  8B EC		   *	    mov    bp, sp
 025E  83 C4 F6		   *	    add    sp, 0FFF6h
 0261  50		   *	    push   ax
 0262  53		   *	    push   bx
 0263  51		   *	    push   cx
 0264  52		   *	    push   dx
 0265  55		   *	    push   bp
 0266  57		   *	    push   di
 0267  56		   *	    push   si
 0268  B4 3D							jge WRITEMatrix@EndForCol
 026A  B0 02			
 026C  8B 56 04							.if (bl) ; no longer firstCol?
 026F  CD 21								WriteToFile handle, COLUMN_SEP, 1
 0271  72 04							.endif
				
 0273  8B D8							mov ax, sword ptr [di]
 0275  EB 0C			
								invoke string_from_sword, addr buf, ax ; ax now has length
 0277				
 0277  B4 3C							WriteToFile handle, buf, ax
 0279  B9 0000			
 027C  8B 56 04							add di, 2 ; size in bytes of a sword
 027F  CD 21			
 0281  8B D8							mov bl, 1 ; no longer first col
								inc cl    ; col ++
 0283								
 0283  B4 42							jmp WRITEMatrix@ForCol
 0285  B0 02						WRITEMatrix@EndForCol:
 0287  33 C9			
 0289  33 D2						WriteToFile handle, CRLF, 2
 028B  CD 21			
							inc ch ; row++
							
 028D  73 48		   *	    jae    @C0019
							jmp WRITEMatrix@ForRow
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
 028F  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     3				EXITM <-1> 
			     3				if DEFINED(@@nao_foi_possivel_abrir_ou_criar_o_arquivo)
			     4					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
 0293  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0026 catstr <ax>, ??0025, ??0026
 = <ax>			     5				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0026
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack
			     4			endif
 0294  8D 36 035E R	     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0298			   *@C001B:
			     4			endif
 0298  8A 04		     4			.repeat
 029A  88 05		     4				mov al,   [si]
 029C  46		     4				mov [di], al
 029D  47		     4				inc si
 029E  0A C0		   *	    or	al, al
 02A0  75 F6		   *	    jne    @C001B
			     4				inc di
 02A2  4E		     4			.until (al == 0)
 02A3  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0028 eq 0
 = 			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)
			     6				regStack substr regStack, (??0028 + 1)
			     6			endif
			     5			exitm ??0029
			     5		%	for ??0027, __popRegs(regStack) 
			     5				pop ??0027
 02A4  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??002B     textequ <>
			     5			??002C textequ <>
			     5			for       ??002A, <ax>
			     5				push  ??002A
			     5				??002C catstr <??002A>, ??002B, ??002C
			     5				??002B catstr <, >
 02A5  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??002C catstr <ax>, ??002B, ??002C
 = <ax>			     5				??002B catstr <, >
			     5			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??002C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??002C
			     6			else
			     6				regStack catstr ??002C, REG_SET_DELIMITER, regStack
			     4			endif
 02A6  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 02AA			   *@C001D:
			     4			endif
 02AA  8A 04		     4			.repeat
 02AC  88 05		     4				mov al,   [si]
 02AE  46		     4				mov [di], al
 02AF  47		     4				inc si
 02B0  0A C0		   *	    or	al, al
 02B2  75 F6		   *	    jne    @C001D
			     4				inc di
 02B4  4E		     4			.until (al == 0)
 02B5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??002E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??002E eq 0
 = 			     6				??002F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??002F substr regStack, 1, (??002E - 1)
			     6				regStack substr regStack, (??002E + 1)
			     6			endif
			     5			exitm ??002F
			     5		%	for ??002D, __popRegs(regStack) 
			     5				pop ??002D
 02B6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0031     textequ <>
			     5			??0032 textequ <>
			     5			for       ??0030, <ax>
			     5				push  ??0030
			     5				??0032 catstr <??0030>, ??0031, ??0032
			     5				??0031 catstr <, >
 02B7  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0032 catstr <ax>, ??0031, ??0032
 = <ax>			     5				??0031 catstr <, >
			     5			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0032
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0032
			     6			else
			     6				regStack catstr ??0032, REG_SET_DELIMITER, regStack
			     4			endif
 02B8  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 02BC			   *@C001F:
			     4			endif
 02BC  8A 04		     4			.repeat
 02BE  88 05		     4				mov al,   [si]
 02C0  46		     4				mov [di], al
 02C1  47		     4				inc si
 02C2  0A C0		   *	    or	al, al
 02C4  75 F6		   *	    jne    @C001F
			     4				inc di
 02C6  4E		     4			.until (al == 0)
 02C7  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0034 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0034 eq 0
 = 			     6				??0035     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0035 substr regStack, 1, (??0034 - 1)
			     6				regStack substr regStack, (??0034 + 1)
			     6			endif
			     5			exitm ??0035
			     5		%	for ??0033, __popRegs(regStack) 
			     5				pop ??0033
 02C8  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 02C9  F9					WRITEMatrix@EndForRow:
				
 02CA  5E		   *	    pop    si
 02CB  5F		   *	    pop    di
 02CC  5D		   *	    pop    bp
 02CD  5A		   *	    pop    dx
 02CE  59		   *	    pop    cx
 02CF  5B		   *	    pop    bx
 02D0  58		   *	    pop    ax
 02D1  8B E5		   *	    mov    sp, bp
 02D3  5D		   *	    pop    bp
 02D4  C2 0002		   *	    ret    00002h
						clc
 02D7			   *@C0019:
						ret
 02D7  89 5E F6				WRITEMatrix endp
 02DA  BB 0000			;====================================================================
				; Exiting
 02DD  BF 03C9 R		
 02E0  B9 0000				ExitSuccess proc near
						mov al, 0
 02E3						jmp ExitAndClose
 02E3  3A 2E 03C7 R				ret
 02E7  7D 5F				ExitSuccess endp
				
 02E9  B3 00				ExitFailure proc near
 02EB  B1 00					mov al, 1
						jmp ExitAndClose
 02ED						ret
 02ED  3A 0E 03C8 R			ExitFailure endp
 02F1  7D 3D			
					ExitAndClose proc near
						.if (FileIsOpen)
 02F3  0A DB		   *	    or	bl, bl
 02F5  74 14		   *	    je     @C0021
							CloseFileHandle
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0037     textequ <>
 = 			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
 02F7  53		     3				push  bx
 = bx			     3				??0038 catstr <bx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 02F8  51		     3				push  cx
 = cx, bx		     3				??0038 catstr <cx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 02F9  52		     3				push  dx
 = dx, cx, bx		     3				??0038 catstr <dx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 = <dx, cx, bx>		     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 02FA  B9 0001		     1			mov cx, 1
 02FD  8B 5E F6		     1			mov bx, handle
 0300  8D 16 0000 R	     1			lea dx, COLUMN_SEP
 0304  B4 40		     1			mov ah, 40h
 0306  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
 = <dx, cx, bx>		     3				??003B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)
			     3				regStack substr regStack, (??003A + 1)
			     3			endif
			     3			exitm ??003B
			     2		%	for ??0039, __popRegs(regStack) 
			     2				pop ??0039
			     2			endm
 0308  5A		     3				pop dx
 0309  59		     3				pop cx
 030A  5B		     3				pop bx
						.endif
 030B			   *@C0021:
						.exit
 030B  8B 05					ret
					ExitAndClose endp
				
 030D  50		   *	    push   ax
 030E  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 0311  50		   *	    push   ax
 0312  E8 1234		   *	    call   string_from_sword
				;====================================================================
				; Reading input
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??003D     textequ <>
 = 			     2			??003E textequ <>
			     2			for       ??003C, <bx,cx,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
 0315  53		     3				push  bx
 = bx			     3				??003E catstr <bx>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 0316  51		     3				push  cx
 = cx, bx		     3				??003E catstr <cx>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 0317  52		     3				push  dx
 = dx, cx, bx		     3				??003E catstr <dx>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 = <dx, cx, bx>		     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 0318  8B C8		     1			mov cx, ax
 031A  8B 5E F6		     1			mov bx, handle
 031D  8D 56 F9		     1			lea dx, buf
 0320  B4 40		     1			mov ah, 40h
 0322  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
 = <dx, cx, bx>		     3				??0041     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)
			     3				regStack substr regStack, (??0040 + 1)
			     3			endif
			     3			exitm ??0041
			     2		%	for ??003F, __popRegs(regStack) 
			     2				pop ??003F
			     2			endm
 0324  5A		     3				pop dx
 0325  59		     3				pop cx
 0326  5B		     3				pop bx
				
 0327  83 C7 02				ReadCommand proc near uses si
						mov dx, offset CommandBuffer
 032A  B3 01					mov ah, 0Ah
 032C  FE C1					int 21h
				
 032E  EB BD					mov si, offset CommandBufferString
 0330						mov bh, 0
						mov bl, CommandBufferLength
						
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0043     textequ <>
 = 			     2			??0044 textequ <>
			     2			for       ??0042, <bx,cx,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
 0330  53		     3				push  bx
 = bx			     3				??0044 catstr <bx>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 0331  51		     3				push  cx
 = cx, bx		     3				??0044 catstr <cx>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 0332  52		     3				push  dx
 = dx, cx, bx		     3				??0044 catstr <dx>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 = <dx, cx, bx>		     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 0333  B9 0002		     1			mov cx, 2
 0336  8B 5E F6		     1			mov bx, handle
 0339  8D 16 0002 R	     1			lea dx, CRLF
 033D  B4 40		     1			mov ah, 40h
 033F  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
 = <dx, cx, bx>		     3				??0047     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)
			     3				regStack substr regStack, (??0046 + 1)
			     3			endif
			     3			exitm ??0047
			     2		%	for ??0045, __popRegs(regStack) 
			     2				pop ??0045
			     2			endm
 0341  5A		     3				pop dx
 0342  59		     3				pop cx
 0343  5B		     3				pop bx
						mov byte ptr [CommandBufferString+bx], 0
 0344  FE C5			
				
 0346  EB 9B					putc CR
 0348						putc LF
				
 0348  F8					invoke ParseCommand
						ret
 0349  5E		   *	    pop    si
 034A  5F		   *	    pop    di
 034B  5D		   *	    pop    bp
 034C  5A		   *	    pop    dx
 034D  59		   *	    pop    cx
 034E  5B		   *	    pop    bx
 034F  58		   *	    pop    ax
 0350  8B E5		   *	    mov    sp, bp
 0352  5D		   *	    pop    bp
 0353  C2 0002		   *	    ret    00002h
 0356					ReadCommand endp
				
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
 0356						LOCAL i, @@eq, @@ne, @@done		SaveRegs ax, bx
 0356  B0 00					i = 0
 0358  EB 06							mov bx, memString
 035A  C3							forc char, <constStr>
 035B							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
 035B							cmp al, '&char'
 035B  B0 01						jne @@ne
 035D  EB 01						i = i + 1
 035F  C3					endm 
 0360						mov ax, 1
						jmp @@done
 0360						@@ne:
							mov ax, 0
 0360  80 3E 0073 R 00	   *	    cmp    FileIsOpen, 000h
 0365  74 0D		   *	    je     @C0023
						@@done:
 0367  B4 3E		     1			mov ah, 3eh
 0369  8B 1E 0071 R	     1			mov bx, FileHandle
 036D  CD 21		     1			int 21h
			     1			
 036F  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
							cmp ax, 0			RestoreRegs
 0374			   *@C0023:
					endm
 0374  B4 4C		   *	    mov    ah, 04Ch
 0376  CD 21		   *	    int    021h
 0378  C3			
 0379					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw	endm
				
 0379					; Return the value read in result, and the end of the string read in si
 0379  56		   *	    push   si
 037A  BA 010B R			ReadNumFromString proc near uses RegsInvokeUses, string:ptr byte, result:ptr sword
 037D  B4 0A					mov ax, 0
 037F  CD 21					mov bx, 0
						mov si, string
 0381  BE 010D R				mov cx, 0
 0384  B7 00			
 0386  8A 1E 010C R				.if byte ptr [si] == '-'
							inc si
 038A  C6 87 010D R 00					mov cx, 1
						.endif
				
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0049     textequ <>
 = 			     2			??004A textequ <>
			     2			for       ??0048, <ax,dx>
			     2				push  ??0048
			     2				??004A catstr <??0048>, ??0049, ??004A
			     2				??0049 catstr <, >
			     2			endm
 038F  50		     3				push  ax
 = ax			     3				??004A catstr <ax>, ??0049, ??004A
 = , 			     3				??0049 catstr <, >
 0390  52		     3				push  dx
 = dx, ax		     3				??004A catstr <dx>, ??0049, ??004A
 = , 			     3				??0049 catstr <, >
 = <dx, ax>		     2			??004A catstr OPEN_DELIMITER, ??004A, CLOSE_DELIMITER
			     2			__pushRegs ??004A
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??004A
			     3			else
			     3				regStack catstr ??004A, REG_SET_DELIMITER, regStack
			     3			endif
 0391  B4 02		     1			mov      ah, 02h
 0393  B2 0D		     1			mov      dl, CR
 0395  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??004C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??004C eq 0
 = <dx, ax>		     3				??004D     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??004D substr regStack, 1, (??004C - 1)
			     3				regStack substr regStack, (??004C + 1)
			     3			endif
			     3			exitm ??004D
			     2		%	for ??004B, __popRegs(regStack) 
			     2				pop ??004B
			     2			endm
 0397  5A		     3				pop dx
 0398  58		     3				pop ax
							mov dx, 10
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??004F     textequ <>
 = 			     2			??0050 textequ <>
			     2			for       ??004E, <ax,dx>
			     2				push  ??004E
			     2				??0050 catstr <??004E>, ??004F, ??0050
			     2				??004F catstr <, >
			     2			endm
 0399  50		     3				push  ax
 = ax			     3				??0050 catstr <ax>, ??004F, ??0050
 = , 			     3				??004F catstr <, >
 039A  52		     3				push  dx
 = dx, ax		     3				??0050 catstr <dx>, ??004F, ??0050
 = , 			     3				??004F catstr <, >
 = <dx, ax>		     2			??0050 catstr OPEN_DELIMITER, ??0050, CLOSE_DELIMITER
			     2			__pushRegs ??0050
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0050
			     3			else
			     3				regStack catstr ??0050, REG_SET_DELIMITER, regStack
			     3			endif
 039B  B4 02		     1			mov      ah, 02h
 039D  B2 0A		     1			mov      dl, LF
 039F  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0052 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0052 eq 0
 = <dx, ax>		     3				??0053     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0053 substr regStack, 1, (??0052 - 1)
			     3				regStack substr regStack, (??0052 + 1)
			     3			endif
			     3			exitm ??0053
			     2		%	for ??0051, __popRegs(regStack) 
			     2				pop ??0051
			     2			endm
 03A1  5A		     3				pop dx
 03A2  58		     3				pop ax
							mul dx
				
 03A3  E8 0060		   *	    call   ParseCommand
							mov bl, [si]
 03A6  5E		   *	    pop    si
 03A7  C3		   *	    ret    00000h
 03A8							sub bl, '0'
							add ax, bx
				
							inc si
						.endw
				
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
				
						.if (cx)
							neg ax
						.endif
				
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
					ReadNumFromString endp
				
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)			stc		.else			mov resultReg, numberInMemory
							clc		.endif	endm
				
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
								.if (!zero?)			add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif	endm
				
				
 03A8					;   AX = command ID (CMD_*)
 03A8  55		   *	    push   bp
 03A9  8B EC		   *	    mov    bp, sp
 03AB  50		   *	    push   ax
 03AC  53		   *	    push   bx
 03AD  51		   *	    push   cx
 03AE  52		   *	    push   dx
 03AF  55		   *	    push   bp
 03B0  B8 0000				;   BX = param1 (if any)
 03B3  BB 0000				;   CX = param2 (if any)
 03B6  8B 76 04				;   DX = offset of string (WRITE)
 03B9  B9 0000				ParseCommand proc near uses si di bp
						local a:sword
				
 03BC  80 3C 2D		   *	    cmp    byte ptr [si], '-'
 03BF  75 04		   *	    jne    @C0025
 03C1  46					mov si, offset CommandBufferString
 03C2  B9 0001					
						SkipSpacesInSI si
 03C5			   *@C0025:
				
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
 03C5  EB 0D		   *	    jmp    @C0027
 03C7			   *@C0028:
 03C7  BA 000A					jumpIfSIComparesTo <ADD> ParseCommand@ADD
 03CA  F7 E2					jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
 03CC  8A 1C					jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
 03CE  80 EB 30					jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
 03D1  03 C3				
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
 03D3  46				ParseCommand@error:
						stc
 03D4			   *@C0027:
 03D4  80 3C 30		   *	    cmp    byte ptr [si], '0'
 03D7  72 05		   *	    jb     @C0029
 03D9  80 3C 39		   *	    cmp    byte ptr [si], '9'
 03DC  76 E9		   *	    jbe    @C0028
 03DE			   *@C0029:
						ret
 03DE  8B 5E 04				ParseCommand@MUL:
 03E1  03 D9			
						skipAndRead si, a, bx
 03E3  3B F3		   *	    cmp    si, bx
 03E5  75 0A		   *	    jne    @C002B
 03E7  F9					.if (carry?)
							call ParseCommand@LINHA_AUSENTE
 03E8  5D		   *	    pop    bp
 03E9  5A		   *	    pop    dx
 03EA  59		   *	    pop    cx
 03EB  5B		   *	    pop    bx
 03EC  58		   *	    pop    ax
 03ED  5D		   *	    pop    bp
 03EE  C2 0004		   *	    ret    00004h
							jmp ParseCommand@error
 03F1			   *@C002B:
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
 03F1  0B C9		   *	    or	cx, cx
 03F3  74 02		   *	    je     @C002D
 03F5  F7 D8						jmp ParseCommand@error
						.elseif (bl < 1)
 03F7			   *@C002D:
							call ParseCommand@LINHA_INVALIDA
 03F7  8B 5E 06						jmp ParseCommand@error
 03FA  89 07					.endif
 03FC  F8					
						skipAndRead si, a, cx
 03FD  5D		   *	    pop    bp
 03FE  5A		   *	    pop    dx
 03FF  59		   *	    pop    cx
 0400  5B		   *	    pop    bx
 0401  58		   *	    pop    ax
 0402  5D		   *	    pop    bp
 0403  C2 0004		   *	    ret    00004h
 0406						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
				
						mov ax, CMD_MUL
				
						jmp ParseCommand@success
				
					ParseCommand@ADD:
				
						skipAndRead si, a, bx
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
				
						skipAndRead si, a, cx
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
 0406							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
 0406  55		   *	    push   bp
 0407  8B EC		   *	    mov    bp, sp
 0409  83 C4 FE		   *	    add    sp, 0FFFEh
 040C  56		   *	    push   si
 040D  57		   *	    push   di
 040E  55		   *	    push   bp
 040F  BE 010D R					call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
 0412  EB 01		   *	    jmp    @C002F
 0414			   *@C0030:
			     1			.while (BYTE PTR [si] == ' ' )
 0414  46		     1				inc si
 0415			   *@C002F:
 0415  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0418  74 FA		   *	    je     @C0030
			     1			.endw
				
						mov ax, CMD_ADD
			     1			StartsWith <MUL> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0059     textequ <>
 = 			     3			??005A textequ <>
			     3			for       ??0058, <ax,bx>
			     3				push  ??0058
			     3				??005A catstr <??0058>, ??0059, ??005A
			     3				??0059 catstr <, >
			     3			endm
 041A  50		     4				push  ax
 = ax			     4				??005A catstr <ax>, ??0059, ??005A
 = , 			     4				??0059 catstr <, >
 041B  53		     4				push  bx
 = bx, ax		     4				??005A catstr <bx>, ??0059, ??005A
 = , 			     4				??0059 catstr <, >
 = <bx, ax>		     3			??005A catstr OPEN_DELIMITER, ??005A, CLOSE_DELIMITER
			     3			__pushRegs ??005A
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??005A
			     4			else
			     4				regStack catstr ??005A, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0054 = 0
			     2			
 041C  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0054]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0056
			     2	
			     2				??0054 = ??0054 + 1
			     2			endm 
 041E  8A 07		     3				mov al, [bx+??0054]
 0420  24 DF		     3				and al, 11011111b ; toUpperCase
 0422  3C 4D		     3				cmp al, 'M'
 0424  75 17		     3				jne ??0056
			     3	
 = 0001			     3				??0054 = ??0054 + 1
 0426  8A 47 01		     3				mov al, [bx+??0054]
 0429  24 DF		     3				and al, 11011111b ; toUpperCase
 042B  3C 55		     3				cmp al, 'U'
 042D  75 0E		     3				jne ??0056
			     3	
 = 0002			     3				??0054 = ??0054 + 1
 042F  8A 47 02		     3				mov al, [bx+??0054]
 0432  24 DF		     3				and al, 11011111b ; toUpperCase
 0434  3C 4C		     3				cmp al, 'L'
 0436  75 05		     3				jne ??0056
			     3	
 = 0003			     3				??0054 = ??0054 + 1
 0438  B8 0001		     2			mov ax, 1
			     2	
 043B  EB 03		     2			jmp ??0057
 043D			     2			??0056:
 043D  B8 0000		     2				mov ax, 0
			     2	
 0440			     2			??0057:
 0440  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??005C instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005C eq 0
 = <bx, ax>		     4				??005D     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??005D substr regStack, 1, (??005C - 1)
			     4				regStack substr regStack, (??005C + 1)
			     4			endif
			     4			exitm ??005D
			     3		%	for ??005B, __popRegs(regStack) 
			     3				pop ??005B
			     3			endm
 0443  5B		     4				pop bx
 0444  58		     4				pop ax
			     1			
 0445  74 06		   *	    je     @C0032
			     1			.if (!zero?)
 0447  83 C6 03		     1				add si, @SizeStr(MUL)
 044A  E9 0192		     1				jmp ParseCommand@MUL
 044D			   *@C0032:
			     1			.endif
						
			     1			StartsWith <ADD> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0063     textequ <>
 = 			     3			??0064 textequ <>
			     3			for       ??0062, <ax,bx>
			     3				push  ??0062
			     3				??0064 catstr <??0062>, ??0063, ??0064
			     3				??0063 catstr <, >
			     3			endm
 044D  50		     4				push  ax
 = ax			     4				??0064 catstr <ax>, ??0063, ??0064
 = , 			     4				??0063 catstr <, >
 044E  53		     4				push  bx
 = bx, ax		     4				??0064 catstr <bx>, ??0063, ??0064
 = , 			     4				??0063 catstr <, >
 = <bx, ax>		     3			??0064 catstr OPEN_DELIMITER, ??0064, CLOSE_DELIMITER
			     3			__pushRegs ??0064
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0064
			     4			else
			     4				regStack catstr ??0064, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??005E = 0
			     2			
 044F  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??005E]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0060
			     2	
			     2				??005E = ??005E + 1
			     2			endm 
 0451  8A 07		     3				mov al, [bx+??005E]
 0453  24 DF		     3				and al, 11011111b ; toUpperCase
 0455  3C 41		     3				cmp al, 'A'
 0457  75 17		     3				jne ??0060
			     3	
 = 0001			     3				??005E = ??005E + 1
 0459  8A 47 01		     3				mov al, [bx+??005E]
 045C  24 DF		     3				and al, 11011111b ; toUpperCase
 045E  3C 44		     3				cmp al, 'D'
 0460  75 0E		     3				jne ??0060
			     3	
 = 0002			     3				??005E = ??005E + 1
 0462  8A 47 02		     3				mov al, [bx+??005E]
 0465  24 DF		     3				and al, 11011111b ; toUpperCase
 0467  3C 44		     3				cmp al, 'D'
 0469  75 05		     3				jne ??0060
			     3	
 = 0003			     3				??005E = ??005E + 1
 046B  B8 0001		     2			mov ax, 1
			     2	
 046E  EB 03		     2			jmp ??0061
 0470			     2			??0060:
 0470  B8 0000		     2				mov ax, 0
			     2	
 0473			     2			??0061:
 0473  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0066 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0066 eq 0
 = <bx, ax>		     4				??0067     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0067 substr regStack, 1, (??0066 - 1)
			     4				regStack substr regStack, (??0066 + 1)
			     4			endif
			     4			exitm ??0067
			     3		%	for ??0065, __popRegs(regStack) 
			     3				pop ??0065
			     3			endm
 0476  5B		     4				pop bx
 0477  58		     4				pop ax
			     1			
 0478  74 06		   *	    je     @C0034
			     1			.if (!zero?)
 047A  83 C6 03		     1				add si, @SizeStr(ADD)
 047D  E9 01BE		     1				jmp ParseCommand@ADD
 0480			   *@C0034:
			     1			.endif
						jmp ParseCommand@success
			     1			StartsWith <UNDO> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??006D     textequ <>
 = 			     3			??006E textequ <>
			     3			for       ??006C, <ax,bx>
			     3				push  ??006C
			     3				??006E catstr <??006C>, ??006D, ??006E
			     3				??006D catstr <, >
			     3			endm
 0480  50		     4				push  ax
 = ax			     4				??006E catstr <ax>, ??006D, ??006E
 = , 			     4				??006D catstr <, >
 0481  53		     4				push  bx
 = bx, ax		     4				??006E catstr <bx>, ??006D, ??006E
 = , 			     4				??006D catstr <, >
 = <bx, ax>		     3			??006E catstr OPEN_DELIMITER, ??006E, CLOSE_DELIMITER
			     3			__pushRegs ??006E
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??006E
			     4			else
			     4				regStack catstr ??006E, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0068 = 0
			     2			
 0482  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??0068]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??006A
			     2	
			     2				??0068 = ??0068 + 1
			     2			endm 
 0484  8A 07		     3				mov al, [bx+??0068]
 0486  24 DF		     3				and al, 11011111b ; toUpperCase
 0488  3C 55		     3				cmp al, 'U'
 048A  75 20		     3				jne ??006A
			     3	
 = 0001			     3				??0068 = ??0068 + 1
 048C  8A 47 01		     3				mov al, [bx+??0068]
 048F  24 DF		     3				and al, 11011111b ; toUpperCase
 0491  3C 4E		     3				cmp al, 'N'
 0493  75 17		     3				jne ??006A
			     3	
 = 0002			     3				??0068 = ??0068 + 1
 0495  8A 47 02		     3				mov al, [bx+??0068]
 0498  24 DF		     3				and al, 11011111b ; toUpperCase
 049A  3C 44		     3				cmp al, 'D'
 049C  75 0E		     3				jne ??006A
			     3	
 = 0003			     3				??0068 = ??0068 + 1
 049E  8A 47 03		     3				mov al, [bx+??0068]
 04A1  24 DF		     3				and al, 11011111b ; toUpperCase
 04A3  3C 4F		     3				cmp al, 'O'
 04A5  75 05		     3				jne ??006A
			     3	
 = 0004			     3				??0068 = ??0068 + 1
 04A7  B8 0001		     2			mov ax, 1
			     2	
 04AA  EB 03		     2			jmp ??006B
 04AC			     2			??006A:
 04AC  B8 0000		     2				mov ax, 0
			     2	
 04AF			     2			??006B:
 04AF  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0070 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0070 eq 0
 = <bx, ax>		     4				??0071     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0071 substr regStack, 1, (??0070 - 1)
			     4				regStack substr regStack, (??0070 + 1)
			     4			endif
			     4			exitm ??0071
			     3		%	for ??006F, __popRegs(regStack) 
			     3				pop ??006F
			     3			endm
 04B2  5B		     4				pop bx
 04B3  58		     4				pop ax
			     1			
 04B4  74 06		   *	    je     @C0036
			     1			.if (!zero?)
 04B6  83 C6 04		     1				add si, @SizeStr(UNDO)
 04B9  E9 01FF		     1				jmp ParseCommand@UNDO
 04BC			   *@C0036:
			     1			.endif
				
			     1			StartsWith <WRITE> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0077     textequ <>
 = 			     3			??0078 textequ <>
			     3			for       ??0076, <ax,bx>
			     3				push  ??0076
			     3				??0078 catstr <??0076>, ??0077, ??0078
			     3				??0077 catstr <, >
			     3			endm
 04BC  50		     4				push  ax
 = ax			     4				??0078 catstr <ax>, ??0077, ??0078
 = , 			     4				??0077 catstr <, >
 04BD  53		     4				push  bx
 = bx, ax		     4				??0078 catstr <bx>, ??0077, ??0078
 = , 			     4				??0077 catstr <, >
 = <bx, ax>		     3			??0078 catstr OPEN_DELIMITER, ??0078, CLOSE_DELIMITER
			     3			__pushRegs ??0078
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0078
			     4			else
			     4				regStack catstr ??0078, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0072 = 0
			     2			
 04BE  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0072]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0074
			     2	
			     2				??0072 = ??0072 + 1
			     2			endm 
 04C0  8A 07		     3				mov al, [bx+??0072]
 04C2  24 DF		     3				and al, 11011111b ; toUpperCase
 04C4  3C 57		     3				cmp al, 'W'
 04C6  75 29		     3				jne ??0074
			     3	
 = 0001			     3				??0072 = ??0072 + 1
 04C8  8A 47 01		     3				mov al, [bx+??0072]
 04CB  24 DF		     3				and al, 11011111b ; toUpperCase
 04CD  3C 52		     3				cmp al, 'R'
 04CF  75 20		     3				jne ??0074
			     3	
 = 0002			     3				??0072 = ??0072 + 1
 04D1  8A 47 02		     3				mov al, [bx+??0072]
 04D4  24 DF		     3				and al, 11011111b ; toUpperCase
 04D6  3C 49		     3				cmp al, 'I'
 04D8  75 17		     3				jne ??0074
			     3	
 = 0003			     3				??0072 = ??0072 + 1
 04DA  8A 47 03		     3				mov al, [bx+??0072]
 04DD  24 DF		     3				and al, 11011111b ; toUpperCase
 04DF  3C 54		     3				cmp al, 'T'
 04E1  75 0E		     3				jne ??0074
			     3	
 = 0004			     3				??0072 = ??0072 + 1
 04E3  8A 47 04		     3				mov al, [bx+??0072]
 04E6  24 DF		     3				and al, 11011111b ; toUpperCase
 04E8  3C 45		     3				cmp al, 'E'
 04EA  75 05		     3				jne ??0074
			     3	
 = 0005			     3				??0072 = ??0072 + 1
 04EC  B8 0001		     2			mov ax, 1
			     2	
 04EF  EB 03		     2			jmp ??0075
 04F1			     2			??0074:
 04F1  B8 0000		     2				mov ax, 0
			     2	
 04F4			     2			??0075:
 04F4  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??007A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??007A eq 0
 = <bx, ax>		     4				??007B     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??007B substr regStack, 1, (??007A - 1)
			     4				regStack substr regStack, (??007A + 1)
			     4			endif
			     4			exitm ??007B
			     3		%	for ??0079, __popRegs(regStack) 
			     3				pop ??0079
			     3			endm
 04F7  5B		     4				pop bx
 04F8  58		     4				pop ax
			     1			
 04F9  74 06		   *	    je     @C0038
			     1			.if (!zero?)
 04FB  83 C6 05		     1				add si, @SizeStr(WRITE)
 04FE  E9 01BF		     1				jmp ParseCommand@WRITE
 0501			   *@C0038:
			     1			.endif
					ParseCommand@UNDO:
			     1			StartsWith <EXIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0081     textequ <>
 = 			     3			??0082 textequ <>
			     3			for       ??0080, <ax,bx>
			     3				push  ??0080
			     3				??0082 catstr <??0080>, ??0081, ??0082
			     3				??0081 catstr <, >
			     3			endm
 0501  50		     4				push  ax
 = ax			     4				??0082 catstr <ax>, ??0081, ??0082
 = , 			     4				??0081 catstr <, >
 0502  53		     4				push  bx
 = bx, ax		     4				??0082 catstr <bx>, ??0081, ??0082
 = , 			     4				??0081 catstr <, >
 = <bx, ax>		     3			??0082 catstr OPEN_DELIMITER, ??0082, CLOSE_DELIMITER
			     3			__pushRegs ??0082
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0082
			     4			else
			     4				regStack catstr ??0082, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??007C = 0
			     2			
 0503  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??007C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007E
			     2	
			     2				??007C = ??007C + 1
			     2			endm 
 0505  8A 07		     3				mov al, [bx+??007C]
 0507  24 DF		     3				and al, 11011111b ; toUpperCase
 0509  3C 45		     3				cmp al, 'E'
 050B  75 20		     3				jne ??007E
			     3	
 = 0001			     3				??007C = ??007C + 1
 050D  8A 47 01		     3				mov al, [bx+??007C]
 0510  24 DF		     3				and al, 11011111b ; toUpperCase
 0512  3C 58		     3				cmp al, 'X'
 0514  75 17		     3				jne ??007E
			     3	
 = 0002			     3				??007C = ??007C + 1
 0516  8A 47 02		     3				mov al, [bx+??007C]
 0519  24 DF		     3				and al, 11011111b ; toUpperCase
 051B  3C 49		     3				cmp al, 'I'
 051D  75 0E		     3				jne ??007E
			     3	
 = 0003			     3				??007C = ??007C + 1
 051F  8A 47 03		     3				mov al, [bx+??007C]
 0522  24 DF		     3				and al, 11011111b ; toUpperCase
 0524  3C 54		     3				cmp al, 'T'
 0526  75 05		     3				jne ??007E
			     3	
 = 0004			     3				??007C = ??007C + 1
 0528  B8 0001		     2			mov ax, 1
			     2	
 052B  EB 03		     2			jmp ??007F
 052D			     2			??007E:
 052D  B8 0000		     2				mov ax, 0
			     2	
 0530			     2			??007F:
 0530  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0084 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0084 eq 0
 = <bx, ax>		     4				??0085     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0085 substr regStack, 1, (??0084 - 1)
			     4				regStack substr regStack, (??0084 + 1)
			     4			endif
			     4			exitm ??0085
			     3		%	for ??0083, __popRegs(regStack) 
			     3				pop ??0083
			     3			endm
 0533  5B		     4				pop bx
 0534  58		     4				pop ax
			     1			
 0535  74 06		   *	    je     @C003A
			     1			.if (!zero?)
 0537  83 C6 04		     1				add si, @SizeStr(EXIT)
 053A  E9 019A		     1				jmp ParseCommand@EXIT
 053D			   *@C003A:
			     1			.endif
						mov ax, CMD_UNDO
			     1			StartsWith <QUIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??008B     textequ <>
 = 			     3			??008C textequ <>
			     3			for       ??008A, <ax,bx>
			     3				push  ??008A
			     3				??008C catstr <??008A>, ??008B, ??008C
			     3				??008B catstr <, >
			     3			endm
 053D  50		     4				push  ax
 = ax			     4				??008C catstr <ax>, ??008B, ??008C
 = , 			     4				??008B catstr <, >
 053E  53		     4				push  bx
 = bx, ax		     4				??008C catstr <bx>, ??008B, ??008C
 = , 			     4				??008B catstr <, >
 = <bx, ax>		     3			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     3			__pushRegs ??008C
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??008C
			     4			else
			     4				regStack catstr ??008C, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0086 = 0
			     2			
 053F  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??0086]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0088
			     2	
			     2				??0086 = ??0086 + 1
			     2			endm 
 0541  8A 07		     3				mov al, [bx+??0086]
 0543  24 DF		     3				and al, 11011111b ; toUpperCase
 0545  3C 51		     3				cmp al, 'Q'
 0547  75 20		     3				jne ??0088
			     3	
 = 0001			     3				??0086 = ??0086 + 1
 0549  8A 47 01		     3				mov al, [bx+??0086]
 054C  24 DF		     3				and al, 11011111b ; toUpperCase
 054E  3C 55		     3				cmp al, 'U'
 0550  75 17		     3				jne ??0088
			     3	
 = 0002			     3				??0086 = ??0086 + 1
 0552  8A 47 02		     3				mov al, [bx+??0086]
 0555  24 DF		     3				and al, 11011111b ; toUpperCase
 0557  3C 49		     3				cmp al, 'I'
 0559  75 0E		     3				jne ??0088
			     3	
 = 0003			     3				??0086 = ??0086 + 1
 055B  8A 47 03		     3				mov al, [bx+??0086]
 055E  24 DF		     3				and al, 11011111b ; toUpperCase
 0560  3C 54		     3				cmp al, 'T'
 0562  75 05		     3				jne ??0088
			     3	
 = 0004			     3				??0086 = ??0086 + 1
 0564  B8 0001		     2			mov ax, 1
			     2	
 0567  EB 03		     2			jmp ??0089
 0569			     2			??0088:
 0569  B8 0000		     2				mov ax, 0
			     2	
 056C			     2			??0089:
 056C  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??008E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??008E eq 0
 = <bx, ax>		     4				??008F     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??008F substr regStack, 1, (??008E - 1)
			     4				regStack substr regStack, (??008E + 1)
			     4			endif
			     4			exitm ??008F
			     3		%	for ??008D, __popRegs(regStack) 
			     3				pop ??008D
			     3			endm
 056F  5B		     4				pop bx
 0570  58		     4				pop ax
			     1			
 0571  74 06		   *	    je     @C003C
			     1			.if (!zero?)
 0573  83 C6 04		     1				add si, @SizeStr(QUIT)
 0576  E9 015E		     1				jmp ParseCommand@EXIT
 0579			   *@C003C:
			     1			.endif
						jmp ParseCommand@success
				
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 0579  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if DEFINED(@Comando)
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0091     textequ <>
 = 			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
 057D  50		     5				push  ax
 = ax			     5				??0092 catstr <ax>, ??0091, ??0092
 = , 			     5				??0091 catstr <, >
 = <ax>			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@Comando>, <si>
 057E  8D 36 0310 R	     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0582			   *@C003E:
			     3			.repeat
 0582  8A 04		     3				mov al,   [si]
 0584  88 05		     3				mov [di], al
 0586  46		     3				inc si
 0587  47		     3				inc di
 0588  0A C0		   *	    or	al, al
 058A  75 F6		   *	    jne    @C003E
			     3			.until (al == 0)
 058C  4E		     3			dec    si
 058D  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
 = <ax>			     5				??0095     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)
			     5				regStack substr regStack, (??0094 + 1)
			     5			endif
			     5			exitm ??0095
			     4		%	for ??0093, __popRegs(regStack) 
			     4				pop ??0093
			     4			endm
 058E  58		     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if DEFINED(@space)
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0097     textequ <>
 = 			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
 058F  50		     5				push  ax
 = ax			     5				??0098 catstr <ax>, ??0097, ??0098
 = , 			     5				??0097 catstr <, >
 = <ax>			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@space>, <si>
 0590  8D 36 0345 R	     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0594			   *@C0040:
			     3			.repeat
 0594  8A 04		     3				mov al,   [si]
 0596  88 05		     3				mov [di], al
 0598  46		     3				inc si
 0599  47		     3				inc di
 059A  0A C0		   *	    or	al, al
 059C  75 F6		   *	    jne    @C0040
			     3			.until (al == 0)
 059E  4E		     3			dec    si
 059F  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
 = <ax>			     5				??009B     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)
			     5				regStack substr regStack, (??009A + 1)
			     5			endif
			     5			exitm ??009B
			     4		%	for ??0099, __popRegs(regStack) 
			     4				pop ??0099
			     4			endm
 05A0  58		     5				pop ax
			     2				else
			     2					strcpy_c <@space>, di
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if DEFINED(@desconhecido)
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??009D     textequ <>
 = 			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
 05A1  50		     5				push  ax
 = ax			     5				??009E catstr <ax>, ??009D, ??009E
 = , 			     5				??009D catstr <, >
 = <ax>			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
 05A2  8D 36 0338 R	     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05A6			   *@C0042:
			     3			.repeat
 05A6  8A 04		     3				mov al,   [si]
 05A8  88 05		     3				mov [di], al
 05AA  46		     3				inc si
 05AB  47		     3				inc di
 05AC  0A C0		   *	    or	al, al
 05AE  75 F6		   *	    jne    @C0042
			     3			.until (al == 0)
 05B0  4E		     3			dec    si
 05B1  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
 = <ax>			     5				??00A1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)
			     5				regStack substr regStack, (??00A0 + 1)
			     5			endif
			     5			exitm ??00A1
			     4		%	for ??009F, __popRegs(regStack) 
			     4				pop ??009F
			     4			endm
 05B2  58		     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A3     textequ <>
 = 			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
 05B3  50		     5				push  ax
 = ax			     5				??00A4 catstr <ax>, ??00A3, ??00A4
 = , 			     5				??00A3 catstr <, >
 = <ax>			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 05B4  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05B8			   *@C0044:
			     3			.repeat
 05B8  8A 04		     3				mov al,   [si]
 05BA  88 05		     3				mov [di], al
 05BC  46		     3				inc si
 05BD  47		     3				inc di
 05BE  0A C0		   *	    or	al, al
 05C0  75 F6		   *	    jne    @C0044
			     3			.until (al == 0)
 05C2  4E		     3			dec    si
 05C3  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
 = <ax>			     5				??00A7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)
			     5				regStack substr regStack, (??00A6 + 1)
			     5			endif
			     5			exitm ??00A7
			     4		%	for ??00A5, __popRegs(regStack) 
			     4				pop ??00A5
			     4			endm
 05C4  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A9     textequ <>
 = 			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
 05C5  50		     5				push  ax
 = ax			     5				??00AA catstr <ax>, ??00A9, ??00AA
 = , 			     5				??00A9 catstr <, >
 = <ax>			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 05C6  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05CA			   *@C0046:
			     3			.repeat
 05CA  8A 04		     3				mov al,   [si]
 05CC  88 05		     3				mov [di], al
 05CE  46		     3				inc si
 05CF  47		     3				inc di
 05D0  0A C0		   *	    or	al, al
 05D2  75 F6		   *	    jne    @C0046
			     3			.until (al == 0)
 05D4  4E		     3			dec    si
 05D5  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
 = <ax>			     5				??00AD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)
			     5				regStack substr regStack, (??00AC + 1)
			     5			endif
			     5			exitm ??00AD
			     4		%	for ??00AB, __popRegs(regStack) 
			     4				pop ??00AB
			     4			endm
 05D6  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
 05D7					ParseCommand@WRITE:
 05D7  F9					SkipSpacesInSI si
						
 05D8  5D		   *	    pop    bp
 05D9  5F		   *	    pop    di
 05DA  5E		   *	    pop    si
 05DB  8B E5		   *	    mov    sp, bp
 05DD  5D		   *	    pop    bp
 05DE  C3		   *	    ret    00000h
 05DF						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
			     1			SkipSpacesInSI si
 05DF  EB 01		   *	    jmp    @C0048
 05E1			   *@C0049:
			     2			.while (BYTE PTR [si] == ' ' )
 05E1  46		     2				inc si
 05E2			   *@C0048:
 05E2  80 3C 20		   *	    cmp    byte ptr [si], ' '
 05E5  74 FA		   *	    je     @C0049
			     2			.endw
 05E7  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 05EA  50		   *	    push   ax
 05EB  56		   *	    push   si
 05EC  E8 FDB9		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 05EF  73 03		   *	    jae    @C004B
			     1			.if            (carry?)
 05F1  F9		     1				stc
 05F2  EB 04		   *	    jmp    @C004D
 05F4			   *@C004B:
			     1			.else
 05F4  8B 5E FE		     1				mov bx, a
 05F7  F8		     1				clc
 05F8			   *@C004D:
			     1			.endif
							inc si
 05F8  73 07		   *	    jae    @C004E
 05FA  E8 012E					.endw
 05FD  EB D8					jmp ParseCommand@success
				
 05FF  EB 17		   *	    jmp    @C0050
 0601			   *@C004E:
 0601  3A 1E 03C7 R	   *	    cmp    bl, N
 0605  76 07		   *	    jbe    @C0051
 0607  E8 04B1				ParseCommand@EXIT:
 060A  EB CB					jmp ParseCommand@success
				
 060C  EB 0A		   *	    jmp    @C0053
 060E			   *@C0051:
 060E  80 FB 01		   *	    cmp    bl, 001h
 0611  73 05		   *	    jae    @C0054
 0613  E8 04A5				ParseCommand@success:
 0616  EB BF					SkipSpacesInSI si
						
 0618			   *@C0054:
 0618			   *@C0053:
 0618			   *@C0050:
						.if (byte ptr [si] != 0)
						
			     1			SkipSpacesInSI si
 0618  EB 01		   *	    jmp    @C0056
 061A			   *@C0057:
			     2			.while (BYTE PTR [si] == ' ' )
 061A  46		     2				inc si
 061B			   *@C0056:
 061B  80 3C 20		   *	    cmp    byte ptr [si], ' '
 061E  74 FA		   *	    je     @C0057
			     2			.endw
 0620  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 0623  50		   *	    push   ax
 0624  56		   *	    push   si
 0625  E8 FD80		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 0628  73 03		   *	    jae    @C0059
			     1			.if            (carry?)
 062A  F9		     1				stc
 062B  EB 04		   *	    jmp    @C005B
 062D			   *@C0059:
			     1			.else
 062D  8B 4E FE		     1				mov cx, a
 0630  F8		     1				clc
 0631			   *@C005B:
			     1			.endif
							strcpy_all                                          NonTerminalErrorBuffer, \
 0631  73 05		   *	    jae    @C005C
 0633  E8 01CF						<@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
 0636  EB 9F						
							jmp ParseCommand@error
 0638			   *@C005C:
						.endif
 0638  B8 0001					clc
						ret
 063B  E9 009B				ParseCommand endp
				
 063E				
					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			SkipSpacesInSI si
 063E  EB 01		   *	    jmp    @C005E
 0640			   *@C005F:
			     2			.while (BYTE PTR [si] == ' ' )
 0640  46		     2				inc si
 0641			   *@C005E:
 0641  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0644  74 FA		   *	    je     @C005F
			     2			.endw
 0646  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 0649  50		   *	    push   ax
 064A  56		   *	    push   si
 064B  E8 FD5A		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 064E  73 03		   *	    jae    @C0061
			     1			.if            (carry?)
 0650  F9		     1				stc
 0651  EB 04		   *	    jmp    @C0063
 0653			   *@C0061:
			     1			.else
 0653  8B 5E FE		     1				mov bx, a
 0656  F8		     1				clc
 0657			   *@C0063:
			     1			.endif
						ret
 0657  73 08		   *	    jae    @C0064
 0659  E8 028F				ParseCommand@LINHA_AUSENTE endp
 065C  E9 FF78			
					ParseCommand@CONSTANTE_AUSENTE proc near
 065F  EB 19		   *	    jmp    @C0066
 0661			   *@C0064:
 0661  3A 1E 03C7 R	   *	    cmp    bl, N
 0665  76 08		   *	    jbe    @C0067
 0667  E8 04BD					ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
 066A  E9 FF6A					ret
					ParseCommand@CONSTANTE_AUSENTE endp
 066D  EB 0B		   *	    jmp    @C0069
 066F			   *@C0067:
 066F  80 FB 01		   *	    cmp    bl, 001h
 0672  73 06		   *	    jae    @C006A
 0674  E8 04B0				
 0677  E9 FF5D				ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
 067A			   *@C006A:
 067A			   *@C0069:
 067A			   *@C0066:
						ret
					ParseCommand@LINHA_DST_AUSENTE endp
			     1			SkipSpacesInSI si
 067A  EB 01		   *	    jmp    @C006C
 067C			   *@C006D:
			     2			.while (BYTE PTR [si] == ' ' )
 067C  46		     2				inc si
 067D			   *@C006C:
 067D  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0680  74 FA		   *	    je     @C006D
			     2			.endw
 0682  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 0685  50		   *	    push   ax
 0686  56		   *	    push   si
 0687  E8 FD1E		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 068A  73 03		   *	    jae    @C006F
			     1			.if            (carry?)
 068C  F9		     1				stc
 068D  EB 04		   *	    jmp    @C0071
 068F			   *@C006F:
			     1			.else
 068F  8B 4E FE		     1				mov cx, a
 0692  F8		     1				clc
 0693			   *@C0071:
			     1			.endif
				
 0693  73 08		   *	    jae    @C0072
 0695  E8 033D				ParseCommand@LINHA_ORG_AUSENTE proc near
 0698  E9 FF3C					ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
						ret
 069B  EB 19		   *	    jmp    @C0074
 069D			   *@C0072:
 069D  3A 1E 03C7 R	   *	    cmp    bl, N
 06A1  76 08		   *	    jbe    @C0075
 06A3  E8 04FD				ParseCommand@LINHA_ORG_AUSENTE endp
 06A6  E9 FF2E			
					ParseCommand@LINHA_INVALIDA proc near
 06A9  EB 0B		   *	    jmp    @C0077
 06AB			   *@C0075:
 06AB  80 FB 01		   *	    cmp    bl, 001h
 06AE  73 06		   *	    jae    @C0078
 06B0  E8 04F0					ErrorNumberOutOfBounds <LINHA>
 06B3  E9 FF21					ret
					ParseCommand@LINHA_INVALIDA endp
 06B6			   *@C0078:
 06B6			   *@C0077:
 06B6			   *@C0074:
				
 06B6  B8 0003				ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
 06B9  EB 1E					ret
					ParseCommand@LINHA_DST_INVALIDA endp
 06BB				
 06BB  B8 0005				ParseCommand@LINHA_ORG_INVALIDA proc near
 06BE  EB 19					ErrorNumberOutOfBounds <LINHA_ORG>
						ret
 06C0					ParseCommand@LINHA_ORG_INVALIDA endp
				
 06C0  EB 01		   *	    jmp    @C007A
 06C2			   *@C007B:
			     1			.while (BYTE PTR [si] == ' ' )
 06C2  46		     1				inc si
 06C3			   *@C007A:
 06C3  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06C6  74 FA		   *	    je     @C007B
			     1			.endw
				
 06C8  8B D6			
 06CA  B8 0006			;====================================================================
				; Reading error reporting
 06CD  EB 01		   *	    jmp    @C007D
 06CF			   *@C007E:
 06CF  46				ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
 06D0			   *@C007D:
 06D0  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06D3  75 FA		   *	    jne    @C007E
 06D5  EB 02					jmp      ExitFailure
				
 06D7					ErrorRead:
 06D7  EB 00					printf_c <Erro na leitura do arquivo.>
						jmp      ExitFailure
 06D9				
					ErrorColumnCount:
 06D9  EB 01		   *	    jmp    @C0080
 06DB			   *@C0081:
			     1			.while (BYTE PTR [si] == ' ' )
 06DB  46		     1				inc si
 06DC			   *@C0080:
 06DC  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06DF  74 FA		   *	    je     @C0081
			     1			.endw
						print_FilePosition
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
 06E1  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06E4  74 3D		   *	    je     @C0083
						jmp      ExitFailure
				
					ErrorRowCount:
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 06E6  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if DEFINED(@@parametros_nao_reconhecidos_ao_final_do_comando)
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00AF     textequ <>
 = 			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
 06EA  50		     5				push  ax
 = ax			     5				??00B0 catstr <ax>, ??00AF, ??00B0
 = , 			     5				??00AF catstr <, >
 = <ax>			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
 06EB  8D 36 0388 R	     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06EF			   *@C0085:
			     3			.repeat
 06EF  8A 04		     3				mov al,   [si]
 06F1  88 05		     3				mov [di], al
 06F3  46		     3				inc si
 06F4  47		     3				inc di
 06F5  0A C0		   *	    or	al, al
 06F7  75 F6		   *	    jne    @C0085
			     3			.until (al == 0)
 06F9  4E		     3			dec    si
 06FA  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
 = <ax>			     5				??00B3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)
			     5				regStack substr regStack, (??00B2 + 1)
			     5			endif
			     5			exitm ??00B3
			     4		%	for ??00B1, __popRegs(regStack) 
			     4				pop ??00B1
			     4			endm
 06FB  58		     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00B5     textequ <>
 = 			     4			??00B6 textequ <>
			     4			for       ??00B4, <ax>
			     4				push  ??00B4
			     4				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     4				??00B5 catstr <, >
			     4			endm
 06FC  50		     5				push  ax
 = ax			     5				??00B6 catstr <ax>, ??00B5, ??00B6
 = , 			     5				??00B5 catstr <, >
 = <ax>			     4			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
			     4			__pushRegs ??00B6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00B6
			     5			else
			     5				regStack catstr ??00B6, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 06FD  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0701			   *@C0087:
			     3			.repeat
 0701  8A 04		     3				mov al,   [si]
 0703  88 05		     3				mov [di], al
 0705  46		     3				inc si
 0706  47		     3				inc di
 0707  0A C0		   *	    or	al, al
 0709  75 F6		   *	    jne    @C0087
			     3			.until (al == 0)
 070B  4E		     3			dec    si
 070C  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00B8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B8 eq 0
 = <ax>			     5				??00B9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00B9 substr regStack, 1, (??00B8 - 1)
			     5				regStack substr regStack, (??00B8 + 1)
			     5			endif
			     5			exitm ??00B9
			     4		%	for ??00B7, __popRegs(regStack) 
			     4				pop ??00B7
			     4			endm
 070D  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00BB     textequ <>
 = 			     4			??00BC textequ <>
			     4			for       ??00BA, <ax>
			     4				push  ??00BA
			     4				??00BC catstr <??00BA>, ??00BB, ??00BC
			     4				??00BB catstr <, >
			     4			endm
 070E  50		     5				push  ax
 = ax			     5				??00BC catstr <ax>, ??00BB, ??00BC
 = , 			     5				??00BB catstr <, >
 = <ax>			     4			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
			     4			__pushRegs ??00BC
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00BC
			     5			else
			     5				regStack catstr ??00BC, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 070F  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0713			   *@C0089:
			     3			.repeat
 0713  8A 04		     3				mov al,   [si]
 0715  88 05		     3				mov [di], al
 0717  46		     3				inc si
 0718  47		     3				inc di
 0719  0A C0		   *	    or	al, al
 071B  75 F6		   *	    jne    @C0089
			     3			.until (al == 0)
 071D  4E		     3			dec    si
 071E  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00BE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00BE eq 0
 = <ax>			     5				??00BF     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00BF substr regStack, 1, (??00BE - 1)
			     5				regStack substr regStack, (??00BE + 1)
			     5			endif
			     5			exitm ??00BF
			     4		%	for ??00BD, __popRegs(regStack) 
			     4				pop ??00BD
			     4			endm
 071F  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
 0720  E9 FEB4					print_TotalRowCol
						jmp      ExitFailure
 0723			   *@C0083:
 0723  F8			
					ErrorUnexpectedChar:
 0724  5D		   *	    pop    bp
 0725  5F		   *	    pop    di
 0726  5E		   *	    pop    si
 0727  8B E5		   *	    mov    sp, bp
 0729  5D		   *	    pop    bp
 072A  C3		   *	    ret    00000h
 072B						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
				
 072B						print_FilePosition
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< LINHA !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 072B  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
 072F  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C2 catstr <ax>, ??00C1, ??00C2
 = <ax>			     5				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack
			     4			endif
 0730  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0734			   *@C008B:
			     4			endif
 0734  8A 04		     4			.repeat
 0736  88 05		     4				mov al,   [si]
 0738  46		     4				mov [di], al
 0739  47		     4				inc si
 073A  0A C0		   *	    or	al, al
 073C  75 F6		   *	    jne    @C008B
			     4				inc di
 073E  4E		     4			.until (al == 0)
 073F  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00C4 eq 0
 = 			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)
			     6				regStack substr regStack, (??00C4 + 1)
			     6			endif
			     5			exitm ??00C5
			     5		%	for ??00C3, __popRegs(regStack) 
			     5				pop ??00C3
 0740  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0741  C6 05 20		     5			endm
 0744  47		     5				mov byte ptr [di], ' '
 0745  C6 05 22		     5				inc di
 0748  47		     5				mov byte ptr [di], '"'
 0749  C6 05 4D		     5				inc di
 074C  47		     5				mov byte ptr [di], 'M'
 074D  C6 05 55		     5				inc di
 0750  47		     5				mov byte ptr [di], 'U'
 0751  C6 05 4C		     5				inc di
 0754  47		     5				mov byte ptr [di], 'L'
 0755  C6 05 22		     5				inc di
 0758  47		     5				mov byte ptr [di], '"'
 0759  C6 05 20		     5				inc di
 075C  47		     5				mov byte ptr [di], ' '
 075D  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
 0760  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C8 catstr <ax>, ??00C7, ??00C8
 = <ax>			     5				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack
			     4			endif
 0761  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0765			   *@C008D:
			     4			endif
 0765  8A 04		     4			.repeat
 0767  88 05		     4				mov al,   [si]
 0769  46		     4				mov [di], al
 076A  47		     4				inc si
 076B  0A C0		   *	    or	al, al
 076D  75 F6		   *	    jne    @C008D
			     4				inc di
 076F  4E		     4			.until (al == 0)
 0770  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00CA eq 0
 = 			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)
			     6				regStack substr regStack, (??00CA + 1)
			     6			endif
			     5			exitm ??00CB
			     5		%	for ??00C9, __popRegs(regStack) 
			     5				pop ??00C9
 0771  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0772  C6 05 20		     5			endm
 0775  47		     5				mov byte ptr [di], ' '
 0776  C6 05 4C		     5				inc di
 0779  47		     5				mov byte ptr [di], 'L'
 077A  C6 05 49		     5				inc di
 077D  47		     5				mov byte ptr [di], 'I'
 077E  C6 05 4E		     5				inc di
 0781  47		     5				mov byte ptr [di], 'N'
 0782  C6 05 48		     5				inc di
 0785  47		     5				mov byte ptr [di], 'H'
 0786  C6 05 41		     5				inc di
 0789  47		     5				mov byte ptr [di], 'A'
 078A  C6 05 20		     5				inc di
 078D  47		     5				mov byte ptr [di], ' '
 078E  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
 0791  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00CE catstr <ax>, ??00CD, ??00CE
 = <ax>			     5				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00CE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack
			     4			endif
 0792  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0796			   *@C008F:
			     4			endif
 0796  8A 04		     4			.repeat
 0798  88 05		     4				mov al,   [si]
 079A  46		     4				mov [di], al
 079B  47		     4				inc si
 079C  0A C0		   *	    or	al, al
 079E  75 F6		   *	    jne    @C008F
			     4				inc di
 07A0  4E		     4			.until (al == 0)
 07A1  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D0 eq 0
 = 			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)
			     6				regStack substr regStack, (??00D0 + 1)
			     6			endif
			     5			exitm ??00D1
			     5		%	for ??00CF, __popRegs(regStack) 
			     5				pop ??00CF
 07A2  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 07A3  C6 05 20		     5			endm
 07A6  47		     5				mov byte ptr [di], ' '
 07A7  C6 05 50		     5				inc di
 07AA  47		     5				mov byte ptr [di], 'P'
 07AB  C6 05 52		     5				inc di
 07AE  47		     5				mov byte ptr [di], 'R'
 07AF  C6 05 49		     5				inc di
 07B2  47		     5				mov byte ptr [di], 'I'
 07B3  C6 05 4D		     5				inc di
 07B6  47		     5				mov byte ptr [di], 'M'
 07B7  C6 05 45		     5				inc di
 07BA  47		     5				mov byte ptr [di], 'E'
 07BB  C6 05 49		     5				inc di
 07BE  47		     5				mov byte ptr [di], 'I'
 07BF  C6 05 52		     5				inc di
 07C2  47		     5				mov byte ptr [di], 'R'
 07C3  C6 05 4F		     5				inc di
 07C6  47		     5				mov byte ptr [di], 'O'
 07C7  C6 05 20		     5				inc di
 07CA  47		     5				mov byte ptr [di], ' '
 07CB  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
 07CE  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00D4 catstr <ax>, ??00D3, ??00D4
 = <ax>			     5				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00D4
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack
			     4			endif
 07CF  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07D3			   *@C0091:
			     4			endif
 07D3  8A 04		     4			.repeat
 07D5  88 05		     4				mov al,   [si]
 07D7  46		     4				mov [di], al
 07D8  47		     4				inc si
 07D9  0A C0		   *	    or	al, al
 07DB  75 F6		   *	    jne    @C0091
			     4				inc di
 07DD  4E		     4			.until (al == 0)
 07DE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D6 eq 0
 = 			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)
			     6				regStack substr regStack, (??00D6 + 1)
			     6			endif
			     5			exitm ??00D7
			     5		%	for ??00D5, __popRegs(regStack) 
			     5				pop ??00D5
 07DF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
 07E0  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00DA catstr <ax>, ??00D9, ??00DA
 = <ax>			     5				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00DA
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack
			     4			endif
 07E1  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07E5			   *@C0093:
			     4			endif
 07E5  8A 04		     4			.repeat
 07E7  88 05		     4				mov al,   [si]
 07E9  46		     4				mov [di], al
 07EA  47		     4				inc si
 07EB  0A C0		   *	    or	al, al
 07ED  75 F6		   *	    jne    @C0093
			     4				inc di
 07EF  4E		     4			.until (al == 0)
 07F0  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00DC eq 0
 = 			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)
			     6				regStack substr regStack, (??00DC + 1)
			     6			endif
			     5			exitm ??00DD
			     5		%	for ??00DB, __popRegs(regStack) 
			     5				pop ??00DB
 07F1  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
 07F2  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E0 catstr <ax>, ??00DF, ??00E0
 = <ax>			     5				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E0
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack
			     4			endif
 07F3  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07F7			   *@C0095:
			     4			endif
 07F7  8A 04		     4			.repeat
 07F9  88 05		     4				mov al,   [si]
 07FB  46		     4				mov [di], al
 07FC  47		     4				inc si
 07FD  0A C0		   *	    or	al, al
 07FF  75 F6		   *	    jne    @C0095
			     4				inc di
 0801  4E		     4			.until (al == 0)
 0802  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E2 eq 0
 = 			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)
			     6				regStack substr regStack, (??00E2 + 1)
			     6			endif
			     5			exitm ??00E3
			     5		%	for ??00E1, __popRegs(regStack) 
			     5				pop ??00E1
 0803  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0804  C3					printf_c < Erro: caracter inexperado: ">
 0805						invoke   printf_s, addr TheUnexpectedChar
				
 0805						jmp ExitFailure
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< CONSTANTE !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 0805  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
 0809  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E6 catstr <ax>, ??00E5, ??00E6
 = <ax>			     5				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E6
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStack
			     4			endif
 080A  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 080E			   *@C0097:
			     4			endif
 080E  8A 04		     4			.repeat
 0810  88 05		     4				mov al,   [si]
 0812  46		     4				mov [di], al
 0813  47		     4				inc si
 0814  0A C0		   *	    or	al, al
 0816  75 F6		   *	    jne    @C0097
			     4				inc di
 0818  4E		     4			.until (al == 0)
 0819  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E8 eq 0
 = 			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)
			     6				regStack substr regStack, (??00E8 + 1)
			     6			endif
			     5			exitm ??00E9
			     5		%	for ??00E7, __popRegs(regStack) 
			     5				pop ??00E7
 081A  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 081B  C6 05 20		     5			endm
 081E  47		     5				mov byte ptr [di], ' '
 081F  C6 05 22		     5				inc di
 0822  47		     5				mov byte ptr [di], '"'
 0823  C6 05 4D		     5				inc di
 0826  47		     5				mov byte ptr [di], 'M'
 0827  C6 05 55		     5				inc di
 082A  47		     5				mov byte ptr [di], 'U'
 082B  C6 05 4C		     5				inc di
 082E  47		     5				mov byte ptr [di], 'L'
 082F  C6 05 22		     5				inc di
 0832  47		     5				mov byte ptr [di], '"'
 0833  C6 05 20		     5				inc di
 0836  47		     5				mov byte ptr [di], ' '
 0837  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
 083A  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00EC catstr <ax>, ??00EB, ??00EC
 = <ax>			     5				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00EC
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack
			     4			endif
 083B  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 083F			   *@C0099:
			     4			endif
 083F  8A 04		     4			.repeat
 0841  88 05		     4				mov al,   [si]
 0843  46		     4				mov [di], al
 0844  47		     4				inc si
 0845  0A C0		   *	    or	al, al
 0847  75 F6		   *	    jne    @C0099
			     4				inc di
 0849  4E		     4			.until (al == 0)
 084A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00EE eq 0
 = 			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)
			     6				regStack substr regStack, (??00EE + 1)
			     6			endif
			     5			exitm ??00EF
			     5		%	for ??00ED, __popRegs(regStack) 
			     5				pop ??00ED
 084B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( CONSTANTE )
			     3					strcpy  CONSTANTE , di
			     3				else
			     4					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 084C  C6 05 20		     5			endm
 084F  47		     5				mov byte ptr [di], ' '
 0850  C6 05 43		     5				inc di
 0853  47		     5				mov byte ptr [di], 'C'
 0854  C6 05 4F		     5				inc di
 0857  47		     5				mov byte ptr [di], 'O'
 0858  C6 05 4E		     5				inc di
 085B  47		     5				mov byte ptr [di], 'N'
 085C  C6 05 53		     5				inc di
 085F  47		     5				mov byte ptr [di], 'S'
 0860  C6 05 54		     5				inc di
 0863  47		     5				mov byte ptr [di], 'T'
 0864  C6 05 41		     5				inc di
 0867  47		     5				mov byte ptr [di], 'A'
 0868  C6 05 4E		     5				inc di
 086B  47		     5				mov byte ptr [di], 'N'
 086C  C6 05 54		     5				inc di
 086F  47		     5				mov byte ptr [di], 'T'
 0870  C6 05 45		     5				inc di
 0873  47		     5				mov byte ptr [di], 'E'
 0874  C6 05 20		     5				inc di
 0877  47		     5				mov byte ptr [di], ' '
 0878  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
 087B  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F2 catstr <ax>, ??00F1, ??00F2
 = <ax>			     5				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStack
			     4			endif
 087C  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0880			   *@C009B:
			     4			endif
 0880  8A 04		     4			.repeat
 0882  88 05		     4				mov al,   [si]
 0884  46		     4				mov [di], al
 0885  47		     4				inc si
 0886  0A C0		   *	    or	al, al
 0888  75 F6		   *	    jne    @C009B
			     4				inc di
 088A  4E		     4			.until (al == 0)
 088B  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00F4 eq 0
 = 			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)
			     6				regStack substr regStack, (??00F4 + 1)
			     6			endif
			     5			exitm ??00F5
			     5		%	for ??00F3, __popRegs(regStack) 
			     5				pop ??00F3
 088C  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 088D  C6 05 20		     5			endm
 0890  47		     5				mov byte ptr [di], ' '
 0891  C6 05 53		     5				inc di
 0894  47		     5				mov byte ptr [di], 'S'
 0895  C6 05 45		     5				inc di
 0898  47		     5				mov byte ptr [di], 'E'
 0899  C6 05 47		     5				inc di
 089C  47		     5				mov byte ptr [di], 'G'
 089D  C6 05 55		     5				inc di
 08A0  47		     5				mov byte ptr [di], 'U'
 08A1  C6 05 4E		     5				inc di
 08A4  47		     5				mov byte ptr [di], 'N'
 08A5  C6 05 44		     5				inc di
 08A8  47		     5				mov byte ptr [di], 'D'
 08A9  C6 05 4F		     5				inc di
 08AC  47		     5				mov byte ptr [di], 'O'
 08AD  C6 05 20		     5				inc di
 08B0  47		     5				mov byte ptr [di], ' '
 08B1  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
 08B4  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F8 catstr <ax>, ??00F7, ??00F8
 = <ax>			     5				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack
			     4			endif
 08B5  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08B9			   *@C009D:
			     4			endif
 08B9  8A 04		     4			.repeat
 08BB  88 05		     4				mov al,   [si]
 08BD  46		     4				mov [di], al
 08BE  47		     4				inc si
 08BF  0A C0		   *	    or	al, al
 08C1  75 F6		   *	    jne    @C009D
			     4				inc di
 08C3  4E		     4			.until (al == 0)
 08C4  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00FA eq 0
 = 			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)
			     6				regStack substr regStack, (??00FA + 1)
			     6			endif
			     5			exitm ??00FB
			     5		%	for ??00F9, __popRegs(regStack) 
			     5				pop ??00F9
 08C5  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
 08C6  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00FE catstr <ax>, ??00FD, ??00FE
 = <ax>			     5				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00FE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack
			     4			endif
 08C7  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08CB			   *@C009F:
			     4			endif
 08CB  8A 04		     4			.repeat
 08CD  88 05		     4				mov al,   [si]
 08CF  46		     4				mov [di], al
 08D0  47		     4				inc si
 08D1  0A C0		   *	    or	al, al
 08D3  75 F6		   *	    jne    @C009F
			     4				inc di
 08D5  4E		     4			.until (al == 0)
 08D6  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0100 eq 0
 = 			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)
			     6				regStack substr regStack, (??0100 + 1)
			     6			endif
			     5			exitm ??0101
			     5		%	for ??00FF, __popRegs(regStack) 
			     5				pop ??00FF
 08D7  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
 08D8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0104 catstr <ax>, ??0103, ??0104
 = <ax>			     5				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0104
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack
			     4			endif
 08D9  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08DD			   *@C00A1:
			     4			endif
 08DD  8A 04		     4			.repeat
 08DF  88 05		     4				mov al,   [si]
 08E1  46		     4				mov [di], al
 08E2  47		     4				inc si
 08E3  0A C0		   *	    or	al, al
 08E5  75 F6		   *	    jne    @C00A1
			     4				inc di
 08E7  4E		     4			.until (al == 0)
 08E8  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0106 eq 0
 = 			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)
			     6				regStack substr regStack, (??0106 + 1)
			     6			endif
			     5			exitm ??0107
			     5		%	for ??0105, __popRegs(regStack) 
			     5				pop ??0105
 08E9  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 08EA  C3				ErrorInvalidN:
 08EB						print_FilePosition
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
 08EB						invoke   printf_u, N
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_DST !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 08EB  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
 08EF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??010A catstr <ax>, ??0109, ??010A
 = <ax>			     5				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??010A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack
			     4			endif
 08F0  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08F4			   *@C00A3:
			     4			endif
 08F4  8A 04		     4			.repeat
 08F6  88 05		     4				mov al,   [si]
 08F8  46		     4				mov [di], al
 08F9  47		     4				inc si
 08FA  0A C0		   *	    or	al, al
 08FC  75 F6		   *	    jne    @C00A3
			     4				inc di
 08FE  4E		     4			.until (al == 0)
 08FF  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??010C eq 0
 = 			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)
			     6				regStack substr regStack, (??010C + 1)
			     6			endif
			     5			exitm ??010D
			     5		%	for ??010B, __popRegs(regStack) 
			     5				pop ??010B
 0900  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0901  C6 05 20		     5			endm
 0904  47		     5				mov byte ptr [di], ' '
 0905  C6 05 22		     5				inc di
 0908  47		     5				mov byte ptr [di], '"'
 0909  C6 05 41		     5				inc di
 090C  47		     5				mov byte ptr [di], 'A'
 090D  C6 05 44		     5				inc di
 0910  47		     5				mov byte ptr [di], 'D'
 0911  C6 05 44		     5				inc di
 0914  47		     5				mov byte ptr [di], 'D'
 0915  C6 05 22		     5				inc di
 0918  47		     5				mov byte ptr [di], '"'
 0919  C6 05 20		     5				inc di
 091C  47		     5				mov byte ptr [di], ' '
 091D  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
 0920  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0110 catstr <ax>, ??010F, ??0110
 = <ax>			     5				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0110
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack
			     4			endif
 0921  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0925			   *@C00A5:
			     4			endif
 0925  8A 04		     4			.repeat
 0927  88 05		     4				mov al,   [si]
 0929  46		     4				mov [di], al
 092A  47		     4				inc si
 092B  0A C0		   *	    or	al, al
 092D  75 F6		   *	    jne    @C00A5
			     4				inc di
 092F  4E		     4			.until (al == 0)
 0930  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0112 eq 0
 = 			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)
			     6				regStack substr regStack, (??0112 + 1)
			     6			endif
			     5			exitm ??0113
			     5		%	for ??0111, __popRegs(regStack) 
			     5				pop ??0111
 0931  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0932  C6 05 20		     5			endm
 0935  47		     5				mov byte ptr [di], ' '
 0936  C6 05 4C		     5				inc di
 0939  47		     5				mov byte ptr [di], 'L'
 093A  C6 05 49		     5				inc di
 093D  47		     5				mov byte ptr [di], 'I'
 093E  C6 05 4E		     5				inc di
 0941  47		     5				mov byte ptr [di], 'N'
 0942  C6 05 48		     5				inc di
 0945  47		     5				mov byte ptr [di], 'H'
 0946  C6 05 41		     5				inc di
 0949  47		     5				mov byte ptr [di], 'A'
 094A  C6 05 5F		     5				inc di
 094D  47		     5				mov byte ptr [di], '_'
 094E  C6 05 44		     5				inc di
 0951  47		     5				mov byte ptr [di], 'D'
 0952  C6 05 53		     5				inc di
 0955  47		     5				mov byte ptr [di], 'S'
 0956  C6 05 54		     5				inc di
 0959  47		     5				mov byte ptr [di], 'T'
 095A  C6 05 20		     5				inc di
 095D  47		     5				mov byte ptr [di], ' '
 095E  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
 0961  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0116 catstr <ax>, ??0115, ??0116
 = <ax>			     5				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0116
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack
			     4			endif
 0962  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0966			   *@C00A7:
			     4			endif
 0966  8A 04		     4			.repeat
 0968  88 05		     4				mov al,   [si]
 096A  46		     4				mov [di], al
 096B  47		     4				inc si
 096C  0A C0		   *	    or	al, al
 096E  75 F6		   *	    jne    @C00A7
			     4				inc di
 0970  4E		     4			.until (al == 0)
 0971  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0118 eq 0
 = 			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)
			     6				regStack substr regStack, (??0118 + 1)
			     6			endif
			     5			exitm ??0119
			     5		%	for ??0117, __popRegs(regStack) 
			     5				pop ??0117
 0972  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0973  C6 05 20		     5			endm
 0976  47		     5				mov byte ptr [di], ' '
 0977  C6 05 50		     5				inc di
 097A  47		     5				mov byte ptr [di], 'P'
 097B  C6 05 52		     5				inc di
 097E  47		     5				mov byte ptr [di], 'R'
 097F  C6 05 49		     5				inc di
 0982  47		     5				mov byte ptr [di], 'I'
 0983  C6 05 4D		     5				inc di
 0986  47		     5				mov byte ptr [di], 'M'
 0987  C6 05 45		     5				inc di
 098A  47		     5				mov byte ptr [di], 'E'
 098B  C6 05 49		     5				inc di
 098E  47		     5				mov byte ptr [di], 'I'
 098F  C6 05 52		     5				inc di
 0992  47		     5				mov byte ptr [di], 'R'
 0993  C6 05 4F		     5				inc di
 0996  47		     5				mov byte ptr [di], 'O'
 0997  C6 05 20		     5				inc di
 099A  47		     5				mov byte ptr [di], ' '
 099B  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
 099E  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??011C catstr <ax>, ??011B, ??011C
 = <ax>			     5				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??011C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack
			     4			endif
 099F  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09A3			   *@C00A9:
			     4			endif
 09A3  8A 04		     4			.repeat
 09A5  88 05		     4				mov al,   [si]
 09A7  46		     4				mov [di], al
 09A8  47		     4				inc si
 09A9  0A C0		   *	    or	al, al
 09AB  75 F6		   *	    jne    @C00A9
			     4				inc di
 09AD  4E		     4			.until (al == 0)
 09AE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??011E eq 0
 = 			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)
			     6				regStack substr regStack, (??011E + 1)
			     6			endif
			     5			exitm ??011F
			     5		%	for ??011D, __popRegs(regStack) 
			     5				pop ??011D
 09AF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
 09B0  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0122 catstr <ax>, ??0121, ??0122
 = <ax>			     5				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0122
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack
			     4			endif
 09B1  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09B5			   *@C00AB:
			     4			endif
 09B5  8A 04		     4			.repeat
 09B7  88 05		     4				mov al,   [si]
 09B9  46		     4				mov [di], al
 09BA  47		     4				inc si
 09BB  0A C0		   *	    or	al, al
 09BD  75 F6		   *	    jne    @C00AB
			     4				inc di
 09BF  4E		     4			.until (al == 0)
 09C0  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0124 eq 0
 = 			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1)
			     6				regStack substr regStack, (??0124 + 1)
			     6			endif
			     5			exitm ??0125
			     5		%	for ??0123, __popRegs(regStack) 
			     5				pop ??0123
 09C1  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
 09C2  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0128 catstr <ax>, ??0127, ??0128
 = <ax>			     5				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0128
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack
			     4			endif
 09C3  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09C7			   *@C00AD:
			     4			endif
 09C7  8A 04		     4			.repeat
 09C9  88 05		     4				mov al,   [si]
 09CB  46		     4				mov [di], al
 09CC  47		     4				inc si
 09CD  0A C0		   *	    or	al, al
 09CF  75 F6		   *	    jne    @C00AD
			     4				inc di
 09D1  4E		     4			.until (al == 0)
 09D2  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??012A eq 0
 = 			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1)
			     6				regStack substr regStack, (??012A + 1)
			     6			endif
			     5			exitm ??012B
			     5		%	for ??0129, __popRegs(regStack) 
			     5				pop ??0129
 09D3  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 09D4  C3			
 09D5					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
 09D5						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_ORG !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 09D5  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
 09D9  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??012E catstr <ax>, ??012D, ??012E
 = <ax>			     5				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??012E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack
			     4			endif
 09DA  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09DE			   *@C00AF:
			     4			endif
 09DE  8A 04		     4			.repeat
 09E0  88 05		     4				mov al,   [si]
 09E2  46		     4				mov [di], al
 09E3  47		     4				inc si
 09E4  0A C0		   *	    or	al, al
 09E6  75 F6		   *	    jne    @C00AF
			     4				inc di
 09E8  4E		     4			.until (al == 0)
 09E9  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0130 eq 0
 = 			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)
			     6				regStack substr regStack, (??0130 + 1)
			     6			endif
			     5			exitm ??0131
			     5		%	for ??012F, __popRegs(regStack) 
			     5				pop ??012F
 09EA  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 09EB  C6 05 20		     5			endm
 09EE  47		     5				mov byte ptr [di], ' '
 09EF  C6 05 22		     5				inc di
 09F2  47		     5				mov byte ptr [di], '"'
 09F3  C6 05 41		     5				inc di
 09F6  47		     5				mov byte ptr [di], 'A'
 09F7  C6 05 44		     5				inc di
 09FA  47		     5				mov byte ptr [di], 'D'
 09FB  C6 05 44		     5				inc di
 09FE  47		     5				mov byte ptr [di], 'D'
 09FF  C6 05 22		     5				inc di
 0A02  47		     5				mov byte ptr [di], '"'
 0A03  C6 05 20		     5				inc di
 0A06  47		     5				mov byte ptr [di], ' '
 0A07  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
 0A0A  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0134 catstr <ax>, ??0133, ??0134
 = <ax>			     5				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0134
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack
			     4			endif
 0A0B  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A0F			   *@C00B1:
			     4			endif
 0A0F  8A 04		     4			.repeat
 0A11  88 05		     4				mov al,   [si]
 0A13  46		     4				mov [di], al
 0A14  47		     4				inc si
 0A15  0A C0		   *	    or	al, al
 0A17  75 F6		   *	    jne    @C00B1
			     4				inc di
 0A19  4E		     4			.until (al == 0)
 0A1A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0136 eq 0
 = 			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1)
			     6				regStack substr regStack, (??0136 + 1)
			     6			endif
			     5			exitm ??0137
			     5		%	for ??0135, __popRegs(regStack) 
			     5				pop ??0135
 0A1B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A1C  C6 05 20		     5			endm
 0A1F  47		     5				mov byte ptr [di], ' '
 0A20  C6 05 4C		     5				inc di
 0A23  47		     5				mov byte ptr [di], 'L'
 0A24  C6 05 49		     5				inc di
 0A27  47		     5				mov byte ptr [di], 'I'
 0A28  C6 05 4E		     5				inc di
 0A2B  47		     5				mov byte ptr [di], 'N'
 0A2C  C6 05 48		     5				inc di
 0A2F  47		     5				mov byte ptr [di], 'H'
 0A30  C6 05 41		     5				inc di
 0A33  47		     5				mov byte ptr [di], 'A'
 0A34  C6 05 5F		     5				inc di
 0A37  47		     5				mov byte ptr [di], '_'
 0A38  C6 05 4F		     5				inc di
 0A3B  47		     5				mov byte ptr [di], 'O'
 0A3C  C6 05 52		     5				inc di
 0A3F  47		     5				mov byte ptr [di], 'R'
 0A40  C6 05 47		     5				inc di
 0A43  47		     5				mov byte ptr [di], 'G'
 0A44  C6 05 20		     5				inc di
 0A47  47		     5				mov byte ptr [di], ' '
 0A48  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
 0A4B  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??013A catstr <ax>, ??0139, ??013A
 = <ax>			     5				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??013A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack
			     4			endif
 0A4C  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A50			   *@C00B3:
			     4			endif
 0A50  8A 04		     4			.repeat
 0A52  88 05		     4				mov al,   [si]
 0A54  46		     4				mov [di], al
 0A55  47		     4				inc si
 0A56  0A C0		   *	    or	al, al
 0A58  75 F6		   *	    jne    @C00B3
			     4				inc di
 0A5A  4E		     4			.until (al == 0)
 0A5B  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??013C eq 0
 = 			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)
			     6				regStack substr regStack, (??013C + 1)
			     6			endif
			     5			exitm ??013D
			     5		%	for ??013B, __popRegs(regStack) 
			     5				pop ??013B
 0A5C  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A5D  C6 05 20		     5			endm
 0A60  47		     5				mov byte ptr [di], ' '
 0A61  C6 05 53		     5				inc di
 0A64  47		     5				mov byte ptr [di], 'S'
 0A65  C6 05 45		     5				inc di
 0A68  47		     5				mov byte ptr [di], 'E'
 0A69  C6 05 47		     5				inc di
 0A6C  47		     5				mov byte ptr [di], 'G'
 0A6D  C6 05 55		     5				inc di
 0A70  47		     5				mov byte ptr [di], 'U'
 0A71  C6 05 4E		     5				inc di
 0A74  47		     5				mov byte ptr [di], 'N'
 0A75  C6 05 44		     5				inc di
 0A78  47		     5				mov byte ptr [di], 'D'
 0A79  C6 05 4F		     5				inc di
 0A7C  47		     5				mov byte ptr [di], 'O'
 0A7D  C6 05 20		     5				inc di
 0A80  47		     5				mov byte ptr [di], ' '
 0A81  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
 0A84  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0140 catstr <ax>, ??013F, ??0140
 = <ax>			     5				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0140
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack
			     4			endif
 0A85  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A89			   *@C00B5:
			     4			endif
 0A89  8A 04		     4			.repeat
 0A8B  88 05		     4				mov al,   [si]
 0A8D  46		     4				mov [di], al
 0A8E  47		     4				inc si
 0A8F  0A C0		   *	    or	al, al
 0A91  75 F6		   *	    jne    @C00B5
			     4				inc di
 0A93  4E		     4			.until (al == 0)
 0A94  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0142 eq 0
 = 			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)
			     6				regStack substr regStack, (??0142 + 1)
			     6			endif
			     5			exitm ??0143
			     5		%	for ??0141, __popRegs(regStack) 
			     5				pop ??0141
 0A95  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
 0A96  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0146 catstr <ax>, ??0145, ??0146
 = <ax>			     5				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0146
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack
			     4			endif
 0A97  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A9B			   *@C00B7:
			     4			endif
 0A9B  8A 04		     4			.repeat
 0A9D  88 05		     4				mov al,   [si]
 0A9F  46		     4				mov [di], al
 0AA0  47		     4				inc si
 0AA1  0A C0		   *	    or	al, al
 0AA3  75 F6		   *	    jne    @C00B7
			     4				inc di
 0AA5  4E		     4			.until (al == 0)
 0AA6  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0148 eq 0
 = 			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)
			     6				regStack substr regStack, (??0148 + 1)
			     6			endif
			     5			exitm ??0149
			     5		%	for ??0147, __popRegs(regStack) 
			     5				pop ??0147
 0AA7  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
 0AA8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??014C catstr <ax>, ??014B, ??014C
 = <ax>			     5				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??014C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack
			     4			endif
 0AA9  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AAD			   *@C00B9:
			     4			endif
 0AAD  8A 04		     4			.repeat
 0AAF  88 05		     4				mov al,   [si]
 0AB1  46		     4				mov [di], al
 0AB2  47		     4				inc si
 0AB3  0A C0		   *	    or	al, al
 0AB5  75 F6		   *	    jne    @C00B9
			     4				inc di
 0AB7  4E		     4			.until (al == 0)
 0AB8  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??014E eq 0
 = 			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)
			     6				regStack substr regStack, (??014E + 1)
			     6			endif
			     5			exitm ??014F
			     5		%	for ??014D, __popRegs(regStack) 
			     5				pop ??014D
 0AB9  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0ABA  C3			
 0ABB				
				;====================================================================
 0ABB				; Reading Functions
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0ABB  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
 0ABF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0152 catstr <ax>, ??0151, ??0152
 = <ax>			     5				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0152
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack
			     4			endif
 0AC0  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AC4			   *@C00BB:
			     4			endif
 0AC4  8A 04		     4			.repeat
 0AC6  88 05		     4				mov al,   [si]
 0AC8  46		     4				mov [di], al
 0AC9  47		     4				inc si
 0ACA  0A C0		   *	    or	al, al
 0ACC  75 F6		   *	    jne    @C00BB
			     4				inc di
 0ACE  4E		     4			.until (al == 0)
 0ACF  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0154 eq 0
 = 			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)
			     6				regStack substr regStack, (??0154 + 1)
			     6			endif
			     5			exitm ??0155
			     5		%	for ??0153, __popRegs(regStack) 
			     5				pop ??0153
 0AD0  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0AD1  C6 05 20		     5			endm
 0AD4  47		     5				mov byte ptr [di], ' '
 0AD5  C6 05 4C		     5				inc di
 0AD8  47		     5				mov byte ptr [di], 'L'
 0AD9  C6 05 49		     5				inc di
 0ADC  47		     5				mov byte ptr [di], 'I'
 0ADD  C6 05 4E		     5				inc di
 0AE0  47		     5				mov byte ptr [di], 'N'
 0AE1  C6 05 48		     5				inc di
 0AE4  47		     5				mov byte ptr [di], 'H'
 0AE5  C6 05 41		     5				inc di
 0AE8  47		     5				mov byte ptr [di], 'A'
 0AE9  C6 05 20		     5				inc di
 0AEC  47		     5				mov byte ptr [di], ' '
 0AED  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
 0AF0  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0158 catstr <ax>, ??0157, ??0158
 = <ax>			     5				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0158
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack
			     4			endif
 0AF1  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AF5			   *@C00BD:
			     4			endif
 0AF5  8A 04		     4			.repeat
 0AF7  88 05		     4				mov al,   [si]
 0AF9  46		     4				mov [di], al
 0AFA  47		     4				inc si
 0AFB  0A C0		   *	    or	al, al
 0AFD  75 F6		   *	    jne    @C00BD
			     4				inc di
 0AFF  4E		     4			.until (al == 0)
 0B00  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??015A eq 0
 = 			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)
			     6				regStack substr regStack, (??015A + 1)
			     6			endif
			     5			exitm ??015B
			     5		%	for ??0159, __popRegs(regStack) 
			     5				pop ??0159
 0B01  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
 0B02  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??015E catstr <ax>, ??015D, ??015E
 = <ax>			     5				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??015E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack
			     4			endif
 0B03  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B07			   *@C00BF:
			     4			endif
 0B07  8A 04		     4			.repeat
 0B09  88 05		     4				mov al,   [si]
 0B0B  46		     4				mov [di], al
 0B0C  47		     4				inc si
 0B0D  0A C0		   *	    or	al, al
 0B0F  75 F6		   *	    jne    @C00BF
			     4				inc di
 0B11  4E		     4			.until (al == 0)
 0B12  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0160 eq 0
 = 			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)
			     6				regStack substr regStack, (??0160 + 1)
			     6			endif
			     5			exitm ??0161
			     5		%	for ??015F, __popRegs(regStack) 
			     5				pop ??015F
 0B13  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
 0B14  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0164 catstr <ax>, ??0163, ??0164
 = <ax>			     5				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0164
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack
			     4			endif
 0B15  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B19			   *@C00C1:
			     4			endif
 0B19  8A 04		     4			.repeat
 0B1B  88 05		     4				mov al,   [si]
 0B1D  46		     4				mov [di], al
 0B1E  47		     4				inc si
 0B1F  0A C0		   *	    or	al, al
 0B21  75 F6		   *	    jne    @C00C1
			     4				inc di
 0B23  4E		     4			.until (al == 0)
 0B24  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0166 eq 0
 = 			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)
			     6				regStack substr regStack, (??0166 + 1)
			     6			endif
			     5			exitm ??0167
			     5		%	for ??0165, __popRegs(regStack) 
			     5				pop ??0165
 0B25  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0B26  C3				HandleCR macro
 0B27						invoke PeekChar		mov    bh, PeekBuffer		.if    bh != LF			jmp ErrorUnexpectedChar		.endif	endm
					
 0B27					ReadEmptyLines proc near uses RegsInvokeUses
						invoke ReadChar
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_DST !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0B27  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
 0B2B  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??016A catstr <ax>, ??0169, ??016A
 = <ax>			     5				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??016A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack
			     4			endif
 0B2C  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B30			   *@C00C3:
			     4			endif
 0B30  8A 04		     4			.repeat
 0B32  88 05		     4				mov al,   [si]
 0B34  46		     4				mov [di], al
 0B35  47		     4				inc si
 0B36  0A C0		   *	    or	al, al
 0B38  75 F6		   *	    jne    @C00C3
			     4				inc di
 0B3A  4E		     4			.until (al == 0)
 0B3B  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??016C eq 0
 = 			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)
			     6				regStack substr regStack, (??016C + 1)
			     6			endif
			     5			exitm ??016D
			     5		%	for ??016B, __popRegs(regStack) 
			     5				pop ??016B
 0B3C  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0B3D  C6 05 20		     5			endm
 0B40  47		     5				mov byte ptr [di], ' '
 0B41  C6 05 4C		     5				inc di
 0B44  47		     5				mov byte ptr [di], 'L'
 0B45  C6 05 49		     5				inc di
 0B48  47		     5				mov byte ptr [di], 'I'
 0B49  C6 05 4E		     5				inc di
 0B4C  47		     5				mov byte ptr [di], 'N'
 0B4D  C6 05 48		     5				inc di
 0B50  47		     5				mov byte ptr [di], 'H'
 0B51  C6 05 41		     5				inc di
 0B54  47		     5				mov byte ptr [di], 'A'
 0B55  C6 05 5F		     5				inc di
 0B58  47		     5				mov byte ptr [di], '_'
 0B59  C6 05 44		     5				inc di
 0B5C  47		     5				mov byte ptr [di], 'D'
 0B5D  C6 05 53		     5				inc di
 0B60  47		     5				mov byte ptr [di], 'S'
 0B61  C6 05 54		     5				inc di
 0B64  47		     5				mov byte ptr [di], 'T'
 0B65  C6 05 20		     5				inc di
 0B68  47		     5				mov byte ptr [di], ' '
 0B69  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
 0B6C  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0170 catstr <ax>, ??016F, ??0170
 = <ax>			     5				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0170
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack
			     4			endif
 0B6D  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B71			   *@C00C5:
			     4			endif
 0B71  8A 04		     4			.repeat
 0B73  88 05		     4				mov al,   [si]
 0B75  46		     4				mov [di], al
 0B76  47		     4				inc si
 0B77  0A C0		   *	    or	al, al
 0B79  75 F6		   *	    jne    @C00C5
			     4				inc di
 0B7B  4E		     4			.until (al == 0)
 0B7C  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0172 eq 0
 = 			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)
			     6				regStack substr regStack, (??0172 + 1)
			     6			endif
			     5			exitm ??0173
			     5		%	for ??0171, __popRegs(regStack) 
			     5				pop ??0171
 0B7D  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
 0B7E  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0176 catstr <ax>, ??0175, ??0176
 = <ax>			     5				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0176
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack
			     4			endif
 0B7F  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B83			   *@C00C7:
			     4			endif
 0B83  8A 04		     4			.repeat
 0B85  88 05		     4				mov al,   [si]
 0B87  46		     4				mov [di], al
 0B88  47		     4				inc si
 0B89  0A C0		   *	    or	al, al
 0B8B  75 F6		   *	    jne    @C00C7
			     4				inc di
 0B8D  4E		     4			.until (al == 0)
 0B8E  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0178 eq 0
 = 			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)
			     6				regStack substr regStack, (??0178 + 1)
			     6			endif
			     5			exitm ??0179
			     5		%	for ??0177, __popRegs(regStack) 
			     5				pop ??0177
 0B8F  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
 0B90  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??017C catstr <ax>, ??017B, ??017C
 = <ax>			     5				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??017C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack
			     4			endif
 0B91  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B95			   *@C00C9:
			     4			endif
 0B95  8A 04		     4			.repeat
 0B97  88 05		     4				mov al,   [si]
 0B99  46		     4				mov [di], al
 0B9A  47		     4				inc si
 0B9B  0A C0		   *	    or	al, al
 0B9D  75 F6		   *	    jne    @C00C9
			     4				inc di
 0B9F  4E		     4			.until (al == 0)
 0BA0  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??017E eq 0
 = 			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)
			     6				regStack substr regStack, (??017E + 1)
			     6			endif
			     5			exitm ??017F
			     5		%	for ??017D, __popRegs(regStack) 
			     5				pop ??017D
 0BA1  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0BA2  C3					.while ax != 0
 0BA3							mov bl, FileBuffer
				
 0BA3							.if bl == LF
								inc FileLine
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_ORG !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0BA3  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
 0BA7  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0182 catstr <ax>, ??0181, ??0182
 = <ax>			     5				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0182
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack
			     4			endif
 0BA8  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BAC			   *@C00CB:
			     4			endif
 0BAC  8A 04		     4			.repeat
 0BAE  88 05		     4				mov al,   [si]
 0BB0  46		     4				mov [di], al
 0BB1  47		     4				inc si
 0BB2  0A C0		   *	    or	al, al
 0BB4  75 F6		   *	    jne    @C00CB
			     4				inc di
 0BB6  4E		     4			.until (al == 0)
 0BB7  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0184 eq 0
 = 			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)
			     6				regStack substr regStack, (??0184 + 1)
			     6			endif
			     5			exitm ??0185
			     5		%	for ??0183, __popRegs(regStack) 
			     5				pop ??0183
 0BB8  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0BB9  C6 05 20		     5			endm
 0BBC  47		     5				mov byte ptr [di], ' '
 0BBD  C6 05 4C		     5				inc di
 0BC0  47		     5				mov byte ptr [di], 'L'
 0BC1  C6 05 49		     5				inc di
 0BC4  47		     5				mov byte ptr [di], 'I'
 0BC5  C6 05 4E		     5				inc di
 0BC8  47		     5				mov byte ptr [di], 'N'
 0BC9  C6 05 48		     5				inc di
 0BCC  47		     5				mov byte ptr [di], 'H'
 0BCD  C6 05 41		     5				inc di
 0BD0  47		     5				mov byte ptr [di], 'A'
 0BD1  C6 05 5F		     5				inc di
 0BD4  47		     5				mov byte ptr [di], '_'
 0BD5  C6 05 4F		     5				inc di
 0BD8  47		     5				mov byte ptr [di], 'O'
 0BD9  C6 05 52		     5				inc di
 0BDC  47		     5				mov byte ptr [di], 'R'
 0BDD  C6 05 47		     5				inc di
 0BE0  47		     5				mov byte ptr [di], 'G'
 0BE1  C6 05 20		     5				inc di
 0BE4  47		     5				mov byte ptr [di], ' '
 0BE5  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
 0BE8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0188 catstr <ax>, ??0187, ??0188
 = <ax>			     5				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0188
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStack
			     4			endif
 0BE9  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BED			   *@C00CD:
			     4			endif
 0BED  8A 04		     4			.repeat
 0BEF  88 05		     4				mov al,   [si]
 0BF1  46		     4				mov [di], al
 0BF2  47		     4				inc si
 0BF3  0A C0		   *	    or	al, al
 0BF5  75 F6		   *	    jne    @C00CD
			     4				inc di
 0BF7  4E		     4			.until (al == 0)
 0BF8  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??018A eq 0
 = 			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)
			     6				regStack substr regStack, (??018A + 1)
			     6			endif
			     5			exitm ??018B
			     5		%	for ??0189, __popRegs(regStack) 
			     5				pop ??0189
 0BF9  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??018D     textequ <>
			     5			??018E textequ <>
			     5			for       ??018C, <ax>
			     5				push  ??018C
			     5				??018E catstr <??018C>, ??018D, ??018E
			     5				??018D catstr <, >
 0BFA  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??018E catstr <ax>, ??018D, ??018E
 = <ax>			     5				??018D catstr <, >
			     5			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??018E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??018E
			     6			else
			     6				regStack catstr ??018E, REG_SET_DELIMITER, regStack
			     4			endif
 0BFB  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BFF			   *@C00CF:
			     4			endif
 0BFF  8A 04		     4			.repeat
 0C01  88 05		     4				mov al,   [si]
 0C03  46		     4				mov [di], al
 0C04  47		     4				inc si
 0C05  0A C0		   *	    or	al, al
 0C07  75 F6		   *	    jne    @C00CF
			     4				inc di
 0C09  4E		     4			.until (al == 0)
 0C0A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0190 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0190 eq 0
 = 			     6				??0191     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0191 substr regStack, 1, (??0190 - 1)
			     6				regStack substr regStack, (??0190 + 1)
			     6			endif
			     5			exitm ??0191
			     5		%	for ??018F, __popRegs(regStack) 
			     5				pop ??018F
 0C0B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0193     textequ <>
			     5			??0194 textequ <>
			     5			for       ??0192, <ax>
			     5				push  ??0192
			     5				??0194 catstr <??0192>, ??0193, ??0194
			     5				??0193 catstr <, >
 0C0C  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0194 catstr <ax>, ??0193, ??0194
 = <ax>			     5				??0193 catstr <, >
			     5			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0194
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0194
			     6			else
			     6				regStack catstr ??0194, REG_SET_DELIMITER, regStack
			     4			endif
 0C0D  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0C11			   *@C00D1:
			     4			endif
 0C11  8A 04		     4			.repeat
 0C13  88 05		     4				mov al,   [si]
 0C15  46		     4				mov [di], al
 0C16  47		     4				inc si
 0C17  0A C0		   *	    or	al, al
 0C19  75 F6		   *	    jne    @C00D1
			     4				inc di
 0C1B  4E		     4			.until (al == 0)
 0C1C  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0196 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0196 eq 0
 = 			     6				??0197     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0197 substr regStack, 1, (??0196 - 1)
			     6				regStack substr regStack, (??0196 + 1)
			     6			endif
			     5			exitm ??0197
			     5		%	for ??0195, __popRegs(regStack) 
			     5				pop ??0195
 0C1D  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0C1E  C3							mov FileCol, 1
 0C1F							.elseif bl == CR
								HandleCR
							.else
								jmp ErrorUnexpectedChar
							.endif
				
 0C1F							invoke ReadChar
						.endw
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??0199     textequ <>
 = 			     2			??019A textequ <>
			     2			for       ??0198, <ax,dx>
			     2				push  ??0198
			     2				??019A catstr <??0198>, ??0199, ??019A
			     2				??0199 catstr <, >
			     2			endm
 0C1F  50		     3				push  ax
 = ax			     3				??019A catstr <ax>, ??0199, ??019A
 = , 			     3				??0199 catstr <, >
 0C20  52		     3				push  dx
 = dx, ax		     3				??019A catstr <dx>, ??0199, ??019A
 = , 			     3				??0199 catstr <, >
 = <dx, ax>		     2			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     2			__pushRegs ??019A
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??019A
			     3			else
			     3				regStack catstr ??019A, REG_SET_DELIMITER, regStack
			     3			endif
 0C21  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C23  B2 45		     2				mov dl, 'E'
 0C25  CD 21		     2				int 21h
 0C27  B2 72		     2				mov dl, 'r'
 0C29  CD 21		     2				int 21h
 0C2B  B2 72		     2				mov dl, 'r'
 0C2D  CD 21		     2				int 21h
 0C2F  B2 6F		     2				mov dl, 'o'
 0C31  CD 21		     2				int 21h
 0C33  B2 20		     2				mov dl, ' '
 0C35  CD 21		     2				int 21h
 0C37  B2 6E		     2				mov dl, 'n'
 0C39  CD 21		     2				int 21h
 0C3B  B2 61		     2				mov dl, 'a'
 0C3D  CD 21		     2				int 21h
 0C3F  B2 20		     2				mov dl, ' '
 0C41  CD 21		     2				int 21h
 0C43  B2 61		     2				mov dl, 'a'
 0C45  CD 21		     2				int 21h
 0C47  B2 62		     2				mov dl, 'b'
 0C49  CD 21		     2				int 21h
 0C4B  B2 65		     2				mov dl, 'e'
 0C4D  CD 21		     2				int 21h
 0C4F  B2 72		     2				mov dl, 'r'
 0C51  CD 21		     2				int 21h
 0C53  B2 74		     2				mov dl, 't'
 0C55  CD 21		     2				int 21h
 0C57  B2 75		     2				mov dl, 'u'
 0C59  CD 21		     2				int 21h
 0C5B  B2 72		     2				mov dl, 'r'
 0C5D  CD 21		     2				int 21h
 0C5F  B2 61		     2				mov dl, 'a'
 0C61  CD 21		     2				int 21h
 0C63  B2 20		     2				mov dl, ' '
 0C65  CD 21		     2				int 21h
 0C67  B2 64		     2				mov dl, 'd'
 0C69  CD 21		     2				int 21h
 0C6B  B2 6F		     2				mov dl, 'o'
 0C6D  CD 21		     2				int 21h
 0C6F  B2 20		     2				mov dl, ' '
 0C71  CD 21		     2				int 21h
 0C73  B2 61		     2				mov dl, 'a'
 0C75  CD 21		     2				int 21h
 0C77  B2 72		     2				mov dl, 'r'
 0C79  CD 21		     2				int 21h
 0C7B  B2 71		     2				mov dl, 'q'
 0C7D  CD 21		     2				int 21h
 0C7F  B2 75		     2				mov dl, 'u'
 0C81  CD 21		     2				int 21h
 0C83  B2 69		     2				mov dl, 'i'
 0C85  CD 21		     2				int 21h
 0C87  B2 76		     2				mov dl, 'v'
 0C89  CD 21		     2				int 21h
 0C8B  B2 6F		     2				mov dl, 'o'
 0C8D  CD 21		     2				int 21h
 0C8F  B2 2E		     2				mov dl, '.'
 0C91  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??019C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??019C eq 0
 = <dx, ax>		     3				??019D     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??019D substr regStack, 1, (??019C - 1)
			     3				regStack substr regStack, (??019C + 1)
			     3			endif
			     3			exitm ??019D
			     2		%	for ??019B, __popRegs(regStack) 
			     2				pop ??019B
			     2			endm
 0C93  5A		     3				pop dx
 0C94  58		     3				pop ax
 0C95  E9 F6C3					ret
					ReadEmptyLines endp
 0C98				
					OpenFile proc near
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??019F     textequ <>
 = 			     2			??01A0 textequ <>
			     2			for       ??019E, <ax,dx>
			     2				push  ??019E
			     2				??01A0 catstr <??019E>, ??019F, ??01A0
			     2				??019F catstr <, >
			     2			endm
 0C98  50		     3				push  ax
 = ax			     3				??01A0 catstr <ax>, ??019F, ??01A0
 = , 			     3				??019F catstr <, >
 0C99  52		     3				push  dx
 = dx, ax		     3				??01A0 catstr <dx>, ??019F, ??01A0
 = , 			     3				??019F catstr <, >
 = <dx, ax>		     2			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     2			__pushRegs ??01A0
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01A0
			     3			else
			     3				regStack catstr ??01A0, REG_SET_DELIMITER, regStack
			     3			endif
 0C9A  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C9C  B2 45		     2				mov dl, 'E'
 0C9E  CD 21		     2				int 21h
 0CA0  B2 72		     2				mov dl, 'r'
 0CA2  CD 21		     2				int 21h
 0CA4  B2 72		     2				mov dl, 'r'
 0CA6  CD 21		     2				int 21h
 0CA8  B2 6F		     2				mov dl, 'o'
 0CAA  CD 21		     2				int 21h
 0CAC  B2 20		     2				mov dl, ' '
 0CAE  CD 21		     2				int 21h
 0CB0  B2 6E		     2				mov dl, 'n'
 0CB2  CD 21		     2				int 21h
 0CB4  B2 61		     2				mov dl, 'a'
 0CB6  CD 21		     2				int 21h
 0CB8  B2 20		     2				mov dl, ' '
 0CBA  CD 21		     2				int 21h
 0CBC  B2 6C		     2				mov dl, 'l'
 0CBE  CD 21		     2				int 21h
 0CC0  B2 65		     2				mov dl, 'e'
 0CC2  CD 21		     2				int 21h
 0CC4  B2 69		     2				mov dl, 'i'
 0CC6  CD 21		     2				int 21h
 0CC8  B2 74		     2				mov dl, 't'
 0CCA  CD 21		     2				int 21h
 0CCC  B2 75		     2				mov dl, 'u'
 0CCE  CD 21		     2				int 21h
 0CD0  B2 72		     2				mov dl, 'r'
 0CD2  CD 21		     2				int 21h
 0CD4  B2 61		     2				mov dl, 'a'
 0CD6  CD 21		     2				int 21h
 0CD8  B2 20		     2				mov dl, ' '
 0CDA  CD 21		     2				int 21h
 0CDC  B2 64		     2				mov dl, 'd'
 0CDE  CD 21		     2				int 21h
 0CE0  B2 6F		     2				mov dl, 'o'
 0CE2  CD 21		     2				int 21h
 0CE4  B2 20		     2				mov dl, ' '
 0CE6  CD 21		     2				int 21h
 0CE8  B2 61		     2				mov dl, 'a'
 0CEA  CD 21		     2				int 21h
 0CEC  B2 72		     2				mov dl, 'r'
 0CEE  CD 21		     2				int 21h
 0CF0  B2 71		     2				mov dl, 'q'
 0CF2  CD 21		     2				int 21h
 0CF4  B2 75		     2				mov dl, 'u'
 0CF6  CD 21		     2				int 21h
 0CF8  B2 69		     2				mov dl, 'i'
 0CFA  CD 21		     2				int 21h
 0CFC  B2 76		     2				mov dl, 'v'
 0CFE  CD 21		     2				int 21h
 0D00  B2 6F		     2				mov dl, 'o'
 0D02  CD 21		     2				int 21h
 0D04  B2 2E		     2				mov dl, '.'
 0D06  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01A2 eq 0
 = <dx, ax>		     3				??01A3     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01A3 substr regStack, 1, (??01A2 - 1)
			     3				regStack substr regStack, (??01A2 + 1)
			     3			endif
			     3			exitm ??01A3
			     2		%	for ??01A1, __popRegs(regStack) 
			     2				pop ??01A1
			     2			endm
 0D08  5A		     3				pop dx
 0D09  58		     3				pop ax
 0D0A  E9 F64E					SaveRegs ax,         dx
						mov      al,         0
 0D0D						lea      dx,         FileName
						mov      ah,         3dh
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01A5     textequ <>
 = 			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
 0D0D  50		     5				push  ax
 = ax			     5				??01A6 catstr <ax>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 0D0E  52		     5				push  dx
 = dx, ax		     5				??01A6 catstr <dx>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 = <dx, ax>		     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack
			     5			endif
 0D0F  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D11  B2 28		     4				mov dl, '('
 0D13  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
 = <dx, ax>		     5				??01A9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)
			     5				regStack substr regStack, (??01A8 + 1)
			     5			endif
			     5			exitm ??01A9
			     4		%	for ??01A7, __popRegs(regStack) 
			     4				pop ??01A7
			     4			endm
 0D15  5A		     5				pop dx
 0D16  58		     5				pop ax
 0D17  FF 36 03C1 R	   *	    push   FileLine
 0D1B  E8 079F		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01AB     textequ <>
 = 			     4			??01AC textequ <>
			     4			for       ??01AA, <ax,dx>
			     4				push  ??01AA
			     4				??01AC catstr <??01AA>, ??01AB, ??01AC
			     4				??01AB catstr <, >
			     4			endm
 0D1E  50		     5				push  ax
 = ax			     5				??01AC catstr <ax>, ??01AB, ??01AC
 = , 			     5				??01AB catstr <, >
 0D1F  52		     5				push  dx
 = dx, ax		     5				??01AC catstr <dx>, ??01AB, ??01AC
 = , 			     5				??01AB catstr <, >
 = <dx, ax>		     4			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     4			__pushRegs ??01AC
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01AC
			     5			else
			     5				regStack catstr ??01AC, REG_SET_DELIMITER, regStack
			     5			endif
 0D20  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D22  B2 3A		     4				mov dl, ':'
 0D24  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01AE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01AE eq 0
 = <dx, ax>		     5				??01AF     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01AF substr regStack, 1, (??01AE - 1)
			     5				regStack substr regStack, (??01AE + 1)
			     5			endif
			     5			exitm ??01AF
			     4		%	for ??01AD, __popRegs(regStack) 
			     4				pop ??01AD
			     4			endm
 0D26  5A		     5				pop dx
 0D27  58		     5				pop ax
 0D28  FF 36 03BF R	   *	    push   FileCol
 0D2C  E8 078E		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01B1     textequ <>
 = 			     4			??01B2 textequ <>
			     4			for       ??01B0, <ax,dx>
			     4				push  ??01B0
			     4				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     4				??01B1 catstr <, >
			     4			endm
 0D2F  50		     5				push  ax
 = ax			     5				??01B2 catstr <ax>, ??01B1, ??01B2
 = , 			     5				??01B1 catstr <, >
 0D30  52		     5				push  dx
 = dx, ax		     5				??01B2 catstr <dx>, ??01B1, ??01B2
 = , 			     5				??01B1 catstr <, >
 = <dx, ax>		     4			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     4			__pushRegs ??01B2
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01B2
			     5			else
			     5				regStack catstr ??01B2, REG_SET_DELIMITER, regStack
			     5			endif
 0D31  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D33  B2 29		     4				mov dl, ')'
 0D35  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01B4 eq 0
 = <dx, ax>		     5				??01B5     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01B5 substr regStack, 1, (??01B4 - 1)
			     5				regStack substr regStack, (??01B4 + 1)
			     5			endif
			     5			exitm ??01B5
			     4		%	for ??01B3, __popRegs(regStack) 
			     4				pop ??01B3
			     4			endm
 0D37  5A		     5				pop dx
 0D38  58		     5				pop ax
						int      21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01B7     textequ <>
 = 			     2			??01B8 textequ <>
			     2			for       ??01B6, <ax,dx>
			     2				push  ??01B6
			     2				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     2				??01B7 catstr <, >
			     2			endm
 0D39  50		     3				push  ax
 = ax			     3				??01B8 catstr <ax>, ??01B7, ??01B8
 = , 			     3				??01B7 catstr <, >
 0D3A  52		     3				push  dx
 = dx, ax		     3				??01B8 catstr <dx>, ??01B7, ??01B8
 = , 			     3				??01B7 catstr <, >
 = <dx, ax>		     2			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     2			__pushRegs ??01B8
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01B8
			     3			else
			     3				regStack catstr ??01B8, REG_SET_DELIMITER, regStack
			     3			endif
 0D3B  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0D3D  B2 20		     2				mov dl, ' '
 0D3F  CD 21		     2				int 21h
 0D41  B2 45		     2				mov dl, 'E'
 0D43  CD 21		     2				int 21h
 0D45  B2 72		     2				mov dl, 'r'
 0D47  CD 21		     2				int 21h
 0D49  B2 72		     2				mov dl, 'r'
 0D4B  CD 21		     2				int 21h
 0D4D  B2 6F		     2				mov dl, 'o'
 0D4F  CD 21		     2				int 21h
 0D51  B2 3A		     2				mov dl, ':'
 0D53  CD 21		     2				int 21h
 0D55  B2 20		     2				mov dl, ' '
 0D57  CD 21		     2				int 21h
 0D59  B2 61		     2				mov dl, 'a'
 0D5B  CD 21		     2				int 21h
 0D5D  B2 20		     2				mov dl, ' '
 0D5F  CD 21		     2				int 21h
 0D61  B2 71		     2				mov dl, 'q'
 0D63  CD 21		     2				int 21h
 0D65  B2 75		     2				mov dl, 'u'
 0D67  CD 21		     2				int 21h
 0D69  B2 61		     2				mov dl, 'a'
 0D6B  CD 21		     2				int 21h
 0D6D  B2 6E		     2				mov dl, 'n'
 0D6F  CD 21		     2				int 21h
 0D71  B2 74		     2				mov dl, 't'
 0D73  CD 21		     2				int 21h
 0D75  B2 69		     2				mov dl, 'i'
 0D77  CD 21		     2				int 21h
 0D79  B2 64		     2				mov dl, 'd'
 0D7B  CD 21		     2				int 21h
 0D7D  B2 61		     2				mov dl, 'a'
 0D7F  CD 21		     2				int 21h
 0D81  B2 64		     2				mov dl, 'd'
 0D83  CD 21		     2				int 21h
 0D85  B2 65		     2				mov dl, 'e'
 0D87  CD 21		     2				int 21h
 0D89  B2 20		     2				mov dl, ' '
 0D8B  CD 21		     2				int 21h
 0D8D  B2 64		     2				mov dl, 'd'
 0D8F  CD 21		     2				int 21h
 0D91  B2 65		     2				mov dl, 'e'
 0D93  CD 21		     2				int 21h
 0D95  B2 20		     2				mov dl, ' '
 0D97  CD 21		     2				int 21h
 0D99  B2 63		     2				mov dl, 'c'
 0D9B  CD 21		     2				int 21h
 0D9D  B2 6F		     2				mov dl, 'o'
 0D9F  CD 21		     2				int 21h
 0DA1  B2 6C		     2				mov dl, 'l'
 0DA3  CD 21		     2				int 21h
 0DA5  B2 75		     2				mov dl, 'u'
 0DA7  CD 21		     2				int 21h
 0DA9  B2 6E		     2				mov dl, 'n'
 0DAB  CD 21		     2				int 21h
 0DAD  B2 61		     2				mov dl, 'a'
 0DAF  CD 21		     2				int 21h
 0DB1  B2 73		     2				mov dl, 's'
 0DB3  CD 21		     2				int 21h
 0DB5  B2 20		     2				mov dl, ' '
 0DB7  CD 21		     2				int 21h
 0DB9  B2 64		     2				mov dl, 'd'
 0DBB  CD 21		     2				int 21h
 0DBD  B2 65		     2				mov dl, 'e'
 0DBF  CD 21		     2				int 21h
 0DC1  B2 76		     2				mov dl, 'v'
 0DC3  CD 21		     2				int 21h
 0DC5  B2 65		     2				mov dl, 'e'
 0DC7  CD 21		     2				int 21h
 0DC9  B2 20		     2				mov dl, ' '
 0DCB  CD 21		     2				int 21h
 0DCD  B2 73		     2				mov dl, 's'
 0DCF  CD 21		     2				int 21h
 0DD1  B2 65		     2				mov dl, 'e'
 0DD3  CD 21		     2				int 21h
 0DD5  B2 72		     2				mov dl, 'r'
 0DD7  CD 21		     2				int 21h
 0DD9  B2 20		     2				mov dl, ' '
 0DDB  CD 21		     2				int 21h
 0DDD  B2 69		     2				mov dl, 'i'
 0DDF  CD 21		     2				int 21h
 0DE1  B2 67		     2				mov dl, 'g'
 0DE3  CD 21		     2				int 21h
 0DE5  B2 75		     2				mov dl, 'u'
 0DE7  CD 21		     2				int 21h
 0DE9  B2 61		     2				mov dl, 'a'
 0DEB  CD 21		     2				int 21h
 0DED  B2 6C		     2				mov dl, 'l'
 0DEF  CD 21		     2				int 21h
 0DF1  B2 20		     2				mov dl, ' '
 0DF3  CD 21		     2				int 21h
 0DF5  B2 65		     2				mov dl, 'e'
 0DF7  CD 21		     2				int 21h
 0DF9  B2 6D		     2				mov dl, 'm'
 0DFB  CD 21		     2				int 21h
 0DFD  B2 20		     2				mov dl, ' '
 0DFF  CD 21		     2				int 21h
 0E01  B2 74		     2				mov dl, 't'
 0E03  CD 21		     2				int 21h
 0E05  B2 6F		     2				mov dl, 'o'
 0E07  CD 21		     2				int 21h
 0E09  B2 64		     2				mov dl, 'd'
 0E0B  CD 21		     2				int 21h
 0E0D  B2 61		     2				mov dl, 'a'
 0E0F  CD 21		     2				int 21h
 0E11  B2 73		     2				mov dl, 's'
 0E13  CD 21		     2				int 21h
 0E15  B2 20		     2				mov dl, ' '
 0E17  CD 21		     2				int 21h
 0E19  B2 61		     2				mov dl, 'a'
 0E1B  CD 21		     2				int 21h
 0E1D  B2 73		     2				mov dl, 's'
 0E1F  CD 21		     2				int 21h
 0E21  B2 20		     2				mov dl, ' '
 0E23  CD 21		     2				int 21h
 0E25  B2 6C		     2				mov dl, 'l'
 0E27  CD 21		     2				int 21h
 0E29  B2 69		     2				mov dl, 'i'
 0E2B  CD 21		     2				int 21h
 0E2D  B2 6E		     2				mov dl, 'n'
 0E2F  CD 21		     2				int 21h
 0E31  B2 68		     2				mov dl, 'h'
 0E33  CD 21		     2				int 21h
 0E35  B2 61		     2				mov dl, 'a'
 0E37  CD 21		     2				int 21h
 0E39  B2 73		     2				mov dl, 's'
 0E3B  CD 21		     2				int 21h
 0E3D  B2 2E		     2				mov dl, '.'
 0E3F  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01BA instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01BA eq 0
 = <dx, ax>		     3				??01BB     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01BB substr regStack, 1, (??01BA - 1)
			     3				regStack substr regStack, (??01BA + 1)
			     3			endif
			     3			exitm ??01BB
			     2		%	for ??01B9, __popRegs(regStack) 
			     2				pop ??01B9
			     2			endm
 0E41  5A		     3				pop dx
 0E42  58		     3				pop ax
 0E43  E9 F515					.if (carry?)
							call ErrorOpen
 0E46						.endif
						mov      FileHandle, ax
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01BD     textequ <>
 = 			     2			??01BE textequ <>
			     2			for       ??01BC, <ax,dx>
			     2				push  ??01BC
			     2				??01BE catstr <??01BC>, ??01BD, ??01BE
			     2				??01BD catstr <, >
			     2			endm
 0E46  50		     3				push  ax
 = ax			     3				??01BE catstr <ax>, ??01BD, ??01BE
 = , 			     3				??01BD catstr <, >
 0E47  52		     3				push  dx
 = dx, ax		     3				??01BE catstr <dx>, ??01BD, ??01BE
 = , 			     3				??01BD catstr <, >
 = <dx, ax>		     2			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     2			__pushRegs ??01BE
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01BE
			     3			else
			     3				regStack catstr ??01BE, REG_SET_DELIMITER, regStack
			     3			endif
 0E48  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0E4A  B2 45		     2				mov dl, 'E'
 0E4C  CD 21		     2				int 21h
 0E4E  B2 72		     2				mov dl, 'r'
 0E50  CD 21		     2				int 21h
 0E52  B2 72		     2				mov dl, 'r'
 0E54  CD 21		     2				int 21h
 0E56  B2 6F		     2				mov dl, 'o'
 0E58  CD 21		     2				int 21h
 0E5A  B2 3A		     2				mov dl, ':'
 0E5C  CD 21		     2				int 21h
 0E5E  B2 20		     2				mov dl, ' '
 0E60  CD 21		     2				int 21h
 0E62  B2 61		     2				mov dl, 'a'
 0E64  CD 21		     2				int 21h
 0E66  B2 20		     2				mov dl, ' '
 0E68  CD 21		     2				int 21h
 0E6A  B2 71		     2				mov dl, 'q'
 0E6C  CD 21		     2				int 21h
 0E6E  B2 75		     2				mov dl, 'u'
 0E70  CD 21		     2				int 21h
 0E72  B2 61		     2				mov dl, 'a'
 0E74  CD 21		     2				int 21h
 0E76  B2 6E		     2				mov dl, 'n'
 0E78  CD 21		     2				int 21h
 0E7A  B2 74		     2				mov dl, 't'
 0E7C  CD 21		     2				int 21h
 0E7E  B2 69		     2				mov dl, 'i'
 0E80  CD 21		     2				int 21h
 0E82  B2 64		     2				mov dl, 'd'
 0E84  CD 21		     2				int 21h
 0E86  B2 61		     2				mov dl, 'a'
 0E88  CD 21		     2				int 21h
 0E8A  B2 64		     2				mov dl, 'd'
 0E8C  CD 21		     2				int 21h
 0E8E  B2 65		     2				mov dl, 'e'
 0E90  CD 21		     2				int 21h
 0E92  B2 20		     2				mov dl, ' '
 0E94  CD 21		     2				int 21h
 0E96  B2 64		     2				mov dl, 'd'
 0E98  CD 21		     2				int 21h
 0E9A  B2 65		     2				mov dl, 'e'
 0E9C  CD 21		     2				int 21h
 0E9E  B2 20		     2				mov dl, ' '
 0EA0  CD 21		     2				int 21h
 0EA2  B2 6C		     2				mov dl, 'l'
 0EA4  CD 21		     2				int 21h
 0EA6  B2 69		     2				mov dl, 'i'
 0EA8  CD 21		     2				int 21h
 0EAA  B2 6E		     2				mov dl, 'n'
 0EAC  CD 21		     2				int 21h
 0EAE  B2 68		     2				mov dl, 'h'
 0EB0  CD 21		     2				int 21h
 0EB2  B2 61		     2				mov dl, 'a'
 0EB4  CD 21		     2				int 21h
 0EB6  B2 73		     2				mov dl, 's'
 0EB8  CD 21		     2				int 21h
 0EBA  B2 20		     2				mov dl, ' '
 0EBC  CD 21		     2				int 21h
 0EBE  B2 64		     2				mov dl, 'd'
 0EC0  CD 21		     2				int 21h
 0EC2  B2 65		     2				mov dl, 'e'
 0EC4  CD 21		     2				int 21h
 0EC6  B2 76		     2				mov dl, 'v'
 0EC8  CD 21		     2				int 21h
 0ECA  B2 65		     2				mov dl, 'e'
 0ECC  CD 21		     2				int 21h
 0ECE  B2 20		     2				mov dl, ' '
 0ED0  CD 21		     2				int 21h
 0ED2  B2 73		     2				mov dl, 's'
 0ED4  CD 21		     2				int 21h
 0ED6  B2 65		     2				mov dl, 'e'
 0ED8  CD 21		     2				int 21h
 0EDA  B2 72		     2				mov dl, 'r'
 0EDC  CD 21		     2				int 21h
 0EDE  B2 20		     2				mov dl, ' '
 0EE0  CD 21		     2				int 21h
 0EE2  B2 31		     2				mov dl, '1'
 0EE4  CD 21		     2				int 21h
 0EE6  B2 20		     2				mov dl, ' '
 0EE8  CD 21		     2				int 21h
 0EEA  B2 61		     2				mov dl, 'a'
 0EEC  CD 21		     2				int 21h
 0EEE  B2 20		     2				mov dl, ' '
 0EF0  CD 21		     2				int 21h
 0EF2  B2 6D		     2				mov dl, 'm'
 0EF4  CD 21		     2				int 21h
 0EF6  B2 65		     2				mov dl, 'e'
 0EF8  CD 21		     2				int 21h
 0EFA  B2 6E		     2				mov dl, 'n'
 0EFC  CD 21		     2				int 21h
 0EFE  B2 6F		     2				mov dl, 'o'
 0F00  CD 21		     2				int 21h
 0F02  B2 73		     2				mov dl, 's'
 0F04  CD 21		     2				int 21h
 0F06  B2 20		     2				mov dl, ' '
 0F08  CD 21		     2				int 21h
 0F0A  B2 71		     2				mov dl, 'q'
 0F0C  CD 21		     2				int 21h
 0F0E  B2 75		     2				mov dl, 'u'
 0F10  CD 21		     2				int 21h
 0F12  B2 65		     2				mov dl, 'e'
 0F14  CD 21		     2				int 21h
 0F16  B2 20		     2				mov dl, ' '
 0F18  CD 21		     2				int 21h
 0F1A  B2 61		     2				mov dl, 'a'
 0F1C  CD 21		     2				int 21h
 0F1E  B2 20		     2				mov dl, ' '
 0F20  CD 21		     2				int 21h
 0F22  B2 71		     2				mov dl, 'q'
 0F24  CD 21		     2				int 21h
 0F26  B2 75		     2				mov dl, 'u'
 0F28  CD 21		     2				int 21h
 0F2A  B2 61		     2				mov dl, 'a'
 0F2C  CD 21		     2				int 21h
 0F2E  B2 6E		     2				mov dl, 'n'
 0F30  CD 21		     2				int 21h
 0F32  B2 74		     2				mov dl, 't'
 0F34  CD 21		     2				int 21h
 0F36  B2 69		     2				mov dl, 'i'
 0F38  CD 21		     2				int 21h
 0F3A  B2 64		     2				mov dl, 'd'
 0F3C  CD 21		     2				int 21h
 0F3E  B2 61		     2				mov dl, 'a'
 0F40  CD 21		     2				int 21h
 0F42  B2 64		     2				mov dl, 'd'
 0F44  CD 21		     2				int 21h
 0F46  B2 65		     2				mov dl, 'e'
 0F48  CD 21		     2				int 21h
 0F4A  B2 20		     2				mov dl, ' '
 0F4C  CD 21		     2				int 21h
 0F4E  B2 64		     2				mov dl, 'd'
 0F50  CD 21		     2				int 21h
 0F52  B2 65		     2				mov dl, 'e'
 0F54  CD 21		     2				int 21h
 0F56  B2 20		     2				mov dl, ' '
 0F58  CD 21		     2				int 21h
 0F5A  B2 63		     2				mov dl, 'c'
 0F5C  CD 21		     2				int 21h
 0F5E  B2 6F		     2				mov dl, 'o'
 0F60  CD 21		     2				int 21h
 0F62  B2 6C		     2				mov dl, 'l'
 0F64  CD 21		     2				int 21h
 0F66  B2 75		     2				mov dl, 'u'
 0F68  CD 21		     2				int 21h
 0F6A  B2 6E		     2				mov dl, 'n'
 0F6C  CD 21		     2				int 21h
 0F6E  B2 61		     2				mov dl, 'a'
 0F70  CD 21		     2				int 21h
 0F72  B2 73		     2				mov dl, 's'
 0F74  CD 21		     2				int 21h
 0F76  B2 2E		     2				mov dl, '.'
 0F78  CD 21		     2				int 21h
 0F7A  B2 20		     2				mov dl, ' '
 0F7C  CD 21		     2				int 21h
 0F7E  B2 4F		     2				mov dl, 'O'
 0F80  CD 21		     2				int 21h
 0F82  B2 20		     2				mov dl, ' '
 0F84  CD 21		     2				int 21h
 0F86  B2 65		     2				mov dl, 'e'
 0F88  CD 21		     2				int 21h
 0F8A  B2 6E		     2				mov dl, 'n'
 0F8C  CD 21		     2				int 21h
 0F8E  B2 63		     2				mov dl, 'c'
 0F90  CD 21		     2				int 21h
 0F92  B2 6F		     2				mov dl, 'o'
 0F94  CD 21		     2				int 21h
 0F96  B2 6E		     2				mov dl, 'n'
 0F98  CD 21		     2				int 21h
 0F9A  B2 74		     2				mov dl, 't'
 0F9C  CD 21		     2				int 21h
 0F9E  B2 72		     2				mov dl, 'r'
 0FA0  CD 21		     2				int 21h
 0FA2  B2 61		     2				mov dl, 'a'
 0FA4  CD 21		     2				int 21h
 0FA6  B2 64		     2				mov dl, 'd'
 0FA8  CD 21		     2				int 21h
 0FAA  B2 6F		     2				mov dl, 'o'
 0FAC  CD 21		     2				int 21h
 0FAE  B2 20		     2				mov dl, ' '
 0FB0  CD 21		     2				int 21h
 0FB2  B2 66		     2				mov dl, 'f'
 0FB4  CD 21		     2				int 21h
 0FB6  B2 6F		     2				mov dl, 'o'
 0FB8  CD 21		     2				int 21h
 0FBA  B2 69		     2				mov dl, 'i'
 0FBC  CD 21		     2				int 21h
 0FBE  B2 3A		     2				mov dl, ':'
 0FC0  CD 21		     2				int 21h
 0FC2  B2 20		     2				mov dl, ' '
 0FC4  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01C0 eq 0
 = <dx, ax>		     3				??01C1     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01C1 substr regStack, 1, (??01C0 - 1)
			     3				regStack substr regStack, (??01C0 + 1)
			     3			endif
			     3			exitm ??01C1
			     2		%	for ??01BF, __popRegs(regStack) 
			     2				pop ??01BF
			     2			endm
 0FC6  5A		     3				pop dx
 0FC7  58		     3				pop ax
						mov      FileIsOpen, 1
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C3     textequ <>
 = 			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
 0FC8  50		     5				push  ax
 = ax			     5				??01C4 catstr <ax>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 0FC9  52		     5				push  dx
 = dx, ax		     5				??01C4 catstr <dx>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 = <dx, ax>		     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack
			     5			endif
 0FCA  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FCC  B2 28		     4				mov dl, '('
 0FCE  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
 = <dx, ax>		     5				??01C7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)
			     5				regStack substr regStack, (??01C6 + 1)
			     5			endif
			     5			exitm ??01C7
			     4		%	for ??01C5, __popRegs(regStack) 
			     4				pop ??01C5
			     4			endm
 0FD0  5A		     5				pop dx
 0FD1  58		     5				pop ax
 0FD2  A0 03C5 R	   *	    mov    al, TotalRow
 0FD5  32 E4		   *	    xor    ah, ah
 0FD7  50		   *	    push   ax
 0FD8  E8 04E2		   *	    call   printf_u
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C9     textequ <>
 = 			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
 0FDB  50		     5				push  ax
 = ax			     5				??01CA catstr <ax>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 0FDC  52		     5				push  dx
 = dx, ax		     5				??01CA catstr <dx>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 = <dx, ax>		     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack
			     5			endif
 0FDD  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FDF  B2 3A		     4				mov dl, ':'
 0FE1  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
 = <dx, ax>		     5				??01CD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)
			     5				regStack substr regStack, (??01CC + 1)
			     5			endif
			     5			exitm ??01CD
			     4		%	for ??01CB, __popRegs(regStack) 
			     4				pop ??01CB
			     4			endm
 0FE3  5A		     5				pop dx
 0FE4  58		     5				pop ax
 0FE5  A0 03C6 R	   *	    mov    al, TotalCol
 0FE8  32 E4		   *	    xor    ah, ah
 0FEA  50		   *	    push   ax
 0FEB  E8 04CF		   *	    call   printf_u
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01CF     textequ <>
 = 			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
 0FEE  50		     5				push  ax
 = ax			     5				??01D0 catstr <ax>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 0FEF  52		     5				push  dx
 = dx, ax		     5				??01D0 catstr <dx>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 = <dx, ax>		     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStack
			     5			endif
 0FF0  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FF2  B2 29		     4				mov dl, ')'
 0FF4  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
 = <dx, ax>		     5				??01D3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)
			     5				regStack substr regStack, (??01D2 + 1)
			     5			endif
			     5			exitm ??01D3
			     4		%	for ??01D1, __popRegs(regStack) 
			     4				pop ??01D1
			     4			endm
 0FF6  5A		     5				pop dx
 0FF7  58		     5				pop ax
 0FF8  E9 F360					RestoreRegs
						ret
 0FFB					OpenFile endp
 0FFB  8A 1E 000D R		
 0FFF  88 1E 03BC R			ReadChar proc near uses RegsReturningOnAX
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01D5     textequ <>
 = 			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
 1003  50		     5				push  ax
 = ax			     5				??01D6 catstr <ax>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 1004  52		     5				push  dx
 = dx, ax		     5				??01D6 catstr <dx>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 = <dx, ax>		     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack
			     5			endif
 1005  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 1007  B2 28		     4				mov dl, '('
 1009  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
 = <dx, ax>		     5				??01D9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)
			     5				regStack substr regStack, (??01D8 + 1)
			     5			endif
			     5			exitm ??01D9
			     4		%	for ??01D7, __popRegs(regStack) 
			     4				pop ??01D7
			     4			endm
 100B  5A		     5				pop dx
 100C  58		     5				pop ax
 100D  FF 36 03C1 R	   *	    push   FileLine
 1011  E8 04A9		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01DB     textequ <>
 = 			     4			??01DC textequ <>
			     4			for       ??01DA, <ax,dx>
			     4				push  ??01DA
			     4				??01DC catstr <??01DA>, ??01DB, ??01DC
			     4				??01DB catstr <, >
			     4			endm
 1014  50		     5				push  ax
 = ax			     5				??01DC catstr <ax>, ??01DB, ??01DC
 = , 			     5				??01DB catstr <, >
 1015  52		     5				push  dx
 = dx, ax		     5				??01DC catstr <dx>, ??01DB, ??01DC
 = , 			     5				??01DB catstr <, >
 = <dx, ax>		     4			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     4			__pushRegs ??01DC
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01DC
			     5			else
			     5				regStack catstr ??01DC, REG_SET_DELIMITER, regStack
			     5			endif
 1016  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 1018  B2 3A		     4				mov dl, ':'
 101A  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01DE instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01DE eq 0
 = <dx, ax>		     5				??01DF     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01DF substr regStack, 1, (??01DE - 1)
			     5				regStack substr regStack, (??01DE + 1)
			     5			endif
			     5			exitm ??01DF
			     4		%	for ??01DD, __popRegs(regStack) 
			     4				pop ??01DD
			     4			endm
 101C  5A		     5				pop dx
 101D  58		     5				pop ax
 101E  FF 36 03BF R	   *	    push   FileCol
 1022  E8 0498		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01E1     textequ <>
 = 			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
 1025  50		     5				push  ax
 = ax			     5				??01E2 catstr <ax>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 1026  52		     5				push  dx
 = dx, ax		     5				??01E2 catstr <dx>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 = <dx, ax>		     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStack
			     5			endif
 1027  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 1029  B2 29		     4				mov dl, ')'
 102B  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
 = <dx, ax>		     5				??01E5     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)
			     5				regStack substr regStack, (??01E4 + 1)
			     5			endif
			     5			exitm ??01E5
			     4		%	for ??01E3, __popRegs(regStack) 
			     4				pop ??01E3
			     4			endm
 102D  5A		     5				pop dx
 102E  58		     5				pop ax
						ret
					ReadChar endp
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01E7     textequ <>
 = 			     2			??01E8 textequ <>
			     2			for       ??01E6, <ax,dx>
			     2				push  ??01E6
			     2				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     2				??01E7 catstr <, >
			     2			endm
 102F  50		     3				push  ax
 = ax			     3				??01E8 catstr <ax>, ??01E7, ??01E8
 = , 			     3				??01E7 catstr <, >
 1030  52		     3				push  dx
 = dx, ax		     3				??01E8 catstr <dx>, ??01E7, ??01E8
 = , 			     3				??01E7 catstr <, >
 = <dx, ax>		     2			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     2			__pushRegs ??01E8
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01E8
			     3			else
			     3				regStack catstr ??01E8, REG_SET_DELIMITER, regStack
			     3			endif
 1031  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 1033  B2 20		     2				mov dl, ' '
 1035  CD 21		     2				int 21h
 1037  B2 45		     2				mov dl, 'E'
 1039  CD 21		     2				int 21h
 103B  B2 72		     2				mov dl, 'r'
 103D  CD 21		     2				int 21h
 103F  B2 72		     2				mov dl, 'r'
 1041  CD 21		     2				int 21h
 1043  B2 6F		     2				mov dl, 'o'
 1045  CD 21		     2				int 21h
 1047  B2 3A		     2				mov dl, ':'
 1049  CD 21		     2				int 21h
 104B  B2 20		     2				mov dl, ' '
 104D  CD 21		     2				int 21h
 104F  B2 63		     2				mov dl, 'c'
 1051  CD 21		     2				int 21h
 1053  B2 61		     2				mov dl, 'a'
 1055  CD 21		     2				int 21h
 1057  B2 72		     2				mov dl, 'r'
 1059  CD 21		     2				int 21h
 105B  B2 61		     2				mov dl, 'a'
 105D  CD 21		     2				int 21h
 105F  B2 63		     2				mov dl, 'c'
 1061  CD 21		     2				int 21h
 1063  B2 74		     2				mov dl, 't'
 1065  CD 21		     2				int 21h
 1067  B2 65		     2				mov dl, 'e'
 1069  CD 21		     2				int 21h
 106B  B2 72		     2				mov dl, 'r'
 106D  CD 21		     2				int 21h
 106F  B2 20		     2				mov dl, ' '
 1071  CD 21		     2				int 21h
 1073  B2 69		     2				mov dl, 'i'
 1075  CD 21		     2				int 21h
 1077  B2 6E		     2				mov dl, 'n'
 1079  CD 21		     2				int 21h
 107B  B2 65		     2				mov dl, 'e'
 107D  CD 21		     2				int 21h
 107F  B2 78		     2				mov dl, 'x'
 1081  CD 21		     2				int 21h
 1083  B2 70		     2				mov dl, 'p'
 1085  CD 21		     2				int 21h
 1087  B2 65		     2				mov dl, 'e'
 1089  CD 21		     2				int 21h
 108B  B2 72		     2				mov dl, 'r'
 108D  CD 21		     2				int 21h
 108F  B2 61		     2				mov dl, 'a'
 1091  CD 21		     2				int 21h
 1093  B2 64		     2				mov dl, 'd'
 1095  CD 21		     2				int 21h
 1097  B2 6F		     2				mov dl, 'o'
 1099  CD 21		     2				int 21h
 109B  B2 3A		     2				mov dl, ':'
 109D  CD 21		     2				int 21h
 109F  B2 20		     2				mov dl, ' '
 10A1  CD 21		     2				int 21h
 10A3  B2 22		     2				mov dl, '"'
 10A5  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01EA instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01EA eq 0
 = <dx, ax>		     3				??01EB     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01EB substr regStack, 1, (??01EA - 1)
			     3				regStack substr regStack, (??01EA + 1)
			     3			endif
			     3			exitm ??01EB
			     2		%	for ??01E9, __popRegs(regStack) 
			     2				pop ??01E9
			     2			endm
 10A7  5A		     3				pop dx
 10A8  58		     3				pop ax
				
 10A9  8D 06 03BC R	   *	    lea    ax, TheUnexpectedChar
 10AD  50		   *	    push   ax
 10AE  E8 03EA		   *	    call   printf_s
					ReadCharTo proc near uses RegsReturningOnAX, Buffer:ptr byte
 10B1  E9 F2A7					mov dx, Buffer
						mov bx, FileHandle
 10B4						mov ah, 3Fh
						mov cx, 1
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01ED     textequ <>
 = 			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
 10B4  50		     5				push  ax
 = ax			     5				??01EE catstr <ax>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 10B5  52		     5				push  dx
 = dx, ax		     5				??01EE catstr <dx>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 = <dx, ax>		     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack
			     5			endif
 10B6  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10B8  B2 28		     4				mov dl, '('
 10BA  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
 = <dx, ax>		     5				??01F1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)
			     5				regStack substr regStack, (??01F0 + 1)
			     5			endif
			     5			exitm ??01F1
			     4		%	for ??01EF, __popRegs(regStack) 
			     4				pop ??01EF
			     4			endm
 10BC  5A		     5				pop dx
 10BD  58		     5				pop ax
 10BE  FF 36 03C1 R	   *	    push   FileLine
 10C2  E8 03F8		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01F3     textequ <>
 = 			     4			??01F4 textequ <>
			     4			for       ??01F2, <ax,dx>
			     4				push  ??01F2
			     4				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     4				??01F3 catstr <, >
			     4			endm
 10C5  50		     5				push  ax
 = ax			     5				??01F4 catstr <ax>, ??01F3, ??01F4
 = , 			     5				??01F3 catstr <, >
 10C6  52		     5				push  dx
 = dx, ax		     5				??01F4 catstr <dx>, ??01F3, ??01F4
 = , 			     5				??01F3 catstr <, >
 = <dx, ax>		     4			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     4			__pushRegs ??01F4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01F4
			     5			else
			     5				regStack catstr ??01F4, REG_SET_DELIMITER, regStack
			     5			endif
 10C7  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10C9  B2 3A		     4				mov dl, ':'
 10CB  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F6 eq 0
 = <dx, ax>		     5				??01F7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01F7 substr regStack, 1, (??01F6 - 1)
			     5				regStack substr regStack, (??01F6 + 1)
			     5			endif
			     5			exitm ??01F7
			     4		%	for ??01F5, __popRegs(regStack) 
			     4				pop ??01F5
			     4			endm
 10CD  5A		     5				pop dx
 10CE  58		     5				pop ax
 10CF  FF 36 03BF R	   *	    push   FileCol
 10D3  E8 03E7		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01F9     textequ <>
 = 			     4			??01FA textequ <>
			     4			for       ??01F8, <ax,dx>
			     4				push  ??01F8
			     4				??01FA catstr <??01F8>, ??01F9, ??01FA
			     4				??01F9 catstr <, >
			     4			endm
 10D6  50		     5				push  ax
 = ax			     5				??01FA catstr <ax>, ??01F9, ??01FA
 = , 			     5				??01F9 catstr <, >
 10D7  52		     5				push  dx
 = dx, ax		     5				??01FA catstr <dx>, ??01F9, ??01FA
 = , 			     5				??01F9 catstr <, >
 = <dx, ax>		     4			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     4			__pushRegs ??01FA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01FA
			     5			else
			     5				regStack catstr ??01FA, REG_SET_DELIMITER, regStack
			     5			endif
 10D8  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10DA  B2 29		     4				mov dl, ')'
 10DC  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01FC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01FC eq 0
 = <dx, ax>		     5				??01FD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01FD substr regStack, 1, (??01FC - 1)
			     5				regStack substr regStack, (??01FC + 1)
			     5			endif
			     5			exitm ??01FD
			     4		%	for ??01FB, __popRegs(regStack) 
			     4				pop ??01FB
			     4			endm
 10DE  5A		     5				pop dx
 10DF  58		     5				pop ax
						int 21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01FF     textequ <>
 = 			     2			??0200 textequ <>
			     2			for       ??01FE, <ax,dx>
			     2				push  ??01FE
			     2				??0200 catstr <??01FE>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     2			endm
 10E0  50		     3				push  ax
 = ax			     3				??0200 catstr <ax>, ??01FF, ??0200
 = , 			     3				??01FF catstr <, >
 10E1  52		     3				push  dx
 = dx, ax		     3				??0200 catstr <dx>, ??01FF, ??0200
 = , 			     3				??01FF catstr <, >
 = <dx, ax>		     2			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     2			__pushRegs ??0200
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0200
			     3			else
			     3				regStack catstr ??0200, REG_SET_DELIMITER, regStack
			     3			endif
 10E2  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 10E4  B2 20		     2				mov dl, ' '
 10E6  CD 21		     2				int 21h
 10E8  B2 45		     2				mov dl, 'E'
 10EA  CD 21		     2				int 21h
 10EC  B2 72		     2				mov dl, 'r'
 10EE  CD 21		     2				int 21h
 10F0  B2 72		     2				mov dl, 'r'
 10F2  CD 21		     2				int 21h
 10F4  B2 6F		     2				mov dl, 'o'
 10F6  CD 21		     2				int 21h
 10F8  B2 3A		     2				mov dl, ':'
 10FA  CD 21		     2				int 21h
 10FC  B2 20		     2				mov dl, ' '
 10FE  CD 21		     2				int 21h
 1100  B2 4E		     2				mov dl, 'N'
 1102  CD 21		     2				int 21h
 1104  B2 20		     2				mov dl, ' '
 1106  CD 21		     2				int 21h
 1108  B2 64		     2				mov dl, 'd'
 110A  CD 21		     2				int 21h
 110C  B2 65		     2				mov dl, 'e'
 110E  CD 21		     2				int 21h
 1110  B2 76		     2				mov dl, 'v'
 1112  CD 21		     2				int 21h
 1114  B2 65		     2				mov dl, 'e'
 1116  CD 21		     2				int 21h
 1118  B2 20		     2				mov dl, ' '
 111A  CD 21		     2				int 21h
 111C  B2 65		     2				mov dl, 'e'
 111E  CD 21		     2				int 21h
 1120  B2 73		     2				mov dl, 's'
 1122  CD 21		     2				int 21h
 1124  B2 74		     2				mov dl, 't'
 1126  CD 21		     2				int 21h
 1128  B2 61		     2				mov dl, 'a'
 112A  CD 21		     2				int 21h
 112C  B2 72		     2				mov dl, 'r'
 112E  CD 21		     2				int 21h
 1130  B2 20		     2				mov dl, ' '
 1132  CD 21		     2				int 21h
 1134  B2 65		     2				mov dl, 'e'
 1136  CD 21		     2				int 21h
 1138  B2 6E		     2				mov dl, 'n'
 113A  CD 21		     2				int 21h
 113C  B2 74		     2				mov dl, 't'
 113E  CD 21		     2				int 21h
 1140  B2 72		     2				mov dl, 'r'
 1142  CD 21		     2				int 21h
 1144  B2 65		     2				mov dl, 'e'
 1146  CD 21		     2				int 21h
 1148  B2 20		     2				mov dl, ' '
 114A  CD 21		     2				int 21h
 114C  B2 32		     2				mov dl, '2'
 114E  CD 21		     2				int 21h
 1150  B2 20		     2				mov dl, ' '
 1152  CD 21		     2				int 21h
 1154  B2 65		     2				mov dl, 'e'
 1156  CD 21		     2				int 21h
 1158  B2 20		     2				mov dl, ' '
 115A  CD 21		     2				int 21h
 115C  B2 37		     2				mov dl, '7'
 115E  CD 21		     2				int 21h
 1160  B2 2E		     2				mov dl, '.'
 1162  CD 21		     2				int 21h
 1164  B2 20		     2				mov dl, ' '
 1166  CD 21		     2				int 21h
 1168  B2 4E		     2				mov dl, 'N'
 116A  CD 21		     2				int 21h
 116C  B2 20		     2				mov dl, ' '
 116E  CD 21		     2				int 21h
 1170  B2 65		     2				mov dl, 'e'
 1172  CD 21		     2				int 21h
 1174  B2 6E		     2				mov dl, 'n'
 1176  CD 21		     2				int 21h
 1178  B2 63		     2				mov dl, 'c'
 117A  CD 21		     2				int 21h
 117C  B2 6F		     2				mov dl, 'o'
 117E  CD 21		     2				int 21h
 1180  B2 6E		     2				mov dl, 'n'
 1182  CD 21		     2				int 21h
 1184  B2 74		     2				mov dl, 't'
 1186  CD 21		     2				int 21h
 1188  B2 72		     2				mov dl, 'r'
 118A  CD 21		     2				int 21h
 118C  B2 61		     2				mov dl, 'a'
 118E  CD 21		     2				int 21h
 1190  B2 64		     2				mov dl, 'd'
 1192  CD 21		     2				int 21h
 1194  B2 6F		     2				mov dl, 'o'
 1196  CD 21		     2				int 21h
 1198  B2 3A		     2				mov dl, ':'
 119A  CD 21		     2				int 21h
 119C  B2 20		     2				mov dl, ' '
 119E  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0202 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0202 eq 0
 = <dx, ax>		     3				??0203     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0203 substr regStack, 1, (??0202 - 1)
			     3				regStack substr regStack, (??0202 + 1)
			     3			endif
			     3			exitm ??0203
			     2		%	for ??0201, __popRegs(regStack) 
			     2				pop ??0201
			     2			endm
 11A0  5A		     3				pop dx
 11A1  58		     3				pop ax
						.if (carry?)
 11A2  A0 03C7 R	   *	    mov    al, N
 11A5  32 E4		   *	    xor    ah, ah
 11A7  50		   *	    push   ax
 11A8  E8 0312		   *	    call   printf_u
 11AB  E9 F1AD						call ErrorRead
						.endif
 11AE				
						; EOF
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??0205     textequ <>
 = 			     2			??0206 textequ <>
			     2			for       ??0204, <ax,dx>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
 11AE  50		     3				push  ax
 = ax			     3				??0206 catstr <ax>, ??0205, ??0206
 = , 			     3				??0205 catstr <, >
 11AF  52		     3				push  dx
 = dx, ax		     3				??0206 catstr <dx>, ??0205, ??0206
 = , 			     3				??0205 catstr <, >
 = <dx, ax>		     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack
			     3			endif
 11B0  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 11B2  B2 55		     2				mov dl, 'U'
 11B4  CD 21		     2				int 21h
 11B6  B2 6E		     2				mov dl, 'n'
 11B8  CD 21		     2				int 21h
 11BA  B2 61		     2				mov dl, 'a'
 11BC  CD 21		     2				int 21h
 11BE  B2 62		     2				mov dl, 'b'
 11C0  CD 21		     2				int 21h
 11C2  B2 6C		     2				mov dl, 'l'
 11C4  CD 21		     2				int 21h
 11C6  B2 65		     2				mov dl, 'e'
 11C8  CD 21		     2				int 21h
 11CA  B2 20		     2				mov dl, ' '
 11CC  CD 21		     2				int 21h
 11CE  B2 74		     2				mov dl, 't'
 11D0  CD 21		     2				int 21h
 11D2  B2 6F		     2				mov dl, 'o'
 11D4  CD 21		     2				int 21h
 11D6  B2 20		     2				mov dl, ' '
 11D8  CD 21		     2				int 21h
 11DA  B2 70		     2				mov dl, 'p'
 11DC  CD 21		     2				int 21h
 11DE  B2 61		     2				mov dl, 'a'
 11E0  CD 21		     2				int 21h
 11E2  B2 72		     2				mov dl, 'r'
 11E4  CD 21		     2				int 21h
 11E6  B2 73		     2				mov dl, 's'
 11E8  CD 21		     2				int 21h
 11EA  B2 65		     2				mov dl, 'e'
 11EC  CD 21		     2				int 21h
 11EE  B2 20		     2				mov dl, ' '
 11F0  CD 21		     2				int 21h
 11F2  B2 63		     2				mov dl, 'c'
 11F4  CD 21		     2				int 21h
 11F6  B2 6F		     2				mov dl, 'o'
 11F8  CD 21		     2				int 21h
 11FA  B2 6D		     2				mov dl, 'm'
 11FC  CD 21		     2				int 21h
 11FE  B2 6D		     2				mov dl, 'm'
 1200  CD 21		     2				int 21h
 1202  B2 61		     2				mov dl, 'a'
 1204  CD 21		     2				int 21h
 1206  B2 6E		     2				mov dl, 'n'
 1208  CD 21		     2				int 21h
 120A  B2 64		     2				mov dl, 'd'
 120C  CD 21		     2				int 21h
 120E  B2 3A		     2				mov dl, ':'
 1210  CD 21		     2				int 21h
 1212  B2 20		     2				mov dl, ' '
 1214  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
 = <dx, ax>		     3				??0209     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)
			     3				regStack substr regStack, (??0208 + 1)
			     3			endif
			     3			exitm ??0209
			     2		%	for ??0207, __popRegs(regStack) 
			     2				pop ??0207
			     2			endm
 1216  5A		     3				pop dx
 1217  58		     3				pop ax
						.if ax == 0
 1218  8D 06 010D R	   *	    lea    ax, CommandBufferString
 121C  50		   *	    push   ax
 121D  E8 027B		   *	    call   printf_s
 1220  E9 F138						mov bx,           dx
							mov byte ptr[bx], 0
						.endif
				
						ret
					ReadCharTo endp
				
					MoveBack proc near uses RegsInvokeUses
						; Move back by one byte
						mov bx, FileHandle
				
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
 1223						mov al, 1
 1223  50		   *	    push   ax
 1224  53		   *	    push   bx
 1225  51		   *	    push   cx
 1226  52		   *	    push   dx
 1227  55		   *	    push   bp
						int 21h
 1228  E8 0059		   *	    call   ReadChar
						.if (carry?)
 122B  EB 31		   *	    jmp    @C00D3
 122D			   *@C00D4:
 122D  8A 1E 000D R					call ErrorRead
						.endif
						ret
 1231  80 FB 0A		   *	    cmp    bl, LF
 1234  75 0C		   *	    jne    @C00D5
 1236  FF 06 03C1 R			MoveBack endp
 123A  C7 06 03BF R 0001	
					PeekChar proc near uses RegsReturningOnAX
 1240  EB 19		   *	    jmp    @C00D7
 1242			   *@C00D5:
 1242  80 FB 0D		   *	    cmp    bl, CR
 1245  75 11		   *	    jne    @C00D8
						invoke ReadCharTo, addr PeekBuffer
			     1			invoke PeekChar
 1247  E8 009A		   *	    call   PeekChar
 124A  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 124E  80 FF 0A		   *	    cmp    bh, LF
 1251  74 08		   *	    je     @C00DA
 1253  E9 FDA5		     1				jmp ErrorUnexpectedChar
			     1			.endif
						invoke MoveBack
 1256  EB 03		   *	    jmp    @C00DC
 1258			   *@C00D8:
 1258  E9 FDA0					ret
					PeekChar endp
				
					ReadNum proc near uses RegsInvokeUses, result:ptr word
 125B			   *@C00DC:
 125B			   *@C00D7:
 125B			   *@C00DA:
 125B  E8 0026		   *	    call   ReadChar
						invoke ReadChar
 125E			   *@C00D3:
 125E  0B C0		   *	    or	ax, ax
 1260  75 CB		   *	    jne    @C00D4
						mov    ax, 0
 1262  5D		   *	    pop    bp
 1263  5A		   *	    pop    dx
 1264  59		   *	    pop    cx
 1265  5B		   *	    pop    bx
 1266  58		   *	    pop    ax
 1267  C3		   *	    ret    00000h
 1268						mov    bx, 0
						mov    cx, 10
 1268						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
			     1			local reg, comma, regpushed
 = 			     1			??020B     textequ <>
 = 			     1			??020C textequ <>
			     1			for       ??020A, <ax,dx>
			     1				push  ??020A
			     1				??020C catstr <??020A>, ??020B, ??020C
			     1				??020B catstr <, >
			     1			endm
 1268  50		     2				push  ax
 = ax			     2				??020C catstr <ax>, ??020B, ??020C
 = , 			     2				??020B catstr <, >
 1269  52		     2				push  dx
 = dx, ax		     2				??020C catstr <dx>, ??020B, ??020C
 = , 			     2				??020B catstr <, >
 = <dx, ax>		     1			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     1			__pushRegs ??020C
 = 0000			     2			size_s sizestr regStack
			     2			if     size_s eq 0
 = <dx, ax>		     2				regStack catstr ??020C
			     2			else
			     2				regStack catstr ??020C, REG_SET_DELIMITER, regStack
			     2			endif
 126A  B0 00						mul cx
 126C  8D 16 0005 R		
 1270  B4 3D						sub bl, '0'
 1272  CD 21						add ax, bx
				
 1274  73 03		   *	    jae    @C00DE
 1276  E8 F9A6						push   ax
							invoke ReadChar
 1279			   *@C00DE:
 1279  A3 0071 R					pop    ax
 127C  C6 06 0073 R 01					mov    bl, FileBuffer
						.endw
			     1			local reg
			     2			local regs_end, regs
 = 0000			     2			??020E instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??020E eq 0
 = <dx, ax>		     2				??020F     substr regStack, 1
 = 			     2				regStack textequ <>
			     2			else
			     2				??020F substr regStack, 1, (??020E - 1)
			     2				regStack substr regStack, (??020E + 1)
			     2			endif
			     2			exitm ??020F
			     1		%	for ??020D, __popRegs(regStack) 
			     1				pop ??020D
			     1			endm
 1281  5A		     2				pop dx
 1282  58		     2				pop ax
 1283  C3					invoke MoveBack
 1284				
						mov bx,           result
 1284						mov word ptr[bx], ax
 1284  53		   *	    push   bx
 1285  51		   *	    push   cx
 1286  52		   *	    push   dx
 1287  55		   *	    push   bp
						ret
 1288  8D 06 000D R	   *	    lea    ax, FileBuffer
 128C  50		   *	    push   ax
 128D  E8 0009		   *	    call   ReadCharTo
 1290  FF 06 03BF R			ReadNum endp
				
 1294  5D		   *	    pop    bp
 1295  5A		   *	    pop    dx
 1296  59		   *	    pop    cx
 1297  5B		   *	    pop    bx
 1298  C3		   *	    ret    00000h
 1299					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
 1299						ReadMatrixLoop:
 1299  55		   *	    push   bp
 129A  8B EC		   *	    mov    bp, sp
 129C  53		   *	    push   bx
 129D  51		   *	    push   cx
 129E  52		   *	    push   dx
 129F  55		   *	    push   bp
 12A0  8B 56 04						invoke ReadChar
 12A3  8B 1E 0071 R					.if    ax == 0  ; EOF
 12A7  B4 3F							mov al,       TotalCol
 12A9  B9 0001							inc al                 ; TotalCol starts at 0
 12AC  CD 21							mov NPlusOne, al
								dec al                 ; ax = N
 12AE  73 03		   *	    jae    @C00E0
 12B0  E8 F9E5							mov N,        al       ; TotalCol starts at 0
								dec al
 12B3			   *@C00E0:
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
 12B3  0B C0		   *	    or	ax, ax
 12B5  75 05		   *	    jne    @C00E2
 12B7  8B DA								jmp ErrorInvalidN
 12B9  C6 07 00							.endif
								jmp EndReading
 12BC			   *@C00E2:
							.endif
				
 12BC  5D		   *	    pop    bp
 12BD  5A		   *	    pop    dx
 12BE  59		   *	    pop    cx
 12BF  5B		   *	    pop    bx
 12C0  5D		   *	    pop    bp
 12C1  C2 0002		   *	    ret    00002h
 12C4							mov bl, FileBuffer
				
 12C4							.if bl == 3Bh
								inc Col
 12C4  50		   *	    push   ax
 12C5  53		   *	    push   bx
 12C6  51		   *	    push   cx
 12C7  52		   *	    push   dx
 12C8  55		   *	    push   bp
 12C9  8B 1E 0071 R					.elseif bl == LF
								inc FileLine
 12CD  B4 42							mov FileCol, 1
 12CF  B9 FFFF							;====================================================================
 12D2  BA FFFF							; On a new line, the number of columns should always be the same
 12D5  B0 01							mov al,      Col
 12D7  CD 21							.if Row == 0
									mov TotalCol, al
 12D9  73 03		   *	    jae    @C00E4
 12DB  E8 F9BA							.elseif TotalCol != al
									jmp ErrorColumnCount
 12DE			   *@C00E4:
								.endif
 12DE  5D		   *	    pop    bp
 12DF  5A		   *	    pop    dx
 12E0  59		   *	    pop    cx
 12E1  5B		   *	    pop    bx
 12E2  58		   *	    pop    ax
 12E3  C3		   *	    ret    00000h
 12E4								;====================================================================
								; If next line is empty, all next lines should be empty
 12E4								invoke PeekChar
 12E4  53		   *	    push   bx
 12E5  51		   *	    push   cx
 12E6  52		   *	    push   dx
 12E7  55		   *	    push   bp
								mov    bh, PeekBuffer
 12E8  8D 06 03BB R	   *	    lea    ax, PeekBuffer
 12EC  50		   *	    push   ax
 12ED  E8 FFA9		   *	    call   ReadCharTo
								.if    bh == LF || bh == CR
 12F0  E8 FFD1		   *	    call   MoveBack
									invoke ReadEmptyLines
 12F3  5D		   *	    pop    bp
 12F4  5A		   *	    pop    dx
 12F5  59		   *	    pop    cx
 12F6  5B		   *	    pop    bx
 12F7  C3		   *	    ret    00000h
 12F8								;====================================================================
								; Otherwise, next line must have data
 12F8								.else
 12F8  55		   *	    push   bp
 12F9  8B EC		   *	    mov    bp, sp
 12FB  50		   *	    push   ax
 12FC  53		   *	    push   bx
 12FD  51		   *	    push   cx
 12FE  52		   *	    push   dx
 12FF  55		   *	    push   bp
									inc Row
 1300  E8 FF81		   *	    call   ReadChar
 1303  B8 0000								inc TotalRow
 1306  BB 0000								mov Col, 0
 1309  B9 000A							.endif
 130C  8A 1E 000D R					.elseif bl == CR
							; accept CR only before LF
 1310  EB 10		   *	    jmp    @C00E6
 1312			   *@C00E7:
 1312  F7 E1							HandleCR
							.elseif (bl == '-')
 1314  80 EB 30							CurrentIndexToBx
 1317  03 C3							invoke ReadNum, bx
								neg    sword ptr [bx]
 1319  50						.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
 131A  E8 FF67		   *	    call   ReadChar
 131D  58							CurrentIndexToBx
 131E  8A 1E 000D R						invoke ReadNum, bx
							.else
 1322			   *@C00E6:
 1322  80 FB 39		   *	    cmp    bl, '9'
 1325  77 05		   *	    ja     @C00E8
 1327  80 FB 30		   *	    cmp    bl, '0'
 132A  73 E6		   *	    jae    @C00E7
 132C			   *@C00E8:
								jmp ErrorUnexpectedChar
 132C  E8 FF95		   *	    call   MoveBack
							.endif
 132F  8B 5E 04						jmp ReadMatrixLoop
 1332  89 07					EndReading:
							CloseFileHandle
 1334  5D		   *	    pop    bp
 1335  5A		   *	    pop    dx
 1336  59		   *	    pop    cx
 1337  5B		   *	    pop    bx
 1338  58		   *	    pop    ax
 1339  5D		   *	    pop    bp
 133A  C2 0002		   *	    ret    00002h
 133D						ret
					ReadMatrix endp
 133D				
 133D  50		   *	    push   ax
 133E  53		   *	    push   bx
 133F  51		   *	    push   cx
 1340  52		   *	    push   dx
 1341  55		   *	    push   bp
				;====================================================================
 1342  E8 FF23		   *	    call   OpenFile
 1345				; Printf
				
 1345  E8 FF3C		   *	    call   ReadChar
					PrintMatrix proc near uses RegsInvokeUses
 1348  0B C0		   *	    or	ax, ax
 134A  75 28		   *	    jne    @C00EA
 134C  A0 03C6 R				mov      bx, offset Matrix
 134F  FE C0					mov      dx, 8
 1351  A2 03C8 R				mov      cx, 0             ; High has row, Low has column
 1354  FE C8					.ForRow:                   ; for (row = 0; row < N; row++)
 1356  A2 03C7 R					cmp ch, N      ; row < N
 1359  FE C8						jge .EndForRow
				
 135B  38 06 03C5 R	   *	    cmp    TotalRow, al
 135F  74 05		   *	    je     @C00EC
 1361  E9 FAE2						mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
 1364  EB 0B		   *	    jmp    @C00EE
 1366			   *@C00EC:
 1366  3C 02		   *	    cmp    al, 002h
 1368  72 04		   *	    jb     @C00F0
 136A  3C 07		   *	    cmp    al, 007h
 136C  76 03		   *	    jbe    @C00EF
 136E			   *@C00F0:
 136E  E9 FD43							cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
 1371			   *@C00EF:
 1371			   *@C00EE:
 1371  E9 00CC			
								mov ax, sword ptr [bx]
 1374			   *@C00EA:
								invoke printf_d_padded, ax, dx
 1374  8A 1E 000D R		
								add bx, 2 ; size in bytes of a sword
				
 1378  80 FB 3B		   *	    cmp    bl, 03Bh
 137B  75 07		   *	    jne    @C00F2
 137D  FE 06 03C4 R						inc cl      ; col ++
								jmp .ForCol
 1381  E9 00B9		   *	    jmp    @C00F4
 1384			   *@C00F2:
 1384  80 FB 0A		   *	    cmp    bl, LF
 1387  75 47		   *	    jne    @C00F5
 1389  FF 06 03C1 R					.EndForCol:
 138D  C7 06 03BF R 0001				putc CR
							putc LF
				
 1393  A0 03C4 R					inc ch      ; row++
							jmp .ForRow
 1396  80 3E 03C3 R 00	   *	    cmp    Row, 000h
 139B  75 05		   *	    jne    @C00F7
 139D  A2 03C6 R				.EndForRow:
						ret
 13A0  EB 09		   *	    jmp    @C00F9
 13A2			   *@C00F7:
 13A2  38 06 03C6 R	   *	    cmp    TotalCol, al
 13A6  74 03		   *	    je     @C00FA
 13A8  E9 F962				PrintMatrix endp
				
					printf_s proc near uses RegsInvokeUses, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
 13AB			   *@C00FA:
 13AB			   *@C00F9:
 13AB  E8 FF36		   *	    call   PeekChar
 13AE  8A 3E 03BB R					mov ah, 2
							mov dl, [bx]
 13B2  80 FF 0A		   *	    cmp    bh, LF
 13B5  74 05		   *	    je     @C00FD
 13B7  80 FF 0D		   *	    cmp    bh, CR
 13BA  75 05		   *	    jne    @C00FC
 13BC			   *@C00FD:
							int 21H
 13BC  E8 FE64		   *	    call   ReadEmptyLines
							inc bx
						.endw
						ret
 13BF  EB 7C		   *	    jmp    @C00FF
 13C1			   *@C00FC:
 13C1  FE 06 03C3 R			printf_s endp
 13C5  FE 06 03C5 R		
 13C9  C6 06 03C4 R 00			printf_u proc near uses RegsInvokeUses, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
 13CE  EB 6D		   *	    jmp    @C0100
 13D0			   *@C00F5:
 13D0  80 FB 0D		   *	    cmp    bl, CR
 13D3  75 11		   *	    jne    @C0101
						invoke printf_s, addr buf
						ret
			     1			invoke PeekChar
 13D5  E8 FF0C		   *	    call   PeekChar
 13D8  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 13DC  80 FF 0A		   *	    cmp    bh, LF
 13DF  74 5C		   *	    je     @C0103
 13E1  E9 FC17		     1				jmp ErrorUnexpectedChar
			     1			.endif
					printf_u endp
 13E4  EB 57		   *	    jmp    @C0105
 13E6			   *@C0101:
 13E6  80 FB 2D		   *	    cmp    bl, '-'
 13E9  75 22		   *	    jne    @C0106
				
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??0211     textequ <>
 = 			     2			??0212 textequ <>
			     2			for       ??0210, <ax>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
 13EB  50		     3				push  ax
 = ax			     3				??0212 catstr <ax>, ??0211, ??0212
 = , 			     3				??0211 catstr <, >
 = <ax>			     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack
			     3			endif
 13EC  A0 03C6 R	     1			mov      al, TotalCol
 13EF  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 13F1  8A 1E 03C3 R	     1			mov bl, Row
 13F5  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 13F9  F6 E3		     1			mul bl
 13FB  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 13FD  D1 E0		     1			shl ax, 1
 13FF  05 03C9 R	     1			add ax, offset Matrix
			     1	
 1402  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
 = <ax>			     3				??0215     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)
			     3				regStack substr regStack, (??0214 + 1)
			     3			endif
			     3			exitm ??0215
			     2		%	for ??0213, __popRegs(regStack) 
			     2				pop ??0213
			     2			endm
 1404  58		     3				pop ax
					printf_d proc near uses RegsInvokeUses, number:sword
 1405  53		   *	    push   bx
 1406  E8 FEEF		   *	    call   ReadNum
 1409  F7 1F					local  buf[7]:byte
						invoke string_from_sword, addr buf, number
 140B  EB 30		   *	    jmp    @C0108
 140D			   *@C0106:
 140D  80 FB 39		   *	    cmp    bl, '9'
 1410  77 28		   *	    ja     @C0109
 1412  80 FB 30		   *	    cmp    bl, '0'
 1415  72 23		   *	    jb     @C0109
						invoke printf_s, addr buf
 1417  E8 FEAA		   *	    call   MoveBack
						ret
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??0217     textequ <>
 = 			     2			??0218 textequ <>
			     2			for       ??0216, <ax>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
 141A  50		     3				push  ax
 = ax			     3				??0218 catstr <ax>, ??0217, ??0218
 = , 			     3				??0217 catstr <, >
 = <ax>			     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack
			     3			endif
 141B  A0 03C6 R	     1			mov      al, TotalCol
 141E  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 1420  8A 1E 03C3 R	     1			mov bl, Row
 1424  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 1428  F6 E3		     1			mul bl
 142A  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 142C  D1 E0		     1			shl ax, 1
 142E  05 03C9 R	     1			add ax, offset Matrix
			     1	
 1431  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
 = <ax>			     3				??021B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)
			     3				regStack substr regStack, (??021A + 1)
			     3			endif
			     3			exitm ??021B
			     2		%	for ??0219, __popRegs(regStack) 
			     2				pop ??0219
			     2			endm
 1433  58		     3				pop ax
					printf_d endp
 1434  53		   *	    push   bx
 1435  E8 FEC0		   *	    call   ReadNum
					
 1438  EB 03		   *	    jmp    @C010C
 143A			   *@C0109:
 143A  E9 FBBE				printf_d_padded proc near uses RegsInvokeUses, number:sword, padTo:sword
						local  buf[7]:byte
 143D			   *@C010C:
 143D			   *@C0108:
 143D			   *@C0105:
 143D			   *@C0100:
 143D			   *@C00F4:
 143D			   *@C00FF:
 143D			   *@C0103:
 143D  E9 FF05					invoke string_from_sword, addr buf, number
 1440						; string_from_sword gives length on AX
						mov    cx, padTo
 1440  B4 3E		     1			mov ah, 3eh
 1442  8B 1E 0071 R	     1			mov bx, FileHandle
 1446  CD 21		     1			int 21h
			     1			
 1448  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
						sub    cx, ax
 144D  5D		   *	    pop    bp
 144E  5A		   *	    pop    dx
 144F  59		   *	    pop    cx
 1450  5B		   *	    pop    bx
 1451  58		   *	    pop    ax
 1452  C3		   *	    ret    00000h
 1453						.WHILE (sword ptr cx > 0)
							putc SPACE
							dec  cx
						.ENDW
						invoke printf_s, addr buf
 1453						ret
 1453  50		   *	    push   ax
 1454  53		   *	    push   bx
 1455  51		   *	    push   cx
 1456  52		   *	    push   dx
 1457  55		   *	    push   bp
 1458  BB 03C9 R			printf_d_padded endp
 145B  BA 0008			
 145E  B9 0000				; length of string goes to ax (including sign)
 1461					string_from_sword proc near uses RegsReturningOnAX, string:ptr byte, number:sword
 1461  3A 2E 03C7 R				mov dx, number
 1465  7D 2E					mov bx, string
						mov cx, 0
 1467  B1 00					.if (sword ptr dx < 0)
 1469							mov byte ptr[bx], '-'
 1469  3A 0E 03C8 R					inc bx
 146D  7D 0E						inc cx
							neg dx
 146F  8B 07					.endif
						invoke string_from_word, bx, dx
 1471  52		   *	    push   dx
 1472  50		   *	    push   ax
 1473  E8 0095		   *	    call   printf_d_padded
						add ax, cx
 1476  83 C3 02					ret
					string_from_sword endp
 1479  FE C1			
 147B  EB EC				; length of string goes to ax
 147D					string_from_word proc near uses RegsReturningOnAX si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??021D     textequ <>
 = 			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
 147D  50		     3				push  ax
 = ax			     3				??021E catstr <ax>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 147E  52		     3				push  dx
 = dx, ax		     3				??021E catstr <dx>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 = <dx, ax>		     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack
			     3			endif
 147F  B4 02		     1			mov      ah, 02h
 1481  B2 0D		     1			mov      dl, CR
 1483  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
 = <dx, ax>		     3				??0221     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)
			     3				regStack substr regStack, (??0220 + 1)
			     3			endif
			     3			exitm ??0221
			     2		%	for ??021F, __popRegs(regStack) 
			     2				pop ??021F
			     2			endm
 1485  5A		     3				pop dx
 1486  58		     3				pop ax
				
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0223     textequ <>
 = 			     2			??0224 textequ <>
			     2			for       ??0222, <ax,dx>
			     2				push  ??0222
			     2				??0224 catstr <??0222>, ??0223, ??0224
			     2				??0223 catstr <, >
			     2			endm
 1487  50		     3				push  ax
 = ax			     3				??0224 catstr <ax>, ??0223, ??0224
 = , 			     3				??0223 catstr <, >
 1488  52		     3				push  dx
 = dx, ax		     3				??0224 catstr <dx>, ??0223, ??0224
 = , 			     3				??0223 catstr <, >
 = <dx, ax>		     2			??0224 catstr OPEN_DELIMITER, ??0224, CLOSE_DELIMITER
			     2			__pushRegs ??0224
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0224
			     3			else
			     3				regStack catstr ??0224, REG_SET_DELIMITER, regStack
			     3			endif
 1489  B4 02		     1			mov      ah, 02h
 148B  B2 0A		     1			mov      dl, LF
 148D  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0226 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0226 eq 0
 = <dx, ax>		     3				??0227     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0227 substr regStack, 1, (??0226 - 1)
			     3				regStack substr regStack, (??0226 + 1)
			     3			endif
			     3			exitm ??0227
			     2		%	for ??0225, __popRegs(regStack) 
			     2				pop ??0225
			     2			endm
 148F  5A		     3				pop dx
 1490  58		     3				pop ax
						mov divisor, 10000
 1491  FE C5					mov first,   1     ; anything not 0 is true
 1493  EB CC			
 1495						mov ax,    number
						mov value, ax
 1495  5D		   *	    pop    bp
 1496  5A		   *	    pop    dx
 1497  59		   *	    pop    cx
 1498  5B		   *	    pop    bx
 1499  58		   *	    pop    ax
 149A  C3		   *	    ret    00000h
 149B				
						mov bx, string
 149B						mov cx, 5
 149B  55		   *	    push   bp
 149C  8B EC		   *	    mov    bp, sp
 149E  50		   *	    push   ax
 149F  53		   *	    push   bx
 14A0  51		   *	    push   cx
 14A1  52		   *	    push   dx
 14A2  55		   *	    push   bp
 14A3  8B 5E 04					.repeat
							mov dx,    0
 14A6  EB 07		   *	    jmp    @C010D
 14A8			   *@C010E:
 14A8  B4 02						mov ax,    value
 14AA  8A 17						div divisor
 14AC  CD 21						mov value, dx
 14AE  43			
							.if (ax != 0) || (!first) ; no zeroes on the left
 14AF			   *@C010D:
 14AF  80 3F 00		   *	    cmp    byte ptr [bx], 000h
 14B2  75 F4		   *	    jne    @C010E
								add al,            '0'
 14B4  5D		   *	    pop    bp
 14B5  5A		   *	    pop    dx
 14B6  59		   *	    pop    cx
 14B7  5B		   *	    pop    bx
 14B8  58		   *	    pop    ax
 14B9  5D		   *	    pop    bp
 14BA  C2 0002		   *	    ret    00002h
 14BD								mov byte ptr [bx], al
								inc bx
 14BD								mov first,         0
							.endif
 14BD  55		   *	    push   bp
 14BE  8B EC		   *	    mov    bp, sp
 14C0  83 C4 FA		   *	    add    sp, 0FFFAh
 14C3  50		   *	    push   ax
 14C4  53		   *	    push   bx
 14C5  51		   *	    push   cx
 14C6  52		   *	    push   dx
 14C7  55		   *	    push   bp
				
 14C8  FF 76 04		   *	    push   word  ptr ss:[bp]+00004h
 14CB  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14CE  50		   *	    push   ax
 14CF  E8 00A2		   *	    call   string_from_word
							mov dx,      0
 14D2  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14D5  50		   *	    push   ax
 14D6  E8 FFC2		   *	    call   printf_s
							mov ax,      divisor
 14D9  5D		   *	    pop    bp
 14DA  5A		   *	    pop    dx
 14DB  59		   *	    pop    cx
 14DC  5B		   *	    pop    bx
 14DD  58		   *	    pop    ax
 14DE  8B E5		   *	    mov    sp, bp
 14E0  5D		   *	    pop    bp
 14E1  C2 0002		   *	    ret    00002h
 14E4							mov si,      10
							div si
 14E4							mov divisor, ax
				
 14E4  55		   *	    push   bp
 14E5  8B EC		   *	    mov    bp, sp
 14E7  83 C4 F8		   *	    add    sp, 0FFF8h
 14EA  50		   *	    push   ax
 14EB  53		   *	    push   bx
 14EC  51		   *	    push   cx
 14ED  52		   *	    push   dx
 14EE  55		   *	    push   bp
						.untilcxz
 14EF  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 14F2  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14F5  50		   *	    push   ax
 14F6  E8 0050		   *	    call   string_from_sword
				
 14F9  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14FC  50		   *	    push   ax
 14FD  E8 FF9B		   *	    call   printf_s
						.if (first)
 1500  5D		   *	    pop    bp
 1501  5A		   *	    pop    dx
 1502  59		   *	    pop    cx
 1503  5B		   *	    pop    bx
 1504  58		   *	    pop    ax
 1505  8B E5		   *	    mov    sp, bp
 1507  5D		   *	    pop    bp
 1508  C2 0002		   *	    ret    00002h
 150B							mov byte ptr [bx], '0'
							inc bx
 150B						.endif
				
 150B  55		   *	    push   bp
 150C  8B EC		   *	    mov    bp, sp
 150E  83 C4 F8		   *	    add    sp, 0FFF8h
 1511  50		   *	    push   ax
 1512  53		   *	    push   bx
 1513  51		   *	    push   cx
 1514  52		   *	    push   dx
 1515  55		   *	    push   bp
						mov cx, string
 1516  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 1519  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 151C  50		   *	    push   ax
 151D  E8 0029		   *	    call   string_from_sword
						mov ax, bx
 1520  8B 4E 06					sub ax, cx     ; ax = bx - string = len
 1523  2B C8			
						mov byte ptr [bx], 0
 1525  EB 0B		   *	    jmp    @C0110
 1527			   *@C0111:
						ret
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0229     textequ <>
 = 			     2			??022A textequ <>
			     2			for       ??0228, <ax,dx>
			     2				push  ??0228
			     2				??022A catstr <??0228>, ??0229, ??022A
			     2				??0229 catstr <, >
			     2			endm
 1527  50		     3				push  ax
 = ax			     3				??022A catstr <ax>, ??0229, ??022A
 = , 			     3				??0229 catstr <, >
 1528  52		     3				push  dx
 = dx, ax		     3				??022A catstr <dx>, ??0229, ??022A
 = , 			     3				??0229 catstr <, >
 = <dx, ax>		     2			??022A catstr OPEN_DELIMITER, ??022A, CLOSE_DELIMITER
			     2			__pushRegs ??022A
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??022A
			     3			else
			     3				regStack catstr ??022A, REG_SET_DELIMITER, regStack
			     3			endif
 1529  B4 02		     1			mov      ah, 02h
 152B  B2 20		     1			mov      dl, SPACE
 152D  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??022C instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??022C eq 0
 = <dx, ax>		     3				??022D     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??022D substr regStack, 1, (??022C - 1)
			     3				regStack substr regStack, (??022C + 1)
			     3			endif
			     3			exitm ??022D
			     2		%	for ??022B, __popRegs(regStack) 
			     2				pop ??022B
			     2			endm
 152F  5A		     3				pop dx
 1530  58		     3				pop ax
 1531  49				string_from_word endp
				
 1532			   *@C0110:
 1532  83 F9 00		   *	    cmp    sword ptr cx, 000h
 1535  7F F0		   *	    jg     @C0111
				;--------------------------------------------------------------------
 1537  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 153A  50		   *	    push   ax
 153B  E8 FF5D		   *	    call   printf_s
				end
 153E  5D		   *	    pop    bp
 153F  5A		   *	    pop    dx
 1540  59		   *	    pop    cx
 1541  5B		   *	    pop    bx
 1542  58		   *	    pop    ax
 1543  8B E5		   *	    mov    sp, bp
 1545  5D		   *	    pop    bp
 1546  C2 0004		   *	    ret    00004h
 1549
 1549
 1549  55		   *	    push   bp
 154A  8B EC		   *	    mov    bp, sp
 154C  53		   *	    push   bx
 154D  51		   *	    push   cx
 154E  52		   *	    push   dx
 154F  55		   *	    push   bp
 1550  8B 56 06
 1553  8B 5E 04
 1556  B9 0000
 1559  83 FA 00		   *	    cmp    sword ptr dx, 000h
 155C  7D 07		   *	    jge    @C0113
 155E  C6 07 2D
 1561  43
 1562  41
 1563  F7 DA
 1565			   *@C0113:
 1565  52		   *	    push   dx
 1566  53		   *	    push   bx
 1567  E8 000A		   *	    call   string_from_word
 156A  03 C1
 156C  5D		   *	    pop    bp
 156D  5A		   *	    pop    dx
 156E  59		   *	    pop    cx
 156F  5B		   *	    pop    bx
 1570  5D		   *	    pop    bp
 1571  C2 0004		   *	    ret    00004h
 1574
 1574
 1574  55		   *	    push   bp
 1575  8B EC		   *	    mov    bp, sp
 1577  83 C4 FA		   *	    add    sp, 0FFFAh
 157A  53		   *	    push   bx
 157B  51		   *	    push   cx
 157C  52		   *	    push   dx
 157D  55		   *	    push   bp
 157E  56		   *	    push   si
 157F  C7 46 FC 2710
 1584  C6 46 FB 01
 1588  8B 46 06
 158B  89 46 FE
 158E  8B 5E 04
 1591  B9 0005
 1594			   *@C0115:
 1594  BA 0000
 1597  8B 46 FE
 159A  F7 76 FC
 159D  89 56 FE
 15A0  0B C0		   *	    or	ax, ax
 15A2  75 06		   *	    jne    @C0117
 15A4  80 7E FB 00	   *	    cmp    first, 000h
 15A8  75 09		   *	    jne    @C0116
 15AA			   *@C0117:
 15AA  04 30
 15AC  88 07
 15AE  43
 15AF  C6 46 FB 00
 15B3			   *@C0116:
 15B3  BA 0000
 15B6  8B 46 FC
 15B9  BE 000A
 15BC  F7 F6
 15BE  89 46 FC
 15C1  E2 D1		   *	    loop   @C0115
 15C3  80 7E FB 00	   *	    cmp    first, 000h
 15C7  74 04		   *	    je     @C0119
 15C9  C6 07 30
 15CC  43
 15CD			   *@C0119:
 15CD  8B 4E 04
 15D0  8B C3
 15D2  2B C1
 15D4  C6 07 00
 15D7  5E		   *	    pop    si
 15D8  5D		   *	    pop    bp
 15D9  5A		   *	    pop    dx
 15DA  59		   *	    pop    cx
 15DB  5B		   *	    pop    bx
 15DC  8B E5		   *	    mov    sp, bp
 15DE  5D		   *	    pop    bp
 15DF  C2 0004		   *	    ret    00004h
 15E2
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:33:33
main.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CloseFileHandle  . . . . . . . .	Proc
CurrentIndexToBx . . . . . . . .	Proc
DEFINED  . . . . . . . . . . . .	Func
ErrorCantOpenNorCreate . . . . .	Proc
ErrorCommandExpectsNumber  . . .	Proc
ErrorNumberOutOfBounds . . . . .	Proc
HandleCR . . . . . . . . . . . .	Proc
RestoreRegs  . . . . . . . . . .	Proc
SaveRegs . . . . . . . . . . . .	Proc
SkipSpacesInSI . . . . . . . . .	Proc
StartsWith . . . . . . . . . . .	Proc
WriteToFile  . . . . . . . . . .	Proc
__popRegs  . . . . . . . . . . .	Func
__pushRegs . . . . . . . . . . .	Proc
jumpIfSIComparesTo . . . . . . .	Proc
print_FilePosition . . . . . . .	Proc
print_Pair . . . . . . . . . . .	Proc
print_TotalRowCol  . . . . . . .	Proc
printf_c . . . . . . . . . . . .	Proc
putc . . . . . . . . . . . . . .	Proc
skipAndRead  . . . . . . . . . .	Proc
strcpy_all . . . . . . . . . . .	Proc
strcpy_c . . . . . . . . . . . .	Proc
strcpy . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 042B	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 15E2	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ADDMatrix  . . . . . . . . . . .	P Near	 01B5	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  ADDMatrix@Loop . . . . . . . .	L Near	 01EF	  _TEXT	
DIVMatrix  . . . . . . . . . . .	P Near	 017D	  _TEXT	Length= 0038 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  DIVMatrix@Loop . . . . . . . .	L Near	 019F	  _TEXT	
ExitAndClose . . . . . . . . . .	P Near	 0360	  _TEXT	Length= 0019 Public STDCALL
ExitFailure  . . . . . . . . . .	P Near	 035B	  _TEXT	Length= 0005 Public STDCALL
ExitSuccess  . . . . . . . . . .	P Near	 0356	  _TEXT	Length= 0005 Public STDCALL
MULMatrix  . . . . . . . . . . .	P Near	 0146	  _TEXT	Length= 0037 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  MULMatrix@Loop . . . . . . . .	L Near	 0168	  _TEXT	
Main@ADD . . . . . . . . . . . .	P Near	 00A6	  _TEXT	Length= 0020 Public STDCALL
Main@MUL . . . . . . . . . . . .	P Near	 00C6	  _TEXT	Length= 001C Public STDCALL
Main@UNDO  . . . . . . . . . . .	P Near	 00E2	  _TEXT	Length= 005F Public STDCALL
Main@WRITE . . . . . . . . . . .	P Near	 0141	  _TEXT	Length= 0005 Public STDCALL
MoveBack . . . . . . . . . . . .	P Near	 12C4	  _TEXT	Length= 0020 Public STDCALL
OpenFile . . . . . . . . . . . .	P Near	 1268	  _TEXT	Length= 001C Public STDCALL
ParseCommand@CONSTANTE_AUSENTE .	P Near	 0805	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_AUSENTE . . .	P Near	 072B	  _TEXT	Length= 00DA Public STDCALL
ParseCommand@LINHA_DST_AUSENTE .	P Near	 08EB	  _TEXT	Length= 00EA Public STDCALL
ParseCommand@LINHA_DST_INVALIDA 	P Near	 0B27	  _TEXT	Length= 007C Public STDCALL
ParseCommand@LINHA_INVALIDA  . .	P Near	 0ABB	  _TEXT	Length= 006C Public STDCALL
ParseCommand@LINHA_ORG_AUSENTE .	P Near	 09D5	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_ORG_INVALIDA 	P Near	 0BA3	  _TEXT	Length= 007C Public STDCALL
ParseCommand . . . . . . . . . .	P Near	 0406	  _TEXT	Length= 0325 Public STDCALL
  a  . . . . . . . . . . . . . .	Word	 bp - 0002
  ??0056 . . . . . . . . . . . .	L Near	 043D	  _TEXT	
  ??0057 . . . . . . . . . . . .	L Near	 0440	  _TEXT	
  ??0060 . . . . . . . . . . . .	L Near	 0470	  _TEXT	
  ??0061 . . . . . . . . . . . .	L Near	 0473	  _TEXT	
  ??006A . . . . . . . . . . . .	L Near	 04AC	  _TEXT	
  ??006B . . . . . . . . . . . .	L Near	 04AF	  _TEXT	
  ??0074 . . . . . . . . . . . .	L Near	 04F1	  _TEXT	
  ??0075 . . . . . . . . . . . .	L Near	 04F4	  _TEXT	
  ??007E . . . . . . . . . . . .	L Near	 052D	  _TEXT	
  ??007F . . . . . . . . . . . .	L Near	 0530	  _TEXT	
  ??0088 . . . . . . . . . . . .	L Near	 0569	  _TEXT	
  ??0089 . . . . . . . . . . . .	L Near	 056C	  _TEXT	
  ParseCommand@error . . . . . .	L Near	 05D7	  _TEXT	
  ParseCommand@MUL . . . . . . .	L Near	 05DF	  _TEXT	
  ParseCommand@ADD . . . . . . .	L Near	 063E	  _TEXT	
  ParseCommand@UNDO  . . . . . .	L Near	 06BB	  _TEXT	
  ParseCommand@WRITE . . . . . .	L Near	 06C0	  _TEXT	
  ParseCommand@EXIT  . . . . . .	L Near	 06D7	  _TEXT	
  ParseCommand@success . . . . .	L Near	 06D9	  _TEXT	
PeekChar . . . . . . . . . . . .	P Near	 12E4	  _TEXT	Length= 0014 Public STDCALL
PrintMatrix  . . . . . . . . . .	P Near	 1453	  _TEXT	Length= 0048 Public STDCALL
  .ForRow  . . . . . . . . . . .	L Near	 1461	  _TEXT	
  .ForCol  . . . . . . . . . . .	L Near	 1469	  _TEXT	
  .EndForCol . . . . . . . . . .	L Near	 147D	  _TEXT	
  .EndForRow . . . . . . . . . .	L Near	 1495	  _TEXT	
ReadCharTo . . . . . . . . . . .	P Near	 1299	  _TEXT	Length= 002B Public STDCALL
  Buffer . . . . . . . . . . . .	Word	 bp + 0004
ReadChar . . . . . . . . . . . .	P Near	 1284	  _TEXT	Length= 0015 Public STDCALL
ReadCommand  . . . . . . . . . .	P Near	 0379	  _TEXT	Length= 002F Public STDCALL
ReadEmptyLines . . . . . . . . .	P Near	 1223	  _TEXT	Length= 0045 Public STDCALL
ReadMatrix . . . . . . . . . . .	P Near	 133D	  _TEXT	Length= 0120 Public STDCALL
  ReadMatrixLoop . . . . . . . .	L Near	 1345	  _TEXT	
  EndReading . . . . . . . . . .	L Near	 1440	  _TEXT	
ReadNumFromString  . . . . . . .	P Near	 03A8	  _TEXT	Length= 005E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  result . . . . . . . . . . . .	Word	 bp + 0006
ReadNum  . . . . . . . . . . . .	P Near	 12F8	  _TEXT	Length= 0045 Public STDCALL
  result . . . . . . . . . . . .	Word	 bp + 0004
SUBMatrix  . . . . . . . . . . .	P Near	 0208	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  SUBMatrix@Loop . . . . . . . .	L Near	 0242	  _TEXT	
WRITEMatrix  . . . . . . . . . .	P Near	 025B	  _TEXT	Length= 00FB Public STDCALL
  NOME . . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
  handle . . . . . . . . . . . .	Word	 bp - 000A
  create_file  . . . . . . . . .	L Near	 0277	  _TEXT	
  file_opened  . . . . . . . . .	L Near	 0283	  _TEXT	
  WRITEMatrix@ForRow . . . . . .	L Near	 02E3	  _TEXT	
  WRITEMatrix@ForCol . . . . . .	L Near	 02ED	  _TEXT	
  WRITEMatrix@EndForCol  . . . .	L Near	 0330	  _TEXT	
  WRITEMatrix@EndForRow  . . . .	L Near	 0348	  _TEXT	
printf_d_padded  . . . . . . . .	P Near	 150B	  _TEXT	Length= 003E Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  padTo  . . . . . . . . . . . .	Word	 bp + 0006
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_d . . . . . . . . . . . .	P Near	 14E4	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_s . . . . . . . . . . . .	P Near	 149B	  _TEXT	Length= 0022 Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
printf_u . . . . . . . . . . . .	P Near	 14BD	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0006
string_from_sword  . . . . . . .	P Near	 1549	  _TEXT	Length= 002B Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
string_from_word . . . . . . . .	P Near	 1574	  _TEXT	Length= 006E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
  value  . . . . . . . . . . . .	Word	 bp - 0002
  divisor  . . . . . . . . . . .	Word	 bp - 0004
  first  . . . . . . . . . . . .	Byte	 bp - 0005


Symbols:

                N a m e                 Type     Value    Attr

??0001 . . . . . . . . . . . . .	Text   	 , 
??0002 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0004 . . . . . . . . . . . . .	Number	 0000h	 
??0005 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0007 . . . . . . . . . . . . .	Text   	 , 
??0008 . . . . . . . . . . . . .	Text   	 <dx, ax>
??000A . . . . . . . . . . . . .	Number	 0000h	 
??000B . . . . . . . . . . . . .	Text   	 <dx, ax>
??000D . . . . . . . . . . . . .	Text   	 , 
??000E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0010 . . . . . . . . . . . . .	Number	 0000h	 
??0011 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0013 . . . . . . . . . . . . .	Text   	 , 
??0014 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0016 . . . . . . . . . . . . .	Number	 0000h	 
??0017 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0019 . . . . . . . . . . . . .	Text   	 , 
??001A . . . . . . . . . . . . .	Text   	 <dx, ax>
??001C . . . . . . . . . . . . .	Number	 0000h	 
??001D . . . . . . . . . . . . .	Text   	 <dx, ax>
??001F . . . . . . . . . . . . .	Text   	 , 
??0020 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0022 . . . . . . . . . . . . .	Number	 0000h	 
??0023 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0025 . . . . . . . . . . . . .	Text   	 , 
??0026 . . . . . . . . . . . . .	Text   	 <ax>
??0028 . . . . . . . . . . . . .	Number	 0000h	 
??0029 . . . . . . . . . . . . .	Text   	 <ax>
??002B . . . . . . . . . . . . .	Text   	 , 
??002C . . . . . . . . . . . . .	Text   	 <ax>
??002E . . . . . . . . . . . . .	Number	 0000h	 
??002F . . . . . . . . . . . . .	Text   	 <ax>
??0031 . . . . . . . . . . . . .	Text   	 , 
??0032 . . . . . . . . . . . . .	Text   	 <ax>
??0034 . . . . . . . . . . . . .	Number	 0000h	 
??0035 . . . . . . . . . . . . .	Text   	 <ax>
??0037 . . . . . . . . . . . . .	Text   	 , 
??0038 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003A . . . . . . . . . . . . .	Number	 0000h	 
??003B . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003D . . . . . . . . . . . . .	Text   	 , 
??003E . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0040 . . . . . . . . . . . . .	Number	 0000h	 
??0041 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0043 . . . . . . . . . . . . .	Text   	 , 
??0044 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0046 . . . . . . . . . . . . .	Number	 0000h	 
??0047 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0049 . . . . . . . . . . . . .	Text   	 , 
??004A . . . . . . . . . . . . .	Text   	 <dx, ax>
??004C . . . . . . . . . . . . .	Number	 0000h	 
??004D . . . . . . . . . . . . .	Text   	 <dx, ax>
??004F . . . . . . . . . . . . .	Text   	 , 
??0050 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0052 . . . . . . . . . . . . .	Number	 0000h	 
??0053 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0054 . . . . . . . . . . . . .	Number	 0003h	 
??0059 . . . . . . . . . . . . .	Text   	 , 
??005A . . . . . . . . . . . . .	Text   	 <bx, ax>
??005C . . . . . . . . . . . . .	Number	 0000h	 
??005D . . . . . . . . . . . . .	Text   	 <bx, ax>
??005E . . . . . . . . . . . . .	Number	 0003h	 
??0063 . . . . . . . . . . . . .	Text   	 , 
??0064 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0066 . . . . . . . . . . . . .	Number	 0000h	 
??0067 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0068 . . . . . . . . . . . . .	Number	 0004h	 
??006D . . . . . . . . . . . . .	Text   	 , 
??006E . . . . . . . . . . . . .	Text   	 <bx, ax>
??0070 . . . . . . . . . . . . .	Number	 0000h	 
??0071 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0072 . . . . . . . . . . . . .	Number	 0005h	 
??0077 . . . . . . . . . . . . .	Text   	 , 
??0078 . . . . . . . . . . . . .	Text   	 <bx, ax>
??007A . . . . . . . . . . . . .	Number	 0000h	 
??007B . . . . . . . . . . . . .	Text   	 <bx, ax>
??007C . . . . . . . . . . . . .	Number	 0004h	 
??0081 . . . . . . . . . . . . .	Text   	 , 
??0082 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0084 . . . . . . . . . . . . .	Number	 0000h	 
??0085 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0086 . . . . . . . . . . . . .	Number	 0004h	 
??008B . . . . . . . . . . . . .	Text   	 , 
??008C . . . . . . . . . . . . .	Text   	 <bx, ax>
??008E . . . . . . . . . . . . .	Number	 0000h	 
??008F . . . . . . . . . . . . .	Text   	 <bx, ax>
??0091 . . . . . . . . . . . . .	Text   	 , 
??0092 . . . . . . . . . . . . .	Text   	 <ax>
??0094 . . . . . . . . . . . . .	Number	 0000h	 
??0095 . . . . . . . . . . . . .	Text   	 <ax>
??0097 . . . . . . . . . . . . .	Text   	 , 
??0098 . . . . . . . . . . . . .	Text   	 <ax>
??009A . . . . . . . . . . . . .	Number	 0000h	 
??009B . . . . . . . . . . . . .	Text   	 <ax>
??009D . . . . . . . . . . . . .	Text   	 , 
??009E . . . . . . . . . . . . .	Text   	 <ax>
??00A0 . . . . . . . . . . . . .	Number	 0000h	 
??00A1 . . . . . . . . . . . . .	Text   	 <ax>
??00A3 . . . . . . . . . . . . .	Text   	 , 
??00A4 . . . . . . . . . . . . .	Text   	 <ax>
??00A6 . . . . . . . . . . . . .	Number	 0000h	 
??00A7 . . . . . . . . . . . . .	Text   	 <ax>
??00A9 . . . . . . . . . . . . .	Text   	 , 
??00AA . . . . . . . . . . . . .	Text   	 <ax>
??00AC . . . . . . . . . . . . .	Number	 0000h	 
??00AD . . . . . . . . . . . . .	Text   	 <ax>
??00AF . . . . . . . . . . . . .	Text   	 , 
??00B0 . . . . . . . . . . . . .	Text   	 <ax>
??00B2 . . . . . . . . . . . . .	Number	 0000h	 
??00B3 . . . . . . . . . . . . .	Text   	 <ax>
??00B5 . . . . . . . . . . . . .	Text   	 , 
??00B6 . . . . . . . . . . . . .	Text   	 <ax>
??00B8 . . . . . . . . . . . . .	Number	 0000h	 
??00B9 . . . . . . . . . . . . .	Text   	 <ax>
??00BB . . . . . . . . . . . . .	Text   	 , 
??00BC . . . . . . . . . . . . .	Text   	 <ax>
??00BE . . . . . . . . . . . . .	Number	 0000h	 
??00BF . . . . . . . . . . . . .	Text   	 <ax>
??00C1 . . . . . . . . . . . . .	Text   	 , 
??00C2 . . . . . . . . . . . . .	Text   	 <ax>
??00C4 . . . . . . . . . . . . .	Number	 0000h	 
??00C5 . . . . . . . . . . . . .	Text   	 <ax>
??00C7 . . . . . . . . . . . . .	Text   	 , 
??00C8 . . . . . . . . . . . . .	Text   	 <ax>
??00CA . . . . . . . . . . . . .	Number	 0000h	 
??00CB . . . . . . . . . . . . .	Text   	 <ax>
??00CD . . . . . . . . . . . . .	Text   	 , 
??00CE . . . . . . . . . . . . .	Text   	 <ax>
??00D0 . . . . . . . . . . . . .	Number	 0000h	 
??00D1 . . . . . . . . . . . . .	Text   	 <ax>
??00D3 . . . . . . . . . . . . .	Text   	 , 
??00D4 . . . . . . . . . . . . .	Text   	 <ax>
??00D6 . . . . . . . . . . . . .	Number	 0000h	 
??00D7 . . . . . . . . . . . . .	Text   	 <ax>
??00D9 . . . . . . . . . . . . .	Text   	 , 
??00DA . . . . . . . . . . . . .	Text   	 <ax>
??00DC . . . . . . . . . . . . .	Number	 0000h	 
??00DD . . . . . . . . . . . . .	Text   	 <ax>
??00DF . . . . . . . . . . . . .	Text   	 , 
??00E0 . . . . . . . . . . . . .	Text   	 <ax>
??00E2 . . . . . . . . . . . . .	Number	 0000h	 
??00E3 . . . . . . . . . . . . .	Text   	 <ax>
??00E5 . . . . . . . . . . . . .	Text   	 , 
??00E6 . . . . . . . . . . . . .	Text   	 <ax>
??00E8 . . . . . . . . . . . . .	Number	 0000h	 
??00E9 . . . . . . . . . . . . .	Text   	 <ax>
??00EB . . . . . . . . . . . . .	Text   	 , 
??00EC . . . . . . . . . . . . .	Text   	 <ax>
??00EE . . . . . . . . . . . . .	Number	 0000h	 
??00EF . . . . . . . . . . . . .	Text   	 <ax>
??00F1 . . . . . . . . . . . . .	Text   	 , 
??00F2 . . . . . . . . . . . . .	Text   	 <ax>
??00F4 . . . . . . . . . . . . .	Number	 0000h	 
??00F5 . . . . . . . . . . . . .	Text   	 <ax>
??00F7 . . . . . . . . . . . . .	Text   	 , 
??00F8 . . . . . . . . . . . . .	Text   	 <ax>
??00FA . . . . . . . . . . . . .	Number	 0000h	 
??00FB . . . . . . . . . . . . .	Text   	 <ax>
??00FD . . . . . . . . . . . . .	Text   	 , 
??00FE . . . . . . . . . . . . .	Text   	 <ax>
??0100 . . . . . . . . . . . . .	Number	 0000h	 
??0101 . . . . . . . . . . . . .	Text   	 <ax>
??0103 . . . . . . . . . . . . .	Text   	 , 
??0104 . . . . . . . . . . . . .	Text   	 <ax>
??0106 . . . . . . . . . . . . .	Number	 0000h	 
??0107 . . . . . . . . . . . . .	Text   	 <ax>
??0109 . . . . . . . . . . . . .	Text   	 , 
??010A . . . . . . . . . . . . .	Text   	 <ax>
??010C . . . . . . . . . . . . .	Number	 0000h	 
??010D . . . . . . . . . . . . .	Text   	 <ax>
??010F . . . . . . . . . . . . .	Text   	 , 
??0110 . . . . . . . . . . . . .	Text   	 <ax>
??0112 . . . . . . . . . . . . .	Number	 0000h	 
??0113 . . . . . . . . . . . . .	Text   	 <ax>
??0115 . . . . . . . . . . . . .	Text   	 , 
??0116 . . . . . . . . . . . . .	Text   	 <ax>
??0118 . . . . . . . . . . . . .	Number	 0000h	 
??0119 . . . . . . . . . . . . .	Text   	 <ax>
??011B . . . . . . . . . . . . .	Text   	 , 
??011C . . . . . . . . . . . . .	Text   	 <ax>
??011E . . . . . . . . . . . . .	Number	 0000h	 
??011F . . . . . . . . . . . . .	Text   	 <ax>
??0121 . . . . . . . . . . . . .	Text   	 , 
??0122 . . . . . . . . . . . . .	Text   	 <ax>
??0124 . . . . . . . . . . . . .	Number	 0000h	 
??0125 . . . . . . . . . . . . .	Text   	 <ax>
??0127 . . . . . . . . . . . . .	Text   	 , 
??0128 . . . . . . . . . . . . .	Text   	 <ax>
??012A . . . . . . . . . . . . .	Number	 0000h	 
??012B . . . . . . . . . . . . .	Text   	 <ax>
??012D . . . . . . . . . . . . .	Text   	 , 
??012E . . . . . . . . . . . . .	Text   	 <ax>
??0130 . . . . . . . . . . . . .	Number	 0000h	 
??0131 . . . . . . . . . . . . .	Text   	 <ax>
??0133 . . . . . . . . . . . . .	Text   	 , 
??0134 . . . . . . . . . . . . .	Text   	 <ax>
??0136 . . . . . . . . . . . . .	Number	 0000h	 
??0137 . . . . . . . . . . . . .	Text   	 <ax>
??0139 . . . . . . . . . . . . .	Text   	 , 
??013A . . . . . . . . . . . . .	Text   	 <ax>
??013C . . . . . . . . . . . . .	Number	 0000h	 
??013D . . . . . . . . . . . . .	Text   	 <ax>
??013F . . . . . . . . . . . . .	Text   	 , 
??0140 . . . . . . . . . . . . .	Text   	 <ax>
??0142 . . . . . . . . . . . . .	Number	 0000h	 
??0143 . . . . . . . . . . . . .	Text   	 <ax>
??0145 . . . . . . . . . . . . .	Text   	 , 
??0146 . . . . . . . . . . . . .	Text   	 <ax>
??0148 . . . . . . . . . . . . .	Number	 0000h	 
??0149 . . . . . . . . . . . . .	Text   	 <ax>
??014B . . . . . . . . . . . . .	Text   	 , 
??014C . . . . . . . . . . . . .	Text   	 <ax>
??014E . . . . . . . . . . . . .	Number	 0000h	 
??014F . . . . . . . . . . . . .	Text   	 <ax>
??0151 . . . . . . . . . . . . .	Text   	 , 
??0152 . . . . . . . . . . . . .	Text   	 <ax>
??0154 . . . . . . . . . . . . .	Number	 0000h	 
??0155 . . . . . . . . . . . . .	Text   	 <ax>
??0157 . . . . . . . . . . . . .	Text   	 , 
??0158 . . . . . . . . . . . . .	Text   	 <ax>
??015A . . . . . . . . . . . . .	Number	 0000h	 
??015B . . . . . . . . . . . . .	Text   	 <ax>
??015D . . . . . . . . . . . . .	Text   	 , 
??015E . . . . . . . . . . . . .	Text   	 <ax>
??0160 . . . . . . . . . . . . .	Number	 0000h	 
??0161 . . . . . . . . . . . . .	Text   	 <ax>
??0163 . . . . . . . . . . . . .	Text   	 , 
??0164 . . . . . . . . . . . . .	Text   	 <ax>
??0166 . . . . . . . . . . . . .	Number	 0000h	 
??0167 . . . . . . . . . . . . .	Text   	 <ax>
??0169 . . . . . . . . . . . . .	Text   	 , 
??016A . . . . . . . . . . . . .	Text   	 <ax>
??016C . . . . . . . . . . . . .	Number	 0000h	 
??016D . . . . . . . . . . . . .	Text   	 <ax>
??016F . . . . . . . . . . . . .	Text   	 , 
??0170 . . . . . . . . . . . . .	Text   	 <ax>
??0172 . . . . . . . . . . . . .	Number	 0000h	 
??0173 . . . . . . . . . . . . .	Text   	 <ax>
??0175 . . . . . . . . . . . . .	Text   	 , 
??0176 . . . . . . . . . . . . .	Text   	 <ax>
??0178 . . . . . . . . . . . . .	Number	 0000h	 
??0179 . . . . . . . . . . . . .	Text   	 <ax>
??017B . . . . . . . . . . . . .	Text   	 , 
??017C . . . . . . . . . . . . .	Text   	 <ax>
??017E . . . . . . . . . . . . .	Number	 0000h	 
??017F . . . . . . . . . . . . .	Text   	 <ax>
??0181 . . . . . . . . . . . . .	Text   	 , 
??0182 . . . . . . . . . . . . .	Text   	 <ax>
??0184 . . . . . . . . . . . . .	Number	 0000h	 
??0185 . . . . . . . . . . . . .	Text   	 <ax>
??0187 . . . . . . . . . . . . .	Text   	 , 
??0188 . . . . . . . . . . . . .	Text   	 <ax>
??018A . . . . . . . . . . . . .	Number	 0000h	 
??018B . . . . . . . . . . . . .	Text   	 <ax>
??018D . . . . . . . . . . . . .	Text   	 , 
??018E . . . . . . . . . . . . .	Text   	 <ax>
??0190 . . . . . . . . . . . . .	Number	 0000h	 
??0191 . . . . . . . . . . . . .	Text   	 <ax>
??0193 . . . . . . . . . . . . .	Text   	 , 
??0194 . . . . . . . . . . . . .	Text   	 <ax>
??0196 . . . . . . . . . . . . .	Number	 0000h	 
??0197 . . . . . . . . . . . . .	Text   	 <ax>
??0199 . . . . . . . . . . . . .	Text   	 , 
??019A . . . . . . . . . . . . .	Text   	 <dx, ax>
??019C . . . . . . . . . . . . .	Number	 0000h	 
??019D . . . . . . . . . . . . .	Text   	 <dx, ax>
??019F . . . . . . . . . . . . .	Text   	 , 
??01A0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A2 . . . . . . . . . . . . .	Number	 0000h	 
??01A3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A5 . . . . . . . . . . . . .	Text   	 , 
??01A6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A8 . . . . . . . . . . . . .	Number	 0000h	 
??01A9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AB . . . . . . . . . . . . .	Text   	 , 
??01AC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AE . . . . . . . . . . . . .	Number	 0000h	 
??01AF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B1 . . . . . . . . . . . . .	Text   	 , 
??01B2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B4 . . . . . . . . . . . . .	Number	 0000h	 
??01B5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B7 . . . . . . . . . . . . .	Text   	 , 
??01B8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BA . . . . . . . . . . . . .	Number	 0000h	 
??01BB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BD . . . . . . . . . . . . .	Text   	 , 
??01BE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C0 . . . . . . . . . . . . .	Number	 0000h	 
??01C1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C3 . . . . . . . . . . . . .	Text   	 , 
??01C4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C6 . . . . . . . . . . . . .	Number	 0000h	 
??01C7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C9 . . . . . . . . . . . . .	Text   	 , 
??01CA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CC . . . . . . . . . . . . .	Number	 0000h	 
??01CD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CF . . . . . . . . . . . . .	Text   	 , 
??01D0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D2 . . . . . . . . . . . . .	Number	 0000h	 
??01D3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D5 . . . . . . . . . . . . .	Text   	 , 
??01D6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D8 . . . . . . . . . . . . .	Number	 0000h	 
??01D9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DB . . . . . . . . . . . . .	Text   	 , 
??01DC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DE . . . . . . . . . . . . .	Number	 0000h	 
??01DF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E1 . . . . . . . . . . . . .	Text   	 , 
??01E2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E4 . . . . . . . . . . . . .	Number	 0000h	 
??01E5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E7 . . . . . . . . . . . . .	Text   	 , 
??01E8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01EA . . . . . . . . . . . . .	Number	 0000h	 
??01EB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01ED . . . . . . . . . . . . .	Text   	 , 
??01EE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F0 . . . . . . . . . . . . .	Number	 0000h	 
??01F1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F3 . . . . . . . . . . . . .	Text   	 , 
??01F4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F6 . . . . . . . . . . . . .	Number	 0000h	 
??01F7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F9 . . . . . . . . . . . . .	Text   	 , 
??01FA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FC . . . . . . . . . . . . .	Number	 0000h	 
??01FD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FF . . . . . . . . . . . . .	Text   	 , 
??0200 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0202 . . . . . . . . . . . . .	Number	 0000h	 
??0203 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0205 . . . . . . . . . . . . .	Text   	 , 
??0206 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0208 . . . . . . . . . . . . .	Number	 0000h	 
??0209 . . . . . . . . . . . . .	Text   	 <dx, ax>
??020B . . . . . . . . . . . . .	Text   	 , 
??020C . . . . . . . . . . . . .	Text   	 <dx, ax>
??020E . . . . . . . . . . . . .	Number	 0000h	 
??020F . . . . . . . . . . . . .	Text   	 <dx, ax>
??0211 . . . . . . . . . . . . .	Text   	 , 
??0212 . . . . . . . . . . . . .	Text   	 <ax>
??0214 . . . . . . . . . . . . .	Number	 0000h	 
??0215 . . . . . . . . . . . . .	Text   	 <ax>
??0217 . . . . . . . . . . . . .	Text   	 , 
??0218 . . . . . . . . . . . . .	Text   	 <ax>
??021A . . . . . . . . . . . . .	Number	 0000h	 
??021B . . . . . . . . . . . . .	Text   	 <ax>
??021D . . . . . . . . . . . . .	Text   	 , 
??021E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0220 . . . . . . . . . . . . .	Number	 0000h	 
??0221 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0223 . . . . . . . . . . . . .	Text   	 , 
??0224 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0226 . . . . . . . . . . . . .	Number	 0000h	 
??0227 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0229 . . . . . . . . . . . . .	Text   	 , 
??022A . . . . . . . . . . . . .	Text   	 <dx, ax>
??022C . . . . . . . . . . . . .	Number	 0000h	 
??022D . . . . . . . . . . . . .	Text   	 <dx, ax>
@@nao_foi_possivel_abrir_ou_criar_o_arquivo  Byte     035E     _DATA	
@@parametros_nao_reconhecidos_ao_final_do_comando  Byte	    0388     _DATA	
@@parametro  . . . . . . . . . .	Byte	 032E	  _DATA	
@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@Comando . . . . . . . . . . . .	Byte	 0310	  _DATA	
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0003h	 
@MainLoopEnd . . . . . . . . . .	L Near	 008F	  _TEXT	
@Model . . . . . . . . . . . . .	Number	 0002h	 
@SkipPrint . . . . . . . . . . .	L Near	 001D	  _TEXT	
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@ValidCommand  . . . . . . . . .	L Near	 004A	  _TEXT	
@Validate  . . . . . . . . . . .	L Near	 0020	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@como  . . . . . . . . . . . . .	Byte	 031F	  _DATA	
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@desconhecido  . . . . . . . . .	Byte	 0338	  _DATA	
@deve_estar_entre_1_e_N  . . . .	Byte	 0347	  _DATA	
@espera  . . . . . . . . . . . .	Byte	 0318	  _DATA	
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@parametro . . . . . . . . . . .	Byte	 0324	  _DATA	
@space . . . . . . . . . . . . .	Byte	 0345	  _DATA	
@stack . . . . . . . . . . . . .	Text   	 DGROUP
@whiletrue . . . . . . . . . . .	L Near	 001A	  _TEXT	
BuffSize . . . . . . . . . . . .	Number	 0064h	 
CLOSE_DELIMITER  . . . . . . . .	Text   	 >
CMD_ADD  . . . . . . . . . . . .	Number	 0003h	 
CMD_DIV  . . . . . . . . . . . .	Number	 0002h	 
CMD_MUL  . . . . . . . . . . . .	Number	 0001h	 
CMD_NONE . . . . . . . . . . . .	Number	 0000h	 
CMD_SUB  . . . . . . . . . . . .	Number	 0004h	 
CMD_UNDO . . . . . . . . . . . .	Number	 0005h	 
CMD_WRITE  . . . . . . . . . . .	Number	 0006h	 
COLON_SPACE  . . . . . . . . . .	Byte	 03B8	  _DATA	
COLUMN_SEP . . . . . . . . . . .	Byte	 0000	  _DATA	
COL_SEPARATOR  . . . . . . . . .	Text   	 SEMI
CRLF . . . . . . . . . . . . . .	Byte	 0002	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
Col  . . . . . . . . . . . . . .	Byte	 03C4	  _DATA	
CommandBufferLength  . . . . . .	Byte	 010C	  _DATA	
CommandBufferString  . . . . . .	Byte	 010D	  _DATA	
CommandBuffer  . . . . . . . . .	Byte	 010B	  _DATA	
ErrorColumnCount . . . . . . . .	L Near	 0D0D	  _TEXT	
ErrorInvalidCommand  . . . . . .	L Near	 11AE	  _TEXT	
ErrorInvalidN  . . . . . . . . .	L Near	 10B4	  _TEXT	
ErrorOpen  . . . . . . . . . . .	L Near	 0C1F	  _TEXT	
ErrorRead  . . . . . . . . . . .	L Near	 0C98	  _TEXT	
ErrorRowCount  . . . . . . . . .	L Near	 0E46	  _TEXT	
ErrorUnexpectedChar  . . . . . .	L Near	 0FFB	  _TEXT	
ExplanationSeparator . . . . . .	Text   	 COLON_SPACE
FileBuffer . . . . . . . . . . .	Byte	 000D	  _DATA	
FileCol  . . . . . . . . . . . .	Word	 03BF	  _DATA	
FileHandle . . . . . . . . . . .	Word	 0071	  _DATA	
FileIsOpen . . . . . . . . . . .	Byte	 0073	  _DATA	
FileLine . . . . . . . . . . . .	Word	 03C1	  _DATA	
FileNameBuffer . . . . . . . . .	Byte	 0074	  _DATA	
FileName . . . . . . . . . . . .	Byte	 0005	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LastCommand@a  . . . . . . . . .	Word	 020C	  _DATA	
LastCommand@b  . . . . . . . . .	Word	 020E	  _DATA	
LastCommand@exists . . . . . . .	Byte	 0210	  _DATA	
LastCommand  . . . . . . . . . .	Byte	 020B	  _DATA	
Matrix . . . . . . . . . . . . .	Word	 03C9	  _DATA	
NPlusOne . . . . . . . . . . . .	Byte	 03C8	  _DATA	
NonTerminalErrorBuffer . . . . .	Byte	 0211	  _DATA	
N  . . . . . . . . . . . . . . .	Byte	 03C7	  _DATA	
OPEN_DELIMITER . . . . . . . . .	Text   	 <
PeekBuffer . . . . . . . . . . .	Byte	 03BB	  _DATA	
QUOT . . . . . . . . . . . . . .	Number	 0022h	 
REG_SET_DELIMITER  . . . . . . .	Text   	 |
RegsInvokeUses . . . . . . . . .	Text   	 ax bx cx dx bp
RegsReturningOnAX  . . . . . . .	Text   	 bx cx dx bp
RegsReturningOnBX  . . . . . . .	Text   	 ax cx dx bp
Row  . . . . . . . . . . . . . .	Byte	 03C3	  _DATA	
SEMI . . . . . . . . . . . . . .	Number	 003Bh	 
SPACE  . . . . . . . . . . . . .	Number	 0020h	 
TheUnexpectedChar  . . . . . . .	Byte	 03BC	  _DATA	
TotalCol . . . . . . . . . . . .	Byte	 03C6	  _DATA	
TotalRow . . . . . . . . . . . .	Byte	 03C5	  _DATA	
caractere  . . . . . . . . . . .	Byte	 010A	  _DATA	
regStack . . . . . . . . . . . .	Text   	 
size_s . . . . . . . . . . . . .	Number	 0000h	 

	   0 Warnings
	   0 Errors
