Microsoft (R) Macro Assembler Version 6.11		    12/15/25 10:06:38
							     First Pass 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					WRITEMatrix proto near, NOME:ptr byte
					PrintMatrix proto near
				;====================================================================
				; Memory
						.stack
 0000						.data
					
					CMD_NONE  EQU 0
					CMD_MUL   EQU 1
					CMD_DIV   EQU 2
					CMD_ADD   EQU 3
					CMD_SUB   EQU 4
					CMD_UNDO  EQU 5
					CMD_WRITE EQU 6
					CR            equ 0dh
					LF            equ 0ah
					QUOT          equ 22h
					SEMI          equ 3Bh
					COL_SEPARATOR equ SEMI
					SPACE         equ 20h
					COLUMN_SEP db ";",0
					CRLF       db CR, LF, 0
					BuffSize       equ 100              ; tam. m√°ximo dos dados lidos no buffer
					FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
					FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
					FileHandle     dw  0                ; Handler do arquivo
					FileIsOpen     db  0                ; closed at the start
					FileNameBuffer db  150 dup (?)
					caractere      db  0
					CommandBuffer       db 254
					CommandBufferLength db 0          ; max length, actual length
					CommandBufferString db 254 dup(0)
					LastCommand   db 0
					LastCommand@a dw 0
					LastCommand@b sword 0
					LastCommand@exists db 0
					NonTerminalErrorBuffer db 255 dup(0)
					@Comando      db "Comando",0
					@espera       db "espera",0
					@como         db "como",0
					@parametro    db "parametro",0
					@@parametro   db "Parametro",0
					@desconhecido db "desconhecido",0
					@space        db " ",0
					@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
					@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
					@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
					
					COLON_SPACE db ": ",0
					ExplanationSeparator textequ <COLON_SPACE>
					; Used on PeekChar
					PeekBuffer        db ?
					; Used when reporting the error
					TheUnexpectedChar db 0,QUOT,0
					; used in main
					FileCol           dw 1
					FileLine          dw 1
					Row      byte 0
					Col      byte 0
					TotalRow byte 0
					TotalCol byte 0
					N        byte 0
					NPlusOne byte 0
					; should be at most 7x7
					Matrix   sword (7 * 7) dup (?)
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
					OPEN_DELIMITER    textequ <!<>
					CLOSE_DELIMITER   textequ <!>>
					REG_SET_DELIMITER textequ <|>
					regStack textequ <> ; starts empty
					__popRegs macro
						regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else
							regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif
						exitm regs
					endm
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else
							regStack catstr regs, REG_SET_DELIMITER, regStack
						endif
					endm
					SaveRegs macro regs:vararg
						comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
					RestoreRegs macro
					%	for reg, __popRegs(regStack) 
							pop reg
						endm
					endm
					RegsInvokeUses textequ <ax bx cx dx bp>
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
						SaveRegs ax, dx
						mov      ah, 02h
						mov      dl, c
						int      21h
						RestoreRegs
					endm
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h
						forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0
					endm
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif
						ifdifi <dst>, <di>
							lea di, dst
						endif
						.repeat
							mov al,   [si]
							mov [di], al
							inc si
							inc di
						.until (al == 0)
						dec    si
						dec    di
						RestoreRegs
					endm
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> 
						ELSE
							EXITM <0> 
						ENDIF
					ENDM
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif
						for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				;--------------------------------------------------------------------
				; Miscellaneous
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
					endm
					CloseFileHandle macro
						mov ah, 3eh
						mov bx, FileHandle
						int 21h
						
						mov FileIsOpen, 0 ; 0 means it is now closed
					endm
					CurrentIndexToBx macro
						; returns in bx
						SaveRegs ax
						mov      al, TotalCol
						inc      al           ; TotalCol starts at 0
						mov bl, Row
						mov bh, Col
						mul bl
						add al, bh
						; got index, find position in array
						shl ax, 1
						add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				;====================================================================
				; Program
 0000					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
			     1			SaveRegs ax, dx
			     2			??0001     textequ <>
			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0002 catstr <ax>, ??0001, ??0002
			     3				??0001 catstr <, >
			     3				push  dx
			     3				??0002 catstr <dx>, ??0001, ??0002
			     3				??0001 catstr <, >
			     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
			     3				??0005     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)      
			     3				regStack substr regStack, (??0004 + 1)     
			     3			endif
			     3			exitm ??0005
			     2		for ??0003, <dx, ax> 
			     2				pop ??0003
			     2			endm
			     3				pop dx
			     3				pop ax
							putc   LF
			     1			SaveRegs ax, dx
			     2			??0007     textequ <>
			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0008 catstr <ax>, ??0007, ??0008
			     3				??0007 catstr <, >
			     3				push  dx
			     3				??0008 catstr <dx>, ??0007, ??0008
			     3				??0007 catstr <, >
			     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
			     3				??000B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)      
			     3				regStack substr regStack, (??000A + 1)     
			     3			endif
			     3			exitm ??000B
			     2		for ??0009, <dx, ax> 
			     2				pop ??0009
			     2			endm
			     3				pop dx
			     3				pop ax
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
						.if (ax == CMD_ADD)
							call Main@ADD
							jmp  @MainLoopEnd
						.elseif  (ax == CMD_MUL)
							call Main@MUL
							jmp  @MainLoopEnd
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
							jmp  @MainLoopEnd
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							jmp  @SkipPrint
						.endif
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
			     1			SaveRegs ax, dx
			     2			??000D     textequ <>
			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
			     3				push  ax
			     3				??000E catstr <ax>, ??000D, ??000E
			     3				??000D catstr <, >
			     3				push  dx
			     3				??000E catstr <dx>, ??000D, ??000E
			     3				??000D catstr <, >
			     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
			     3				??0011     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)      
			     3				regStack substr regStack, (??0010 + 1)     
			     3			endif
			     3			exitm ??0011
			     2		for ??000F, <dx, ax> 
			     2				pop ??000F
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??0013     textequ <>
			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0014 catstr <ax>, ??0013, ??0014
			     3				??0013 catstr <, >
			     3				push  dx
			     3				??0014 catstr <dx>, ??0013, ??0014
			     3				??0013 catstr <, >
			     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
			     3				??0017     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)      
			     3				regStack substr regStack, (??0016 + 1)     
			     3			endif
			     3			exitm ??0017
			     2		for ??0015, <dx, ax> 
			     2				pop ??0015
			     2			endm
			     3				pop dx
			     3				pop ax
					jmp @whiletrue
 0153					Main@ADD proc near
						mov LastCommand,        CMD_ADD
						mov bh,                 0
						mov LastCommand@a,      bx
						mov ch,                 0
						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
						invoke ADDMatrix, bl, cl
						ret
 017A					Main@ADD endp
 017A					Main@MUL proc near
						mov LastCommand,        CMD_MUL
						mov bh,                 0
						mov LastCommand@a,      bx
						mov LastCommand@b,      sword ptr cx
						mov LastCommand@exists, 1
						invoke MULMatrix, bl, cx
						ret
 019D					Main@MUL endp
 019D					Main@UNDO proc near
						mov al, LastCommand@exists
						.if !al
							jmp @MainLoopEnd
						.endif
						mov al,           LastCommand
						mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
						.if (al == CMD_ADD)
							invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
						.elseif (al == CMD_MUL)
							invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
							mov LastCommand, CMD_ADD
						.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
							mov LastCommand, CMD_MUL
						.endif
						ret
 028B					Main@UNDO  endp
 028B					Main@WRITE proc near
						invoke WRITEMatrix, dx
						ret
 0297					Main@WRITE endp
				;====================================================================
				; MUL
 0297					MULMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						MULMatrix@Loop:
							mov  ax,             sword ptr [bx]
							imul CONSTANTE
							mov  sword ptr [bx], ax
							add  bx, 2
							loop MULMatrix@Loop
						ret
 02CE					MULMatrix endp
 02CE					DIVMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
							mov ax, sword ptr [bx]
							cwd                    ; extend sign to dx
							
							idiv CONSTANTE
							
							mov sword ptr [bx], ax
							add  bx, 2
							loop DIVMatrix@Loop
						ret
 0306					DIVMatrix endp
				;====================================================================
				; ADD
 0306					ADDMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						ADDMatrix@Loop:
							mov ax,   [di]
							add ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop ADDMatrix@Loop
						ret
 0359					ADDMatrix endp
 0359					SUBMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						SUBMatrix@Loop:
							mov ax,   [di]
							sub ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop SUBMatrix@Loop
						ret
 03AC					SUBMatrix endp
				;====================================================================
				; WRITE
					WriteToFile macro handle:req, offset_buf:req, len:req
						SaveRegs bx, cx, dx
						mov cx, len
						mov bx, handle
						lea dx, offset_buf
						mov ah, 40h
						int 21h
						RestoreRegs
					endm
 03AC					WRITEMatrix proc near uses ax bx cx dx bp di si, NOME:ptr byte
						local buf[7]:byte, handle:word
						mov   ah,          3Dh         ; open
						mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
						jc    create_file              ; if not exists
						mov bx, ax      ; BX = file handle
						jmp file_opened
						create_file:
						mov ah, 3Ch  ; create
						mov cx, 0
						mov dx, NOME
						int 21h
						mov bx, ax
						file_opened:
						mov ah, 42h
						mov al, 02h ; SEEK_END
						xor cx, cx
						xor dx, dx
						int 21h
						.if (carry?)
							ErrorCantOpenNorCreate
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     4			SaveRegs ax
			     5			??0019     textequ <>
			     5			??001A textequ <>
			     5			for       ??0018, <ax>
			     5				push  ??0018
			     5				??001A catstr <??0018>, ??0019, ??001A
			     5				??0019 catstr <, >
			     5			endm
			     6				push  ax
			     6				??001A catstr <ax>, ??0019, ??001A
			     6				??0019 catstr <, >
			     5			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
			     5			__pushRegs ??001A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??001A
			     6			else
			     6				regStack catstr ??001A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>_po
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??001C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??001C eq 0
			     6				??001D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??001D substr regStack, 1, (??001C - 1)      
			     6				regStack substr regStack, (??001C + 1)     
			     6			endif
			     6			exitm ??001D
			     5		for ??001B, <ax> 
			     5				pop ??001B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di ??000
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??001F     textequ <>
			     5			??0020 textequ <>
			     5			for       ??001E, <ax>
			     5				push  ??001E
			     5				??0020 catstr <??001E>, ??001F, ??0020
			     5				??001F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0020 catstr <ax>, ??001F, ??0020
			     6				??001F catstr <, >
			     5			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
			     5			__pushRegs ??0020
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0020
			     6			else
			     6				regStack catstr ??0020, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0022 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0022 eq 0
			     6				??0023     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0023 substr regStack, 1, (??0022 - 1)      
			     6				regStack substr regStack, (??0022 + 1)     
			     6			endif
			     6			exitm ??0023
			     5		for ??0021, <ax> 
			     5				pop ??0021
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, diu_cria
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0026 catstr <ax>, ??0025, ??0026
			     6				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
			     5			__pushRegs ??0026
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0028 eq 0
			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)      
			     6				regStack substr regStack, (??0028 + 1)     
			     6			endif
			     6			exitm ??0029
			     5		for ??0027, <ax> 
			     5				pop ??0027
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, diu_cri
			     3				endif
							stc
							ret
						.endif
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
								jge WRITEMatrix@EndForCol
								.if (bl) ; no longer firstCol?
									WriteToFile handle, COLUMN_SEP, 1
			     1			SaveRegs bx, cx, dx
			     2			??002B     textequ <>
			     2			??002C textequ <>
			     2			for       ??002A, <bx,cx,dx>
			     2				push  ??002A
			     2				??002C catstr <??002A>, ??002B, ??002C
			     2				??002B catstr <, >
			     2			endm
			     3				push  bx
			     3				??002C catstr <bx>, ??002B, ??002C
			     3				??002B catstr <, >
			     3				push  cx
			     3				??002C catstr <cx>, ??002B, ??002C
			     3				??002B catstr <, >
			     3				push  dx
			     3				??002C catstr <dx>, ??002B, ??002C
			     3				??002B catstr <, >
			     2			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
			     2			__pushRegs ??002C
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??002C
			     3			else
			     3				regStack catstr ??002C, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 1
			     1			mov bx, handle
			     1			lea dx, COLUMN_SEP
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??002E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??002E eq 0
			     3				??002F     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??002F substr regStack, 1, (??002E - 1)tstr <
			     3				regStack substr regStack, (??002E + 1)tstr 
			     3			endif
			     3			exitm ??002F
			     2		for ??002D, <dx, cx, bx> 
			     2				pop ??002D
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								.endif
								mov ax, sword ptr [di]
								invoke string_from_sword, addr buf, ax ; ax now has length
								WriteToFile handle, buf, ax
			     1			SaveRegs bx, cx, dx
			     2			??0031     textequ <>
			     2			??0032 textequ <>
			     2			for       ??0030, <bx,cx,dx>
			     2				push  ??0030
			     2				??0032 catstr <??0030>, ??0031, ??0032
			     2				??0031 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0032 catstr <bx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     3				push  cx
			     3				??0032 catstr <cx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     3				push  dx
			     3				??0032 catstr <dx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     2			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
			     2			__pushRegs ??0032
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0032
			     3			else
			     3				regStack catstr ??0032, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, ax
			     1			mov bx, handle
			     1			lea dx, buf
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??0034 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0034 eq 0
			     3				??0035     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0035 substr regStack, 1, (??0034 - 1)      
			     3				regStack substr regStack, (??0034 + 1)     
			     3			endif
			     3			exitm ??0035
			     2		for ??0033, <dx, cx, bx> 
			     2				pop ??0033
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								add di, 2 ; size in bytes of a sword
								mov bl, 1 ; no longer first col
								inc cl    ; col ++
								
								jmp WRITEMatrix@ForCol
							WRITEMatrix@EndForCol:
							WriteToFile handle, CRLF, 2
			     1			SaveRegs bx, cx, dx
			     2			??0037     textequ <>
			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0038 catstr <bx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  cx
			     3				??0038 catstr <cx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  dx
			     3				??0038 catstr <dx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 2
			     1			mov bx, handle
			     1			lea dx, CRLF
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
			     3				??003B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)			??0
			     3				regStack substr regStack, (??003A + 1)			??
			     3			endif
			     3			exitm ??003B
			     2		for ??0039, <dx, cx, bx> 
			     2				pop ??0039
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
							inc ch ; row++
							
							jmp WRITEMatrix@ForRow
						WRITEMatrix@EndForRow:
						; closeFile
						mov ah, 3eh
						mov bx, handle
						int 21h
						; Reset Disk
						mov ah, 0Dh
						int 21h
						clc
						ret
 0526					WRITEMatrix endp
				;====================================================================
				; Exiting
 0526					ExitSuccess proc near
						mov al, 0
						jmp ExitAndClose
						ret
 0533					ExitSuccess endp
 0533					ExitFailure proc near
						mov al, 1
						jmp ExitAndClose
						ret
 0540					ExitFailure endp
 0540					ExitAndClose proc near
						.if (FileIsOpen)
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						.endif
						.exit
						ret
 0568					ExitAndClose endp
				;====================================================================
				; Reading input
 0568					ReadCommand proc near uses si
						mov dx, offset CommandBuffer
						mov ah, 0Ah
						int 21h
						mov si, offset CommandBufferString
						mov bh, 0
						mov bl, CommandBufferLength
						
						mov byte ptr [CommandBufferString+bx], 0
						putc CR
			     1			SaveRegs ax, dx
			     2			??003D     textequ <>
			     2			??003E textequ <>
			     2			for       ??003C, <ax,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
			     3				push  ax
			     3				??003E catstr <ax>, ??003D, ??003E
			     3				??003D catstr <, >
			     3				push  dx
			     3				??003E catstr <dx>, ??003D, ??003E
			     3				??003D catstr <, >
			     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
			     3				??0041     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)			??0
			     3				regStack substr regStack, (??0040 + 1)			??
			     3			endif
			     3			exitm ??0041
			     2		for ??003F, <dx, ax> 
			     2				pop ??003F
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??0043     textequ <>
			     2			??0044 textequ <>
			     2			for       ??0042, <ax,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0044 catstr <ax>, ??0043, ??0044
			     3				??0043 catstr <, >
			     3				push  dx
			     3				??0044 catstr <dx>, ??0043, ??0044
			     3				??0043 catstr <, >
			     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
			     3				??0047     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)      
			     3				regStack substr regStack, (??0046 + 1)     
			     3			endif
			     3			exitm ??0047
			     2		for ??0045, <dx, ax> 
			     2				pop ??0045
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke ParseCommand
						ret
 059E					ReadCommand endp
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
						SaveRegs ax, bx
						i = 0
						
						mov bx, memString
						
						forc char, <constStr>
							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
							cmp al, '&char'
							jne @@ne
							i = i + 1
						endm 
						mov ax, 1
						jmp @@done
						@@ne:
							mov ax, 0
						@@done:
							cmp ax, 0
							RestoreRegs
					endm
					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw
					endm
					; Return the value read in result, and the end of the string read in si
 059E					ReadNumFromString proc near uses ax bx cx dx bp, string:ptr byte, result:ptr sword
						mov ax, 0
						mov bx, 0
						mov si, string
						mov cx, 0
						.if byte ptr [si] == '-'
							inc si
							mov cx, 1
						.endif
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
							mov dx, 10
							mul dx
							mov bl, [si]
							sub bl, '0'
							add ax, bx
							inc si
						.endw
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
						.if (cx)
							neg ax
						.endif
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
 065C					ReadNumFromString endp
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)
							stc
						.else
							mov resultReg, numberInMemory
							clc
						.endif
					endm
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
						
						.if (!zero?)
							add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif
					endm
					;   AX = command ID (CMD_*)
					;   BX = param1 (if any)
					;   CX = param2 (if any)
					;   DX = offset of string (WRITE)
 065C					ParseCommand proc near uses si di bp
						local a:sword
						mov si, offset CommandBufferString
						
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
			     1			StartsWith <MUL> si
			     2			SaveRegs ax, bx
			     3			??004D     textequ <>
			     3			??004E textequ <>
			     3			for       ??004C, <ax,bx>
			     3				push  ??004C
			     3				??004E catstr <??004C>, ??004D, ??004E
			     3				??004D catstr <, >
			     3			endm
			     4				push  ax
			     4				??004E catstr <ax>, ??004D, ??004E
			     4				??004D catstr <, >
			     4				push  bx
			     4				??004E catstr <bx>, ??004D, ??004E
			     4				??004D catstr <, >
			     3			??004E catstr OPEN_DELIMITER, ??004E, CLOSE_DELIMITER
			     3			__pushRegs ??004E
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??004E
			     4			else
			     4				regStack catstr ??004E, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0048 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0048]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??004A
			     2				??0048 = ??0048 + 1
			     2			endm 
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'M'
			     3				jne ??004A
			     3	
 = 0001			     3				??0048 = ??0048 + 1
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??004A
			     3	
 = 0002			     3				??0048 = ??0048 + 1
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'L'
			     3				jne ??004A
			     3	
 = 0003			     3				??0048 = ??0048 + 1
			     2			mov ax, 1
			     2			jmp ??004B
			     2			??004A:
			     2				mov ax, 0
			     2			??004B:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0050 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0050 eq 0
			     4				??0051     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0051 substr regStack, 1, (??0050 - 1)      
			     4				regStack substr regStack, (??0050 + 1)     
			     4			endif
			     4			exitm ??0051
			     3		for ??004F, <bx, ax> 
			     3				pop ??004F
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@MUL
			     1			.endif
						jumpIfSIComparesTo <ADD> ParseCommand@ADD
			     1			StartsWith <ADD> si
			     2			SaveRegs ax, bx
			     3			??0057     textequ <>
			     3			??0058 textequ <>
			     3			for       ??0056, <ax,bx>
			     3				push  ??0056
			     3				??0058 catstr <??0056>, ??0057, ??0058
			     3				??0057 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0058 catstr <ax>, ??0057, ??0058
			     4				??0057 catstr <, >
			     4				push  bx
			     4				??0058 catstr <bx>, ??0057, ??0058
			     4				??0057 catstr <, >
			     3			??0058 catstr OPEN_DELIMITER, ??0058, CLOSE_DELIMITER
			     3			__pushRegs ??0058
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0058
			     4			else
			     4				regStack catstr ??0058, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0052 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??0052]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0054
			     2				??0052 = ??0052 + 1
			     2			endm 
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'A'
			     3				jne ??0054
			     3	
 = 0001			     3				??0052 = ??0052 + 1
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0054
			     3	
 = 0002			     3				??0052 = ??0052 + 1
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0054
			     3	
 = 0003			     3				??0052 = ??0052 + 1
			     2			mov ax, 1
			     2			jmp ??0055
			     2			??0054:
			     2				mov ax, 0
			     2			??0055:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??005A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005A eq 0
			     4				??005B     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??005B substr regStack, 1, (??005A - 1)??0043
			     4				regStack substr regStack, (??005A + 1)??004
			     4			endif
			     4			exitm ??005B
			     3		for ??0059, <bx, ax> 
			     3				pop ??0059
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@ADD
			     1			.endif
						jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
			     1			StartsWith <UNDO> si
			     2			SaveRegs ax, bx
			     3			??0061     textequ <>
			     3			??0062 textequ <>
			     3			for       ??0060, <ax,bx>
			     3				push  ??0060
			     3				??0062 catstr <??0060>, ??0061, ??0062
			     3				??0061 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0062 catstr <ax>, ??0061, ??0062
			     4				??0061 catstr <, >
			     4				push  bx
			     4				??0062 catstr <bx>, ??0061, ??0062
			     4				??0061 catstr <, >
			     3			??0062 catstr OPEN_DELIMITER, ??0062, CLOSE_DELIMITER
			     3			__pushRegs ??0062
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0062
			     4			else
			     4				regStack catstr ??0062, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??005C = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??005C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??005E
			     2				??005C = ??005C + 1
			     2			endm 
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??005E
			     3	
 = 0001			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'N'
			     3				jne ??005E
			     3	
 = 0002			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??005E
			     3	
 = 0003			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'O'
			     3				jne ??005E
			     3	
 = 0004			     3				??005C = ??005C + 1
			     2			mov ax, 1
			     2			jmp ??005F
			     2			??005E:
			     2				mov ax, 0
			     2			??005F:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0064 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0064 eq 0
			     4				??0065     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0065 substr regStack, 1, (??0064 - 1)      
			     4				regStack substr regStack, (??0064 + 1)     
			     4			endif
			     4			exitm ??0065
			     3		for ??0063, <bx, ax> 
			     3				pop ??0063
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@UNDO
			     1			.endif
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
			     1			StartsWith <WRITE> si
			     2			SaveRegs ax, bx
			     3			??006B     textequ <>
			     3			??006C textequ <>
			     3			for       ??006A, <ax,bx>
			     3				push  ??006A
			     3				??006C catstr <??006A>, ??006B, ??006C
			     3				??006B catstr <, >
			     3			endm
			     4				push  ax
			     4				??006C catstr <ax>, ??006B, ??006C
			     4				??006B catstr <, >
			     4				push  bx
			     4				??006C catstr <bx>, ??006B, ??006C
			     4				??006B catstr <, >
			     3			??006C catstr OPEN_DELIMITER, ??006C, CLOSE_DELIMITER
			     3			__pushRegs ??006C
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??006C
			     4			else
			     4				regStack catstr ??006C, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0066 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0066]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0068
			     2				??0066 = ??0066 + 1
			     2			endm 
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'W'
			     3				jne ??0068
			     3	
 = 0001			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'R'
			     3				jne ??0068
			     3	
 = 0002			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0068
			     3	
 = 0003			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0068
			     3	
 = 0004			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??0068
			     3	
 = 0005			     3				??0066 = ??0066 + 1
			     2			mov ax, 1
			     2			jmp ??0069
			     2			??0068:
			     2				mov ax, 0
			     2			??0069:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??006E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??006E eq 0
			     4				??006F     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??006F substr regStack, 1, (??006E - 1)      
			     4				regStack substr regStack, (??006E + 1)     
			     4			endif
			     4			exitm ??006F
			     3		for ??006D, <bx, ax> 
			     3				pop ??006D
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 05
			     1				jmp ParseCommand@WRITE
			     1			.endif
						jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
			     1			StartsWith <EXIT> si
			     2			SaveRegs ax, bx
			     3			??0075     textequ <>
			     3			??0076 textequ <>
			     3			for       ??0074, <ax,bx>
			     3				push  ??0074
			     3				??0076 catstr <??0074>, ??0075, ??0076
			     3				??0075 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0076 catstr <ax>, ??0075, ??0076
			     4				??0075 catstr <, >
			     4				push  bx
			     4				??0076 catstr <bx>, ??0075, ??0076
			     4				??0075 catstr <, >
			     3			??0076 catstr OPEN_DELIMITER, ??0076, CLOSE_DELIMITER
			     3			__pushRegs ??0076
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0076
			     4			else
			     4				regStack catstr ??0076, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0070 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??0070]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0072
			     2				??0070 = ??0070 + 1
			     2			endm 
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??0072
			     3	
 = 0001			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'X'
			     3				jne ??0072
			     3	
 = 0002			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0072
			     3	
 = 0003			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0072
			     3	
 = 0004			     3				??0070 = ??0070 + 1
			     2			mov ax, 1
			     2			jmp ??0073
			     2			??0072:
			     2				mov ax, 0
			     2			??0073:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0078 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0078 eq 0
			     4				??0079     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0079 substr regStack, 1, (??0078 - 1)DELIMI
			     4				regStack substr regStack, (??0078 + 1)DELIM
			     4			endif
			     4			exitm ??0079
			     3		for ??0077, <bx, ax> 
			     3				pop ??0077
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
						jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
			     1			StartsWith <QUIT> si
			     2			SaveRegs ax, bx
			     3			??007F     textequ <>
			     3			??0080 textequ <>
			     3			for       ??007E, <ax,bx>
			     3				push  ??007E
			     3				??0080 catstr <??007E>, ??007F, ??0080
			     3				??007F catstr <, >
			     3			endm
			     4				push  ax
			     4				??0080 catstr <ax>, ??007F, ??0080
			     4				??007F catstr <, >
			     4				push  bx
			     4				??0080 catstr <bx>, ??007F, ??0080
			     4				??007F catstr <, >
			     3			??0080 catstr OPEN_DELIMITER, ??0080, CLOSE_DELIMITER
			     3			__pushRegs ??0080
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0080
			     4			else
			     4				regStack catstr ??0080, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??007A = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??007A]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007C
			     2				??007A = ??007A + 1
			     2			endm 
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'Q'
			     3				jne ??007C
			     3	
 = 0001			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??007C
			     3	
 = 0002			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??007C
			     3	
 = 0003			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??007C
			     3	
 = 0004			     3				??007A = ??007A + 1
			     2			mov ax, 1
			     2			jmp ??007D
			     2			??007C:
			     2				mov ax, 0
			     2			??007D:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0082 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0082 eq 0
			     4				??0083     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0083 substr regStack, 1, (??0082 - 1)      
			     4				regStack substr regStack, (??0082 + 1)     
			     4			endif
			     4			exitm ??0083
			     3		for ??0081, <bx, ax> 
			     3				pop ??0081
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
					
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			??0085     textequ <>
			     4			??0086 textequ <>
			     4			for       ??0084, <ax>
			     4				push  ??0084
			     4				??0086 catstr <??0084>, ??0085, ??0086
			     4				??0085 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0086 catstr <ax>, ??0085, ??0086
			     5				??0085 catstr <, >
			     4			??0086 catstr OPEN_DELIMITER, ??0086, CLOSE_DELIMITER
			     4			__pushRegs ??0086
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0086
			     5			else
			     5				regStack catstr ??0086, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@Comando>, <si>
			     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>>, 
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??0088 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0088 eq 0
			     5				??0089     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??0089 substr regStack, 1, (??0088 - 1)      
			     5				regStack substr regStack, (??0088 + 1)     
			     5			endif
			     5			exitm ??0089
			     4		for ??0087, <ax> 
			     4				pop ??0087
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di      
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			??008B     textequ <>
			     4			??008C textequ <>
			     4			for       ??008A, <ax>
			     4				push  ??008A
			     4				??008C catstr <??008A>, ??008B, ??008C
			     4				??008B catstr <, >
			     4			endm
			     5				push  ax
			     5				??008C catstr <ax>, ??008B, ??008C
			     5				??008B catstr <, >
			     4			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     4			__pushRegs ??008C
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??008C
			     5			else
			     5				regStack catstr ??008C, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@space>, <si>
			     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii> <s
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??008E instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??008E eq 0
			     5				??008F     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??008F substr regStack, 1, (??008E - 1)      
			     5				regStack substr regStack, (??008E + 1)     
			     5			endif
			     5			exitm ??008F
			     4		for ??008D, <ax> 
			     4				pop ??008D
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@space>, dii    
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			??0091     textequ <>
			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0092 catstr <ax>, ??0091, ??0092
			     5				??0091 catstr <, >
			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
			     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>cid
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
			     5				??0095     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)      
			     5				regStack substr regStack, (??0094 + 1)     
			     5			endif
			     5			exitm ??0095
			     4		for ??0093, <ax> 
			     4				pop ??0093
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, di      
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??0097     textequ <>
			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0098 catstr <ax>, ??0097, ??0098
			     5				??0097 catstr <, >
			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
			     5				??009B     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)      
			     5				regStack substr regStack, (??009A + 1)     
			     5			endif
			     5			exitm ??009B
			     4		for ??0099, <ax> 
			     4				pop ??0099
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di      
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??009D     textequ <>
			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
			     5				push  ax
			     5				??009E catstr <ax>, ??009D, ??009E
			     5				??009D catstr <, >
			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
			     5				??00A1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)      
			     5				regStack substr regStack, (??00A0 + 1)     
			     5			endif
			     5			exitm ??00A1
			     4		for ??009F, <ax> 
			     4				pop ??009F
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di     
			     2				endif
					ParseCommand@error:
						stc
						ret
					ParseCommand@MUL:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.endif
						
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
						mov ax, CMD_MUL
						jmp ParseCommand@success
					ParseCommand@ADD:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
						mov ax, CMD_ADD
						
						jmp ParseCommand@success
					ParseCommand@UNDO:
						mov ax, CMD_UNDO
						jmp ParseCommand@success
					ParseCommand@WRITE:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
							inc si
						.endw
						jmp ParseCommand@success
					ParseCommand@EXIT:
						jmp ParseCommand@success
					ParseCommand@success:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						.if (byte ptr [si] != 0)
						
							strcpy_all                                          NonTerminalErrorBuffer, \
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			??00A3     textequ <>
			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00A4 catstr <ax>, ??00A3, ??00A4
			     5				??00A3 catstr <, >
			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
			     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ros
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
			     5				??00A7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)      
			     5				regStack substr regStack, (??00A6 + 1)     
			     5			endif
			     5			exitm ??00A7
			     4		for ??00A5, <ax> 
			     4				pop ??00A5
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di      
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??00A9     textequ <>
			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00AA catstr <ax>, ??00A9, ??00AA
			     5				??00A9 catstr <, >
			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
			     5				??00AD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)      
			     5				regStack substr regStack, (??00AC + 1)     
			     5			endif
			     5			exitm ??00AD
			     4		for ??00AB, <ax> 
			     4				pop ??00AB
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, didos_ao
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??00AF     textequ <>
			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
			     5				push  ax
			     5				??00B0 catstr <ax>, ??00AF, ??00B0
			     5				??00AF catstr <, >
			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStacknSepar
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
			     5				??00B3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)      
			     5				regStack substr regStack, (??00B2 + 1)     
			     5			endif
			     5			exitm ??00B3
			     4		for ??00B1, <ax> 
			     4				pop ??00B1
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, didos_a
			     2				endif
							
							jmp ParseCommand@error
						.endif
						clc
						ret
 0D4D					ParseCommand endp
 0D4D					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00B5     textequ <>
			     5			??00B6 textequ <>
			     5			for       ??00B4, <ax>
			     5				push  ??00B4
			     5				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     5				??00B5 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00B6 catstr <ax>, ??00B5, ??00B6
			     6				??00B5 catstr <, >
			     5			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
			     5			__pushRegs ??00B6
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00B6
			     6			else
			     6				regStack catstr ??00B6, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00B8 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00B8 eq 0
			     6				??00B9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00B9 substr regStack, 1, (??00B8 - 1)      
			     6				regStack substr regStack, (??00B8 + 1)     
			     6			endif
			     6			exitm ??00B9
			     5		for ??00B7, <ax> 
			     5				pop ??00B7
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di ??0
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di 
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>  
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00BB     textequ <>
			     5			??00BC textequ <>
			     5			for       ??00BA, <ax>
			     5				push  ??00BA
			     5				??00BC catstr <??00BA>, ??00BB, ??00BC
			     5				??00BB catstr <, >
			     5			endm
			     6				push  ax
			     6				??00BC catstr <ax>, ??00BB, ??00BC
			     6				??00BB catstr <, >
			     5			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
			     5			__pushRegs ??00BC
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00BC
			     6			else
			     6				regStack catstr ??00BC, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00BE instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00BE eq 0
			     6				??00BF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00BF substr regStack, 1, (??00BE - 1)      
			     6				regStack substr regStack, (??00BE + 1)     
			     6			endif
			     6			exitm ??00BF
			     5		for ??00BD, <ax> 
			     5				pop ??00BD
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di ??
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , di di 
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>r ?
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C2 catstr <ax>, ??00C1, ??00C2
			     6				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
			     5			__pushRegs ??00C2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00C4 eq 0
			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)      
			     6				regStack substr regStack, (??00C4 + 1)     
			     6			endif
			     6			exitm ??00C5
			     5		for ??00C3, <ax> 
			     5				pop ??00C3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, dii 
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , di ?
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>⁄  
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C8 catstr <ax>, ??00C7, ??00C8
			     6				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
			     5			__pushRegs ??00C8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00CA eq 0
			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)      
			     6				regStack substr regStack, (??00CA + 1)     
			     6			endif
			     6			exitm ??00CB
			     5		for ??00C9, <ax> 
			     5				pop ??00C9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di??008
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00CE catstr <ax>, ??00CD, ??00CE
			     6				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
			     5			__pushRegs ??00CE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D0 eq 0
			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)      
			     6				regStack substr regStack, (??00D0 + 1)     
			     6			endif
			     6			exitm ??00D1
			     5		for ??00CF, <ax> 
			     5				pop ??00CF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00D4 catstr <ax>, ??00D3, ??00D4
			     6				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
			     5			__pushRegs ??00D4
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D6 eq 0
			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)      
			     6				regStack substr regStack, (??00D6 + 1)     
			     6			endif
			     6			exitm ??00D7
			     5		for ??00D5, <ax> 
			     5				pop ??00D5
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0E99					ParseCommand@LINHA_AUSENTE endp
 0E99					ParseCommand@CONSTANTE_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00DA catstr <ax>, ??00D9, ??00DA
			     6				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
			     5			__pushRegs ??00DA
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00DC eq 0
			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)      
			     6				regStack substr regStack, (??00DC + 1)     
			     6			endif
			     6			exitm ??00DD
			     5		for ??00DB, <ax> 
			     5				pop ??00DB
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di 
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E0 catstr <ax>, ??00DF, ??00E0
			     6				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
			     5			__pushRegs ??00E0
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E2 eq 0
			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)      
			     6				regStack substr regStack, (??00E2 + 1)     
			     6			endif
			     6			exitm ??00E3
			     5		for ??00E1, <ax> 
			     5				pop ??00E1
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  CONSTANTE , di     
			     3				else
			     3					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'C'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E6 catstr <ax>, ??00E5, ??00E6
			     6				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
			     5			__pushRegs ??00E6
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStacktstr <
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E8 eq 0
			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)      
			     6				regStack substr regStack, (??00E8 + 1)     
			     6			endif
			     6			exitm ??00E9
			     5		for ??00E7, <ax> 
			     5				pop ??00E7
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi   
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
			     5			endm
			     6				push  ax
			     6				??00EC catstr <ax>, ??00EB, ??00EC
			     6				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
			     5			__pushRegs ??00EC
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00EE eq 0
			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)      
			     6				regStack substr regStack, (??00EE + 1)     
			     6			endif
			     6			exitm ??00EF
			     5		for ??00ED, <ax> 
			     5				pop ??00ED
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F2 catstr <ax>, ??00F1, ??00F2
			     6				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
			     5			__pushRegs ??00F2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStacktstr <
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00F4 eq 0
			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)      
			     6				regStack substr regStack, (??00F4 + 1)     
			     6			endif
			     6			exitm ??00F5
			     5		for ??00F3, <ax> 
			     5				pop ??00F3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F8 catstr <ax>, ??00F7, ??00F8
			     6				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
			     5			__pushRegs ??00F8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00FA eq 0
			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)20  
			     6				regStack substr regStack, (??00FA + 1)20 
			     6			endif
			     6			exitm ??00FB
			     5		for ??00F9, <ax> 
			     5				pop ??00F9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0FF1					ParseCommand@CONSTANTE_AUSENTE endp
					
 0FF1					ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00FE catstr <ax>, ??00FD, ??00FE
			     6				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
			     5			__pushRegs ??00FE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0100 eq 0
			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)      
			     6				regStack substr regStack, (??0100 + 1)     
			     6			endif
			     6			exitm ??0101
			     5		for ??00FF, <ax> 
			     5				pop ??00FF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, diring>,
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, dir
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>r ?
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0104 catstr <ax>, ??0103, ??0104
			     6				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
			     5			__pushRegs ??0104
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack'   
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0106 eq 0
			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)R, reg
			     6				regStack substr regStack, (??0106 + 1)R, re
			     6			endif
			     6			exitm ??0107
			     5		for ??0105, <ax> 
			     5				pop ??0105
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, diring>
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , diring>
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
			     5			endm
			     6				push  ax
			     6				??010A catstr <ax>, ??0109, ??010A
			     6				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
			     5			__pushRegs ??010A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??010C eq 0
			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)      
			     6				regStack substr regStack, (??010C + 1)     
			     6			endif
			     6			exitm ??010D
			     5		for ??010B, <ax> 
			     5				pop ??010B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didirin
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , diiring
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0110 catstr <ax>, ??010F, ??0110
			     6				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
			     5			__pushRegs ??0110
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0112 eq 0
			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)      
			     6				regStack substr regStack, (??0112 + 1)     
			     6			endif
			     6			exitm ??0113
			     5		for ??0111, <ax> 
			     5				pop ??0111
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, ding>, d
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0116 catstr <ax>, ??0115, ??0116
			     6				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
			     5			__pushRegs ??0116
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0118 eq 0
			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)      
			     6				regStack substr regStack, (??0118 + 1)     
			     6			endif
			     6			exitm ??0119
			     5		for ??0117, <ax> 
			     5				pop ??0117
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
			     5			endm
			     6				push  ax
			     6				??011C catstr <ax>, ??011B, ??011C
			     6				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
			     5			__pushRegs ??011C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??011E eq 0
			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)      
			     6				regStack substr regStack, (??011E + 1)     
			     6			endif
			     6			exitm ??011F
			     5		for ??011D, <ax> 
			     5				pop ??011D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 114D					ParseCommand@LINHA_DST_AUSENTE endp
 114D					ParseCommand@LINHA_ORG_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0122 catstr <ax>, ??0121, ??0122
			     6				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
			     5			__pushRegs ??0122
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0124 eq 0
			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1)      
			     6				regStack substr regStack, (??0124 + 1)     
			     6			endif
			     6			exitm ??0125
			     5		for ??0123, <ax> 
			     5				pop ??0123
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, di 
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>di]
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0128 catstr <ax>, ??0127, ??0128
			     6				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
			     5			__pushRegs ??0128
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??012A eq 0
			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1)      
			     6				regStack substr regStack, (??012A + 1)     
			     6			endif
			     6			exitm ??012B
			     5		for ??0129, <ax> 
			     5				pop ??0129
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di     
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>r ?
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
			     5			endm
			     6				push  ax
			     6				??012E catstr <ax>, ??012D, ??012E
			     6				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
			     5			__pushRegs ??012E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0130 eq 0
			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)      
			     6				regStack substr regStack, (??0130 + 1)     
			     6			endif
			     6			exitm ??0131
			     5		for ??012F, <ax> 
			     5				pop ??012F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi   
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, 
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0134 catstr <ax>, ??0133, ??0134
			     6				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
			     5			__pushRegs ??0134
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0136 eq 0
			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1) ax  
			     6				regStack substr regStack, (??0136 + 1) ax 
			     6			endif
			     6			exitm ??0137
			     5		for ??0135, <ax> 
			     5				pop ??0135
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
			     5			endm
			     6				push  ax
			     6				??013A catstr <ax>, ??0139, ??013A
			     6				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
			     5			__pushRegs ??013A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??013C eq 0
			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)      
			     6				regStack substr regStack, (??013C + 1)     
			     6			endif
			     6			exitm ??013D
			     5		for ??013B, <ax> 
			     5				pop ??013B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0140 catstr <ax>, ??013F, ??0140
			     6				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
			     5			__pushRegs ??0140
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0142 eq 0
			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)      
			     6				regStack substr regStack, (??0142 + 1)     
			     6			endif
			     6			exitm ??0143
			     5		for ??0141, <ax> 
			     5				pop ??0141
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 12A5					ParseCommand@LINHA_ORG_AUSENTE endp
 12A5					ParseCommand@LINHA_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0146 catstr <ax>, ??0145, ??0146
			     6				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
			     5			__pushRegs ??0146
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0148 eq 0
			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)      
			     6				regStack substr regStack, (??0148 + 1)     
			     6			endif
			     6			exitm ??0149
			     5		for ??0147, <ax> 
			     5				pop ??0147
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , diro>, d
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
			     5			endm
			     6				push  ax
			     6				??014C catstr <ax>, ??014B, ??014C
			     6				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
			     5			__pushRegs ??014C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??014E eq 0
			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)      
			     6				regStack substr regStack, (??014E + 1)     
			     6			endif
			     6			exitm ??014F
			     5		for ??014D, <ax> 
			     5				pop ??014D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0152 catstr <ax>, ??0151, ??0152
			     6				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
			     5			__pushRegs ??0152
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0154 eq 0
			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)      
			     6				regStack substr regStack, (??0154 + 1)     
			     6			endif
			     6			exitm ??0155
			     5		for ??0153, <ax> 
			     5				pop ??0153
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0158 catstr <ax>, ??0157, ??0158
			     6				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
			     5			__pushRegs ??0158
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??015A eq 0
			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)      
			     6				regStack substr regStack, (??015A + 1)     
			     6			endif
			     6			exitm ??015B
			     5		for ??0159, <ax> 
			     5				pop ??0159
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 135D					ParseCommand@LINHA_INVALIDA endp
 135D					ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
			     5			endm
			     6				push  ax
			     6				??015E catstr <ax>, ??015D, ??015E
			     6				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
			     5			__pushRegs ??015E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0160 eq 0
			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)DELIMI
			     6				regStack substr regStack, (??0160 + 1)DELIM
			     6			endif
			     6			exitm ??0161
			     5		for ??015F, <ax> 
			     5				pop ??015F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , di di  
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0164 catstr <ax>, ??0163, ??0164
			     6				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
			     5			__pushRegs ??0164
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0166 eq 0
			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)      
			     6				regStack substr regStack, (??0166 + 1)     
			     6			endif
			     6			exitm ??0167
			     5		for ??0165, <ax> 
			     5				pop ??0165
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
			     5			endm
			     6				push  ax
			     6				??016A catstr <ax>, ??0169, ??016A
			     6				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
			     5			__pushRegs ??016A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??016C eq 0
			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)      
			     6				regStack substr regStack, (??016C + 1)     
			     6			endif
			     6			exitm ??016D
			     5		for ??016B, <ax> 
			     5				pop ??016B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0170 catstr <ax>, ??016F, ??0170
			     6				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
			     5			__pushRegs ??0170
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0172 eq 0
			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)      
			     6				regStack substr regStack, (??0172 + 1)     
			     6			endif
			     6			exitm ??0173
			     5		for ??0171, <ax> 
			     5				pop ??0171
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 1425					ParseCommand@LINHA_DST_INVALIDA endp
 1425					ParseCommand@LINHA_ORG_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_ORG>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0176 catstr <ax>, ??0175, ??0176
			     6				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
			     5			__pushRegs ??0176
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0178 eq 0
			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)      
			     6				regStack substr regStack, (??0178 + 1)     
			     6			endif
			     6			exitm ??0179
			     5		for ??0177, <ax> 
			     5				pop ??0177
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, dircpy_c
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di dirc
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
			     5			endm
			     6				push  ax
			     6				??017C catstr <ax>, ??017B, ??017C
			     6				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
			     5			__pushRegs ??017C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??017E eq 0
			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)      
			     6				regStack substr regStack, (??017E + 1)     
			     6			endif
			     6			exitm ??017F
			     5		for ??017D, <ax> 
			     5				pop ??017D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, diandBuf
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0182 catstr <ax>, ??0181, ??0182
			     6				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
			     5			__pushRegs ??0182
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0184 eq 0
			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)      
			     6				regStack substr regStack, (??0184 + 1)     
			     6			endif
			     6			exitm ??0185
			     5		for ??0183, <ax> 
			     5				pop ??0183
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didiand
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0188 catstr <ax>, ??0187, ??0188
			     6				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
			     5			__pushRegs ??0188
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStackT >, @
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??018A eq 0
			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)      
			     6				regStack substr regStack, (??018A + 1)     
			     6			endif
			     6			exitm ??018B
			     5		for ??0189, <ax> 
			     5				pop ??0189
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didian
			     3				endif
						ret
 14ED					ParseCommand@LINHA_ORG_INVALIDA endp
				;====================================================================
				; Reading error reporting
					ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??018D     textequ <>
			     2			??018E textequ <>
			     2			for       ??018C, <ax,dx>
			     2				push  ??018C
			     2				??018E catstr <??018C>, ??018D, ??018E
			     2				??018D catstr <, >
			     2			endm
			     3				push  ax
			     3				??018E catstr <ax>, ??018D, ??018E
			     3				??018D catstr <, >
			     3				push  dx
			     3				??018E catstr <dx>, ??018D, ??018E
			     3				??018D catstr <, >
			     2			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
			     2			__pushRegs ??018E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??018E
			     3			else
			     3				regStack catstr ??018E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??0190 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0190 eq 0
			     3				??0191     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0191 substr regStack, 1, (??0190 - 1)tordi
			     3				regStack substr regStack, (??0190 + 1)tord
			     3			endif
			     3			exitm ??0191
			     2		for ??018F, <dx, ax> 
			     2				pop ??018F
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRead:
						printf_c <Erro na leitura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??0193     textequ <>
			     2			??0194 textequ <>
			     2			for       ??0192, <ax,dx>
			     2				push  ??0192
			     2				??0194 catstr <??0192>, ??0193, ??0194
			     2				??0193 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0194 catstr <ax>, ??0193, ??0194
			     3				??0193 catstr <, >
			     3				push  dx
			     3				??0194 catstr <dx>, ??0193, ??0194
			     3				??0193 catstr <, >
			     2			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
			     2			__pushRegs ??0194
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0194
			     3			else
			     3				regStack catstr ??0194, REG_SET_DELIMITER, regStack?0163,
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??0196 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0196 eq 0
			     3				??0197     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0197 substr regStack, 1, (??0196 - 1)      
			     3				regStack substr regStack, (??0196 + 1)     
			     3			endif
			     3			exitm ??0197
			     2		for ??0195, <dx, ax> 
			     2				pop ??0195
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorColumnCount:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??0199     textequ <>
			     4			??019A textequ <>
			     4			for       ??0198, <ax,dx>
			     4				push  ??0198
			     4				??019A catstr <??0198>, ??0199, ??019A
			     4				??0199 catstr <, >
			     4			endm
			     5				push  ax
			     5				??019A catstr <ax>, ??0199, ??019A
			     5				??0199 catstr <, >
			     5				push  dx
			     5				??019A catstr <dx>, ??0199, ??019A
			     5				??0199 catstr <, >
			     4			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     4			__pushRegs ??019A
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??019A
			     5			else
			     5				regStack catstr ??019A, REG_SET_DELIMITER, regStack?0163,
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??019C instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??019C eq 0
			     5				??019D     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??019D substr regStack, 1, (??019C - 1)      
			     5				regStack substr regStack, (??019C + 1)     
			     5			endif
			     5			exitm ??019D
			     4		for ??019B, <dx, ax> 
			     4				pop ??019B
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??019F     textequ <>
			     4			??01A0 textequ <>
			     4			for       ??019E, <ax,dx>
			     4				push  ??019E
			     4				??01A0 catstr <??019E>, ??019F, ??01A0
			     4				??019F catstr <, >
			     4			endm
			     5				push  ax
			     5				??01A0 catstr <ax>, ??019F, ??01A0
			     5				??019F catstr <, >
			     5				push  dx
			     5				??01A0 catstr <dx>, ??019F, ??01A0
			     5				??019F catstr <, >
			     4			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     4			__pushRegs ??01A0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01A0
			     5			else
			     5				regStack catstr ??01A0, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A2 eq 0
			     5				??01A3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01A3 substr regStack, 1, (??01A2 - 1)??019F
			     5				regStack substr regStack, (??01A2 + 1)??019
			     5			endif
			     5			exitm ??01A3
			     4		for ??01A1, <dx, ax> 
			     4				pop ??01A1
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01A5     textequ <>
			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01A6 catstr <ax>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     5				push  dx
			     5				??01A6 catstr <dx>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
			     5				??01A9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)      
			     5				regStack substr regStack, (??01A8 + 1)     
			     5			endif
			     5			exitm ??01A9
			     4		for ??01A7, <dx, ax> 
			     4				pop ??01A7
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1			SaveRegs ax,   dx
			     2			??01AB     textequ <>
			     2			??01AC textequ <>
			     2			for       ??01AA, <ax,dx>
			     2				push  ??01AA
			     2				??01AC catstr <??01AA>, ??01AB, ??01AC
			     2				??01AB catstr <, >
			     2			endm
			     3				push  ax
			     3				??01AC catstr <ax>, ??01AB, ??01AC
			     3				??01AB catstr <, >
			     3				push  dx
			     3				??01AC catstr <dx>, ??01AB, ??01AC
			     3				??01AB catstr <, >
			     2			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     2			__pushRegs ??01AC
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01AC
			     3			else
			     3				regStack catstr ??01AC, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'g'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??01AE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01AE eq 0
			     3				??01AF     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01AF substr regStack, 1, (??01AE - 1)      
			     3				regStack substr regStack, (??01AE + 1)     
			     3			endif
			     3			exitm ??01AF
			     2		for ??01AD, <dx, ax> 
			     2				pop ??01AD
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRowCount:
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1			SaveRegs ax,   dx
			     2			??01B1     textequ <>
			     2			??01B2 textequ <>
			     2			for       ??01B0, <ax,dx>
			     2				push  ??01B0
			     2				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     2				??01B1 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01B2 catstr <ax>, ??01B1, ??01B2
			     3				??01B1 catstr <, >
			     3				push  dx
			     3				??01B2 catstr <dx>, ??01B1, ??01B2
			     3				??01B1 catstr <, >
			     2			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     2			__pushRegs ??01B2
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01B2
			     3			else
			     3				regStack catstr ??01B2, REG_SET_DELIMITER, regStack?0163,
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '1'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'O'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'f'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01B4 eq 0
			     3				??01B5     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01B5 substr regStack, 1, (??01B4 - 1)      
			     3				regStack substr regStack, (??01B4 + 1)     
			     3			endif
			     3			exitm ??01B5
			     2		for ??01B3, <dx, ax> 
			     2				pop ??01B3
			     2			endm
			     3				pop dx
			     3				pop ax
						print_TotalRowCol
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01B7     textequ <>
			     4			??01B8 textequ <>
			     4			for       ??01B6, <ax,dx>
			     4				push  ??01B6
			     4				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     4				??01B7 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01B8 catstr <ax>, ??01B7, ??01B8
			     5				??01B7 catstr <, >
			     5				push  dx
			     5				??01B8 catstr <dx>, ??01B7, ??01B8
			     5				??01B7 catstr <, >
			     4			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     4			__pushRegs ??01B8
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01B8
			     5			else
			     5				regStack catstr ??01B8, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01BA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01BA eq 0
			     5				??01BB     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01BB substr regStack, 1, (??01BA - 1)      
			     5				regStack substr regStack, (??01BA + 1)     
			     5			endif
			     5			exitm ??01BB
			     4		for ??01B9, <dx, ax> 
			     4				pop ??01B9
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01BD     textequ <>
			     4			??01BE textequ <>
			     4			for       ??01BC, <ax,dx>
			     4				push  ??01BC
			     4				??01BE catstr <??01BC>, ??01BD, ??01BE
			     4				??01BD catstr <, >
			     4			endm
			     5				push  ax
			     5				??01BE catstr <ax>, ??01BD, ??01BE
			     5				??01BD catstr <, >
			     5				push  dx
			     5				??01BE catstr <dx>, ??01BD, ??01BE
			     5				??01BD catstr <, >
			     4			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     4			__pushRegs ??01BE
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01BE
			     5			else
			     5				regStack catstr ??01BE, REG_SET_DELIMITER, regStack?0163,
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C0 eq 0
			     5				??01C1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01C1 substr regStack, 1, (??01C0 - 1)      
			     5				regStack substr regStack, (??01C0 + 1)     
			     5			endif
			     5			exitm ??01C1
			     4		for ??01BF, <dx, ax> 
			     4				pop ??01BF
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01C3     textequ <>
			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01C4 catstr <ax>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     5				push  dx
			     5				??01C4 catstr <dx>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
			     5				??01C7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)      
			     5				regStack substr regStack, (??01C6 + 1)     
			     5			endif
			     5			exitm ??01C7
			     4		for ??01C5, <dx, ax> 
			     4				pop ??01C5
			     4			endm
			     5				pop dx
			     5				pop ax
						jmp      ExitFailure
					ErrorUnexpectedChar:
						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01C9     textequ <>
			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01CA catstr <ax>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     5				push  dx
			     5				??01CA catstr <dx>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
			     5				??01CD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)      
			     5				regStack substr regStack, (??01CC + 1)     
			     5			endif
			     5			exitm ??01CD
			     4		for ??01CB, <dx, ax> 
			     4				pop ??01CB
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01CF     textequ <>
			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D0 catstr <ax>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     5				push  dx
			     5				??01D0 catstr <dx>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
			     5				??01D3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)      
			     5				regStack substr regStack, (??01D2 + 1)     
			     5			endif
			     5			exitm ??01D3
			     4		for ??01D1, <dx, ax> 
			     4				pop ??01D1
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01D5     textequ <>
			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D6 catstr <ax>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     5				push  dx
			     5				??01D6 catstr <dx>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
			     5				??01D9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)      
			     5				regStack substr regStack, (??01D8 + 1)     
			     5			endif
			     5			exitm ??01D9
			     4		for ??01D7, <dx, ax> 
			     4				pop ??01D7
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: caracter inexperado: ">
			     1			SaveRegs ax,   dx
			     2			??01DB     textequ <>
			     2			??01DC textequ <>
			     2			for       ??01DA, <ax,dx>
			     2				push  ??01DA
			     2				??01DC catstr <??01DA>, ??01DB, ??01DC
			     2				??01DB catstr <, >
			     2			endm
			     3				push  ax
			     3				??01DC catstr <ax>, ??01DB, ??01DC
			     3				??01DB catstr <, >
			     3				push  dx
			     3				??01DC catstr <dx>, ??01DB, ??01DC
			     3				??01DB catstr <, >
			     2			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     2			__pushRegs ??01DC
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01DC
			     3			else
			     3				regStack catstr ??01DC, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'x'
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '"'
			     2				int 21h
			     1			RestoreRegs
			     3			??01DE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01DE eq 0
			     3				??01DF     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01DF substr regStack, 1, (??01DE - 1)??01C3
			     3				regStack substr regStack, (??01DE + 1)??01C
			     3			endif
			     3			exitm ??01DF
			     2		for ??01DD, <dx, ax> 
			     2				pop ??01DD
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr TheUnexpectedChar
						jmp ExitFailure
					ErrorInvalidN:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01E1     textequ <>
			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01E2 catstr <ax>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     5				push  dx
			     5				??01E2 catstr <dx>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStackr <, >
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
			     5				??01E5     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)??01E1
			     5				regStack substr regStack, (??01E4 + 1)??01E
			     5			endif
			     5			exitm ??01E5
			     4		for ??01E3, <dx, ax> 
			     4				pop ??01E3
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01E7     textequ <>
			     4			??01E8 textequ <>
			     4			for       ??01E6, <ax,dx>
			     4				push  ??01E6
			     4				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     4				??01E7 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01E8 catstr <ax>, ??01E7, ??01E8
			     5				??01E7 catstr <, >
			     5				push  dx
			     5				??01E8 catstr <dx>, ??01E7, ??01E8
			     5				??01E7 catstr <, >
			     4			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     4			__pushRegs ??01E8
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01E8
			     5			else
			     5				regStack catstr ??01E8, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01EA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01EA eq 0
			     5				??01EB     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01EB substr regStack, 1, (??01EA - 1)1)  
			     5				regStack substr regStack, (??01EA + 1)1) 
			     5			endif
			     5			exitm ??01EB
			     4		for ??01E9, <dx, ax> 
			     4				pop ??01E9
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01ED     textequ <>
			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
			     5				push  ax
			     5				??01EE catstr <ax>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     5				push  dx
			     5				??01EE catstr <dx>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
			     5				??01F1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)      
			     5				regStack substr regStack, (??01F0 + 1)     
			     5			endif
			     5			exitm ??01F1
			     4		for ??01EF, <dx, ax> 
			     4				pop ??01EF
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1			SaveRegs ax,   dx
			     2			??01F3     textequ <>
			     2			??01F4 textequ <>
			     2			for       ??01F2, <ax,dx>
			     2				push  ??01F2
			     2				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     2				??01F3 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01F4 catstr <ax>, ??01F3, ??01F4
			     3				??01F3 catstr <, >
			     3				push  dx
			     3				??01F4 catstr <dx>, ??01F3, ??01F4
			     3				??01F3 catstr <, >
			     2			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     2			__pushRegs ??01F4
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01F4
			     3			else
			     3				regStack catstr ??01F4, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '2'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '7'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01F6 eq 0
			     3				??01F7     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01F7 substr regStack, 1, (??01F6 - 1)      
			     3				regStack substr regStack, (??01F6 + 1)     
			     3			endif
			     3			exitm ??01F7
			     2		for ??01F5, <dx, ax> 
			     2				pop ??01F5
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_u, N
						jmp      ExitFailure
					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
			     1			SaveRegs ax,   dx
			     2			??01F9     textequ <>
			     2			??01FA textequ <>
			     2			for       ??01F8, <ax,dx>
			     2				push  ??01F8
			     2				??01FA catstr <??01F8>, ??01F9, ??01FA
			     2				??01F9 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01FA catstr <ax>, ??01F9, ??01FA
			     3				??01F9 catstr <, >
			     3				push  dx
			     3				??01FA catstr <dx>, ??01F9, ??01FA
			     3				??01F9 catstr <, >
			     2			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     2			__pushRegs ??01FA
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01FA
			     3			else
			     3				regStack catstr ??01FA, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'U'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01FC instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01FC eq 0
			     3				??01FD     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01FD substr regStack, 1, (??01FC - 1)      
			     3				regStack substr regStack, (??01FC + 1)     
			     3			endif
			     3			exitm ??01FD
			     2		for ??01FB, <dx, ax> 
			     2				pop ??01FB
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
				;====================================================================
				; Reading Functions
					HandleCR macro
						invoke PeekChar
						mov    bh, PeekBuffer
						.if    bh != LF
							jmp ErrorUnexpectedChar
						.endif
					endm
					
 1B3E					ReadEmptyLines proc near uses ax bx cx dx bp
						invoke ReadChar
						.while ax != 0
							mov bl, FileBuffer
							.if bl == LF
								inc FileLine
								mov FileCol, 1
							.elseif bl == CR
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.else
								jmp ErrorUnexpectedChar
							.endif
							invoke ReadChar
						.endw
						ret
 1BF6					ReadEmptyLines endp
 1BF6					OpenFile proc near
						SaveRegs ax,         dx
			     1			??01FF     textequ <>
			     1			??0200 textequ <>
			     1			for       ??01FE, <ax,dx>
			     1				push  ??01FE
			     1				??0200 catstr <??01FE>, ??01FF, ??0200
			     1				??01FF catstr <, >
			     1			endm
			     2				push  ax
			     2				??0200 catstr <ax>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     2				push  dx
			     2				??0200 catstr <dx>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     1			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     1			__pushRegs ??0200
			     2			size_s sizestr regStack
			     2			if     size_s eq 0
			     2				regStack catstr ??0200
			     2			else
			     2				regStack catstr ??0200, REG_SET_DELIMITER, regStack      
			     2			endif
						mov      al,         0
						lea      dx,         FileName
						mov      ah,         3dh
						int      21h
						.if (carry?)
							call ErrorOpen
						.endif
						mov      FileHandle, ax
						mov      FileIsOpen, 1
						RestoreRegs
			     2			??0202 instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??0202 eq 0
			     2				??0203     substr regStack, 1
			     2				regStack textequ <>
			     2			else
			     2				??0203 substr regStack, 1, (??0202 - 1)      
			     2				regStack substr regStack, (??0202 + 1)     
			     2			endif
			     2			exitm ??0203
			     1		for ??0201, <dx, ax> 
			     1				pop ??0201
			     1			endm
			     2				pop dx
			     2				pop ax
						ret
 1C18					OpenFile endp
 1C18					ReadChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
						ret
 1C34					ReadChar endp
 1C34					ReadCharTo proc near uses bx cx dx bp, Buffer:ptr byte
						mov dx, Buffer
						mov bx, FileHandle
						mov ah, 3Fh
						mov cx, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						; EOF
						.if ax == 0
							mov bx,           dx
							mov byte ptr[bx], 0
						.endif
						ret
 1C78					ReadCharTo endp
 1C78					MoveBack proc near uses ax bx cx dx bp
						; Move back by one byte
						mov bx, FileHandle
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
						mov al, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						ret
 1C9E					MoveBack endp
 1C9E					PeekChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr PeekBuffer
						invoke MoveBack
						ret
 1CB2					PeekChar endp
 1CB2					ReadNum proc near uses ax bx cx dx bp, result:ptr word
						invoke ReadChar
						mov    ax, 0
						mov    bx, 0
						mov    cx, 10
						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
							mul cx
							sub bl, '0'
							add ax, bx
							push   ax
							invoke ReadChar
							pop    ax
							mov    bl, FileBuffer
						.endw
						invoke MoveBack
						mov bx,           result
						mov word ptr[bx], ax
						ret
 1D21					ReadNum endp
 1D21					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
						ReadMatrixLoop:
							invoke ReadChar
							.if    ax == 0  ; EOF
								mov al,       TotalCol
								inc al                 ; TotalCol starts at 0
								mov NPlusOne, al
								dec al                 ; ax = N
								mov N,        al       ; TotalCol starts at 0
								dec al
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
									jmp ErrorInvalidN
								.endif
								jmp EndReading
							.endif
							mov bl, FileBuffer
							.if bl == 3Bh
								inc Col
							.elseif bl == LF
								inc FileLine
								mov FileCol, 1
								;====================================================================
								; On a new line, the number of columns should always be the same
								mov al,      Col
								.if Row == 0
									mov TotalCol, al
								.elseif TotalCol != al
									jmp ErrorColumnCount
								.endif
								;====================================================================
								; If next line is empty, all next lines should be empty
								invoke PeekChar
								mov    bh, PeekBuffer
								.if    bh == LF || bh == CR
									invoke ReadEmptyLines
								;====================================================================
								; Otherwise, next line must have data
								.else
									inc Row
									inc TotalRow
									mov Col, 0
								.endif
							.elseif bl == CR
							; accept CR only before LF
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.elseif (bl == '-')
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??0205     textequ <>
			     2			??0206 textequ <>
			     2			for       ??0204, <ax>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0206 catstr <ax>, ??0205, ??0206
			     3				??0205 catstr <, >
			     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
			     3				??0209     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)DELIMI
			     3				regStack substr regStack, (??0208 + 1)DELIM
			     3			endif
			     3			exitm ??0209
			     2		for ??0207, <ax> 
			     2				pop ??0207
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
								neg    sword ptr [bx]
							.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??020B     textequ <>
			     2			??020C textequ <>
			     2			for       ??020A, <ax>
			     2				push  ??020A
			     2				??020C catstr <??020A>, ??020B, ??020C
			     2				??020B catstr <, >
			     2			endm
			     3				push  ax
			     3				??020C catstr <ax>, ??020B, ??020C
			     3				??020B catstr <, >
			     2			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     2			__pushRegs ??020C
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??020C
			     3			else
			     3				regStack catstr ??020C, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??020E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??020E eq 0
			     3				??020F     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??020F substr regStack, 1, (??020E - 1)      
			     3				regStack substr regStack, (??020E + 1)     
			     3			endif
			     3			exitm ??020F
			     2		for ??020D, <ax> 
			     2				pop ??020D
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
							.else
								jmp ErrorUnexpectedChar
							.endif
							jmp ReadMatrixLoop
						EndReading:
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						ret
 1F7C					ReadMatrix endp
				;====================================================================
				; Printf
 1F7C					PrintMatrix proc near uses ax bx cx dx bp
						mov      bx, offset Matrix
						mov      dx, 8
						mov      cx, 0             ; High has row, Low has column
						.ForRow:                   ; for (row = 0; row < N; row++)
							cmp ch, N      ; row < N
							jge .EndForRow
							mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
								mov ax, sword ptr [bx]
								invoke printf_d_padded, ax, dx
								add bx, 2 ; size in bytes of a sword
								inc cl      ; col ++
								jmp .ForCol
							.EndForCol:
							putc CR
			     1			SaveRegs ax, dx
			     2			??0211     textequ <>
			     2			??0212 textequ <>
			     2			for       ??0210, <ax,dx>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0212 catstr <ax>, ??0211, ??0212
			     3				??0211 catstr <, >
			     3				push  dx
			     3				??0212 catstr <dx>, ??0211, ??0212
			     3				??0211 catstr <, >
			     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
			     3				??0215     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)      
			     3				regStack substr regStack, (??0214 + 1)     
			     3			endif
			     3			exitm ??0215
			     2		for ??0213, <dx, ax> 
			     2				pop ??0213
			     2			endm
			     3				pop dx
			     3				pop ax
							putc LF
			     1			SaveRegs ax, dx
			     2			??0217     textequ <>
			     2			??0218 textequ <>
			     2			for       ??0216, <ax,dx>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0218 catstr <ax>, ??0217, ??0218
			     3				??0217 catstr <, >
			     3				push  dx
			     3				??0218 catstr <dx>, ??0217, ??0218
			     3				??0217 catstr <, >
			     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
			     3				??021B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)      
			     3				regStack substr regStack, (??021A + 1)     
			     3			endif
			     3			exitm ??021B
			     2		for ??0219, <dx, ax> 
			     2				pop ??0219
			     2			endm
			     3				pop dx
			     3				pop ax
							inc ch      ; row++
							jmp .ForRow
						.EndForRow:
						ret
 1FD7					PrintMatrix endp
 1FD7					printf_s proc near uses ax bx cx dx bp, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
							mov ah, 2
							mov dl, [bx]
							int 21H
							inc bx
						.endw
						ret
 2012					printf_s endp
 2012					printf_u proc near uses ax bx cx dx bp, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
						invoke printf_s, addr buf
						ret
 2040					printf_u endp
 2040					printf_d proc near uses ax bx cx dx bp, number:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						invoke printf_s, addr buf
						ret
 206E					printf_d endp
					
 206E					printf_d_padded proc near uses ax bx cx dx bp, number:sword, padTo:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						; string_from_sword gives length on AX
						mov    cx, padTo
						sub    cx, ax
						.WHILE (sword ptr cx > 0)
							putc SPACE
			     1			SaveRegs ax, dx
			     2			??021D     textequ <>
			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
			     3				push  ax
			     3				??021E catstr <ax>, ??021D, ??021E
			     3				??021D catstr <, >
			     3				push  dx
			     3				??021E catstr <dx>, ??021D, ??021E
			     3				??021D catstr <, >
			     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, SPACE
			     1			int      21h
			     1			RestoreRegs
			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
			     3				??0221     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)      
			     3				regStack substr regStack, (??0220 + 1)     
			     3			endif
			     3			exitm ??0221
			     2		for ??021F, <dx, ax> 
			     2				pop ??021F
			     2			endm
			     3				pop dx
			     3				pop ax
							dec  cx
						.ENDW
						invoke printf_s, addr buf
						ret
 20CC					printf_d_padded endp
					; length of string goes to ax (including sign)
 20CC					string_from_sword proc near uses bx cx dx bp, string:ptr byte, number:sword
						mov dx, number
						mov bx, string
						mov cx, 0
						.if (sword ptr dx < 0)
							mov byte ptr[bx], '-'
							inc bx
							inc cx
							neg dx
						.endif
						invoke string_from_word, bx, dx
						add ax, cx
						ret
 210F					string_from_sword endp
					; length of string goes to ax
 210F					string_from_word proc near uses bx cx dx bp si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
						mov divisor, 10000
						mov first,   1     ; anything not 0 is true
						mov ax,    number
						mov value, ax
						mov bx, string
						mov cx, 5
						.repeat
							mov dx,    0
							mov ax,    value
							div divisor
							mov value, dx
							.if (ax != 0) || (!first) ; no zeroes on the left
								add al,            '0'
								mov byte ptr [bx], al
								inc bx
								mov first,         0
							.endif
							mov dx,      0
							mov ax,      divisor
							mov si,      10
							div si
							mov divisor, ax
						.untilcxz
						.if (first)
							mov byte ptr [bx], '0'
							inc bx
						.endif
						mov cx, string
						mov ax, bx
						sub ax, cx     ; ax = bx - string = len
						mov byte ptr [bx], 0
						ret
 21B1					string_from_word endp
				;--------------------------------------------------------------------
				end
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 10:06:38
main.asm						     Page 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
				
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
				
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
				
				
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
				
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
				
					WRITEMatrix proto near, NOME:ptr byte
				
					PrintMatrix proto near
				
				;====================================================================
				; Memory
						.stack
 0000						.data
					
				
 = 0000					CMD_NONE  EQU 0
 = 0001					CMD_MUL   EQU 1
 = 0002					CMD_DIV   EQU 2
 = 0003					CMD_ADD   EQU 3
 = 0004					CMD_SUB   EQU 4
 = 0005					CMD_UNDO  EQU 5
 = 0006					CMD_WRITE EQU 6
				
 = 000D					CR            equ 0dh
 = 000A					LF            equ 0ah
 = 0022					QUOT          equ 22h
 = 003B					SEMI          equ 3Bh
 = SEMI					COL_SEPARATOR equ SEMI
 = 0020					SPACE         equ 20h
				
 0000 3B 00				COLUMN_SEP db ";",0
 0002 0D 0A 00				CRLF       db CR, LF, 0
				
 = 0064					BuffSize       equ 100              ; tam. m√°ximo dos dados lidos no buffer
 0005 4D 41 54 2E 74 78			FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
       74 00
 000D  0064 [				FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
        00
       ]
 0071 0000				FileHandle     dw  0                ; Handler do arquivo
 0073 00				FileIsOpen     db  0                ; closed at the start
 0074  0096 [				FileNameBuffer db  150 dup (?)
        00
       ]
 010A 00				caractere      db  0
				
 010B FE				CommandBuffer       db 254
 010C 00				CommandBufferLength db 0          ; max length, actual length
 010D  00FE [				CommandBufferString db 254 dup(0)
        00
       ]
				
 020B 00				LastCommand   db 0
 020C 0000				LastCommand@a dw 0
 020E 0000				LastCommand@b sword 0
 0210 00				LastCommand@exists db 0
				
				
 0211  00FF [				NonTerminalErrorBuffer db 255 dup(0)
        00
       ]
				
 0310 43 6F 6D 61 6E 64			@Comando      db "Comando",0
       6F 00
 0318 65 73 70 65 72 61			@espera       db "espera",0
       00
 031F 63 6F 6D 6F 00			@como         db "como",0
 0324 70 61 72 61 6D 65			@parametro    db "parametro",0
       74 72 6F 00
 032E 50 61 72 61 6D 65			@@parametro   db "Parametro",0
       74 72 6F 00
 0338 64 65 73 63 6F 6E			@desconhecido db "desconhecido",0
       68 65 63 69 64 6F
       00
 0345 20 00				@space        db " ",0
				
 0347 64 65 76 65 20 65			@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
       73 74 61 72 20 65
       6E 74 72 65 20 31
       20 65 20 4E 00
 035E 4E 61 6F 20 66 6F			@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
       69 20 70 6F 73 73
       69 76 65 6C 20 61
       62 72 69 72 20 6F
       75 20 63 72 69 61
       72 20 6F 20 61 72
       71 75 69 76 6F 00
 0388 50 61 72 61 6D 65			@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
       74 72 6F 73 20 6E
       61 6F 20 72 65 63
       6F 6E 68 65 63 69
       64 6F 73 20 61 6F
       20 66 69 6E 61 6C
       20 64 6F 20 63 6F
       6D 61 6E 64 6F 00
					
 03B8 3A 20 00				COLON_SPACE db ": ",0
				
 = COLON_SPACE				ExplanationSeparator textequ <COLON_SPACE>
				
				
					; Used on PeekChar
 03BB 00				PeekBuffer        db ?
					; Used when reporting the error
 03BC 00 22 00				TheUnexpectedChar db 0,QUOT,0
					; used in main
 03BF 0001				FileCol           dw 1
 03C1 0001				FileLine          dw 1
				
 03C3 00				Row      byte 0
 03C4 00				Col      byte 0
 03C5 00				TotalRow byte 0
 03C6 00				TotalCol byte 0
				
 03C7 00				N        byte 0
 03C8 00				NPlusOne byte 0
					; should be at most 7x7
 03C9  0031 [				Matrix   sword (7 * 7) dup (?)
        0000
       ]
				
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
 = <					OPEN_DELIMITER    textequ <!<>
 = >					CLOSE_DELIMITER   textequ <!>>
 = |					REG_SET_DELIMITER textequ <|>
				
 = 					regStack textequ <> ; starts empty
				
					__popRegs macro
						local regs_end, regs		regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else			regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif		exitm regs
					endm
				
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else			regStack catstr regs, REG_SET_DELIMITER, regStack
						endif	endm
				
					SaveRegs macro regs:vararg
						local reg, comma, regpushed		comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
				
					RestoreRegs macro
						local reg	%	for reg, __popRegs(regStack) ;; Pop each register
							pop reg
						endm
					endm
				
					RegsInvokeUses textequ <ax bx cx dx bp>
				
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
 = ax bx cx dx bp				SaveRegs ax, dx
						mov      ah, 02h		mov      dl, c
 = bx cx dx bp					int      21h		RestoreRegs
 = ax cx dx bp				endm
				
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h		forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
				
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0	endm
				
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif		ifdifi <dst>, <di>
							lea di, dst
						endif		.repeat			mov al,   [si]			mov [di], al			inc si			inc di		.until (al == 0)		dec    si		dec    di		RestoreRegs
					endm
				
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> ; True
						ELSE			EXITM <0> ; False
						ENDIF	ENDM
				
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif		for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
				
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
				
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
				
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				
				;--------------------------------------------------------------------
				; Miscellaneous
				
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@Comando, !< &command !>, @espera, !< &paramName !>, @como, !< &positionName !>, @parametro, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@@parametro, !< &paramName !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
						<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
					endm
				
					CloseFileHandle macro
						mov ah, 3eh		mov bx, FileHandle		int 21h				mov FileIsOpen, 0 ; 0 means it is now closed	endm
				
					CurrentIndexToBx macro
						; returns in bx		SaveRegs ax
						mov      al, TotalCol		inc      al           ; TotalCol starts at 0
						mov bl, Row		mov bh, Col
						mul bl		add al, bh
						; got index, find position in array
						shl ax, 1		add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				
				;====================================================================
				; Program
					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
							putc   LF
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
				
						.if (ax == CMD_ADD)
							call Main@ADD
							jmp  @MainLoopEnd
						.elseif  (ax == CMD_MUL)
							call Main@MUL
							jmp  @MainLoopEnd
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
							jmp  @MainLoopEnd
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							jmp  @SkipPrint
						.endif
				
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
						putc LF
					jmp @whiletrue
				
					Main@ADD proc near
						mov LastCommand,        CMD_ADD
 0000						mov bh,                 0
						mov LastCommand@a,      bx
 0000			   *@Startup:
 0000  BA ---- R	   *	    mov    dx, DGROUP
 0003  8E DA		   *	    mov    ds, dx
 0005  8C D3		   *	    mov    bx, ss
 0007  2B DA		   *	    sub    bx, dx
 0009  D1 E3		   *	    shl    bx, 001h
 000B  D1 E3		   *	    shl    bx, 001h
 000D  D1 E3		   *	    shl    bx, 001h
 000F  D1 E3		   *	    shl    bx, 001h
 0011  FA		   *	    cli    
 0012  8E D2		   *	    mov    ss, dx
 0014  03 E3		   *	    add    sp, bx
 0016  FB		   *	    sti    
						mov ch,                 0
 0017  E8 1319		   *	    call   ReadMatrix
 001A						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
 001A  E8 142C		   *	    call   PrintMatrix
 001D				
						invoke ADDMatrix, bl, cl
 001D  E8 034F		   *	    call   ReadCommand
 0020				
 0020  73 28					ret
					Main@ADD endp
 0022  8D 06 0211 R	   *	    lea    ax, NonTerminalErrorBuffer
 0026  50		   *	    push   ax
 0027  E8 1467		   *	    call   printf_s
 002A  8D 1E 0211 R			Main@MUL proc near
 002E  C6 07 00					mov LastCommand,        CMD_MUL
						mov bh,                 0
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0001     textequ <>
 = 			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
 0031  50		     3				push  ax
 = ax			     3				??0002 catstr <ax>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 0032  52		     3				push  dx
 = dx, ax		     3				??0002 catstr <dx>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 = <dx, ax>		     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack
			     3			endif
 0033  B4 02		     1			mov      ah, 02h
 0035  B2 0D		     1			mov      dl, CR
 0037  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
 = <dx, ax>		     3				??0005     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)
			     3				regStack substr regStack, (??0004 + 1)
			     3			endif
			     3			exitm ??0005
			     2		%	for ??0003, __popRegs(regStack) 
			     2				pop ??0003
			     2			endm
 0039  5A		     3				pop dx
 003A  58		     3				pop ax
						mov LastCommand@a,      bx
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0007     textequ <>
 = 			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
 003B  50		     3				push  ax
 = ax			     3				??0008 catstr <ax>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 003C  52		     3				push  dx
 = dx, ax		     3				??0008 catstr <dx>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 = <dx, ax>		     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack
			     3			endif
 003D  B4 02		     1			mov      ah, 02h
 003F  B2 0A		     1			mov      dl, LF
 0041  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
 = <dx, ax>		     3				??000B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)
			     3				regStack substr regStack, (??000A + 1)
			     3			endif
			     3			exitm ??000B
			     2		%	for ??0009, __popRegs(regStack) 
			     2				pop ??0009
			     2			endm
 0043  5A		     3				pop dx
 0044  58		     3				pop ax
						mov LastCommand@b,      sword ptr cx
 0045  E8 0327		   *	    call   ReadCommand
 0048  EB D6					mov LastCommand@exists, 1
 004A				
						invoke MULMatrix, bl, cx
						ret
 004A  83 F8 03		   *	    cmp    ax, CMD_ADD
 004D  75 07		   *	    jne    @C0001
 004F  E8 003F				Main@MUL endp
 0052  EB 27				Main@UNDO proc near
						mov al, LastCommand@exists
 0054  EB 22		   *	    jmp    @C0003
 0056			   *@C0001:
 0056  83 F8 01		   *	    cmp    ax, CMD_MUL
 0059  75 07		   *	    jne    @C0004
 005B  E8 0053					.if !al
 005E  EB 1B						jmp @MainLoopEnd
						.endif
 0060  EB 16		   *	    jmp    @C0006
 0062			   *@C0004:
 0062  83 F8 05		   *	    cmp    ax, CMD_UNDO
 0065  75 07		   *	    jne    @C0007
 0067  E8 0063					mov al,           LastCommand
 006A  EB 0F					mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
 006C  EB 0A		   *	    jmp    @C0009
 006E			   *@C0007:
 006E  83 F8 06		   *	    cmp    ax, CMD_WRITE
 0071  75 05		   *	    jne    @C000A
 0073  E8 00B6					.if (al == CMD_ADD)
 0076  EB A5						invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
 0078			   *@C000A:
 0078			   *@C0009:
 0078			   *@C0006:
 0078			   *@C0003:
						.elseif (al == CMD_MUL)
 0078  E9 02D1						invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
 007B						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??000D     textequ <>
 = 			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
 007B  50		     3				push  ax
 = ax			     3				??000E catstr <ax>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 007C  52		     3				push  dx
 = dx, ax		     3				??000E catstr <dx>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 = <dx, ax>		     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack
			     3			endif
 007D  B4 02		     1			mov      ah, 02h
 007F  B2 0D		     1			mov      dl, CR
 0081  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
 = <dx, ax>		     3				??0011     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)
			     3				regStack substr regStack, (??0010 + 1)
			     3			endif
			     3			exitm ??0011
			     2		%	for ??000F, __popRegs(regStack) 
			     2				pop ??000F
			     2			endm
 0083  5A		     3				pop dx
 0084  58		     3				pop ax
							mov LastCommand, CMD_ADD
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0013     textequ <>
 = 			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
 0085  50		     3				push  ax
 = ax			     3				??0014 catstr <ax>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 0086  52		     3				push  dx
 = dx, ax		     3				??0014 catstr <dx>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 = <dx, ax>		     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack
			     3			endif
 0087  B4 02		     1			mov      ah, 02h
 0089  B2 0A		     1			mov      dl, LF
 008B  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
 = <dx, ax>		     3				??0017     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)
			     3				regStack substr regStack, (??0016 + 1)
			     3			endif
			     3			exitm ??0017
			     2		%	for ??0015, __popRegs(regStack) 
			     2				pop ??0015
			     2			endm
 008D  5A		     3				pop dx
 008E  58		     3				pop ax
 008F  EB 89					.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
 0091							mov LastCommand, CMD_MUL
 0091  C6 06 020B R 03				.endif
 0096  B7 00					ret
 0098  89 1E 020C R			Main@UNDO  endp
 009C  B5 00				Main@WRITE proc near
 009E  89 0E 020E R				invoke WRITEMatrix, dx
 00A2  C6 06 0210 R 01				ret
					Main@WRITE endp
				
 00A7  8A C1		   *	    mov    al, cl
 00A9  50		   *	    push   ax
 00AA  8A C3		   *	    mov    al, bl
 00AC  50		   *	    push   ax
 00AD  E8 00F0		   *	    call   ADDMatrix
				
 00B0  C3			;====================================================================
 00B1				; MUL
 00B1					MULMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
 00B1  C6 06 020B R 01				mov al, LINHA
 00B6  B7 00					dec al
 00B8  89 1E 020C R				mov bl, TotalCol
 00BC  89 0E 020E R				inc bl
 00C0  C6 06 0210 R 01				mul bl
				
						shl ax, 1
 00C5  51		   *	    push   cx
 00C6  8A C3		   *	    mov    al, bl
 00C8  50		   *	    push   ax
 00C9  E8 0065		   *	    call   MULMatrix
 00CC  C3			
 00CD						mov bx, offset Matrix
 00CD						add bx, ax
 00CD  A0 0210 R		
						mov ch, 0
 00D0  0A C0		   *	    or	al, al
 00D2  75 02		   *	    jne    @C000C
 00D4  EB A5					mov cl, NPlusOne
				
 00D6			   *@C000C:
 00D6  A0 020B R				MULMatrix@Loop:
 00D9  8B 1E 020C R					mov  ax,             sword ptr [bx]
 00DD  8B 0E 020E R					imul CONSTANTE
							mov  sword ptr [bx], ax
 00E1  3C 03		   *	    cmp    al, CMD_ADD
 00E3  75 10		   *	    jne    @C000E
				
 00E5  8A C1		   *	    mov    al, cl
 00E7  50		   *	    push   ax
 00E8  8A C3		   *	    mov    al, bl
 00EA  50		   *	    push   ax
 00EB  E8 0105		   *	    call   SUBMatrix
 00EE  C6 06 020B R 04					add  bx, 2
							loop MULMatrix@Loop
 00F3  EB 36		   *	    jmp    @C0010
 00F5			   *@C000E:
 00F5  3C 01		   *	    cmp    al, CMD_MUL
 00F7  75 0E		   *	    jne    @C0011
				
 00F9  51		   *	    push   cx
 00FA  8A C3		   *	    mov    al, bl
 00FC  50		   *	    push   ax
 00FD  E8 0068		   *	    call   DIVMatrix
 0100  C6 06 020B R 02				ret
					MULMatrix endp
 0105  EB 24		   *	    jmp    @C0013
 0107			   *@C0011:
 0107  3C 04		   *	    cmp    al, CMD_SUB
 0109  75 10		   *	    jne    @C0014
				
 010B  8A C1		   *	    mov    al, cl
 010D  50		   *	    push   ax
 010E  8A C3		   *	    mov    al, bl
 0110  50		   *	    push   ax
 0111  E8 008C		   *	    call   ADDMatrix
 0114  C6 06 020B R 03			DIVMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
 0119  EB 10		   *	    jmp    @C0016
 011B			   *@C0014:
 011B  3C 02		   *	    cmp    al, CMD_DIV
 011D  75 0C		   *	    jne    @C0017
						dec al
 011F  51		   *	    push   cx
 0120  8A C3		   *	    mov    al, bl
 0122  50		   *	    push   ax
 0123  E8 000B		   *	    call   MULMatrix
 0126  C6 06 020B R 01				mov bl, TotalCol
						inc bl
 012B			   *@C0017:
 012B			   *@C0016:
 012B			   *@C0013:
 012B			   *@C0010:
 012B  C3					mul bl
 012C				
 012C						shl ax, 1
				
 012C  52		   *	    push   dx
 012D  E8 0116		   *	    call   WRITEMatrix
 0130  C3					mov bx, offset Matrix
 0131						add bx, ax
				
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
 0131							mov ax, sword ptr [bx]
 0131  55		   *	    push   bp
 0132  8B EC		   *	    mov    bp, sp
 0134  50		   *	    push   ax
 0135  53		   *	    push   bx
 0136  51		   *	    push   cx
 0137  52		   *	    push   dx
 0138  55		   *	    push   bp
 0139  8A 46 04						cwd                    ; extend sign to dx
 013C  FE C8						
 013E  8A 1E 03C6 R					idiv CONSTANTE
 0142  FE C3						
 0144  F6 E3						mov sword ptr [bx], ax
				
 0146  D1 E0						add  bx, 2
							loop DIVMatrix@Loop
 0148  BB 03C9 R		
 014B  03 D8					ret
					DIVMatrix endp
 014D  B5 00			
 014F  8A 0E 03C8 R		;====================================================================
				; ADD
 0153					ADDMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
 0153  8B 07			
 0155  F7 6E 06					mov al, LINHA_DST
 0158  89 07					dec al
						mov bl, TotalCol
 015A  83 C3 02					inc bl
 015D  E2 F4					mul bl
						shl ax, 1
						
 015F  5D		   *	    pop    bp
 0160  5A		   *	    pop    dx
 0161  59		   *	    pop    cx
 0162  5B		   *	    pop    bx
 0163  58		   *	    pop    ax
 0164  5D		   *	    pop    bp
 0165  C2 0004		   *	    ret    00004h
 0168						lea di, Matrix
						add di, ax
 0168				
 0168  55		   *	    push   bp
 0169  8B EC		   *	    mov    bp, sp
 016B  50		   *	    push   ax
 016C  53		   *	    push   bx
 016D  51		   *	    push   cx
 016E  52		   *	    push   dx
 016F  55		   *	    push   bp
 0170  8A 46 04			
 0173  FE C8					mov al, LINHA_ORG
 0175  8A 1E 03C6 R				dec al
 0179  FE C3					mov bl, TotalCol
 017B  F6 E3					inc bl
						mul bl
 017D  D1 E0					shl ax, 1
				
 017F  BB 03C9 R				lea si, Matrix
 0182  03 D8					add si, ax
				
 0184  B5 00					mov ch, 0
 0186  8A 0E 03C8 R				mov cl, NPlusOne
 018A						ADDMatrix@Loop:
 018A  8B 07						mov ax,   [di]
 018C  99						add ax,   [si]
							mov [di], ax
 018D  F7 7E 06			
							add  di, 2
 0190  89 07						add  si, 2
							loop ADDMatrix@Loop
 0192  83 C3 02			
 0195  E2 F3					ret
					ADDMatrix endp
				
 0197  5D		   *	    pop    bp
 0198  5A		   *	    pop    dx
 0199  59		   *	    pop    cx
 019A  5B		   *	    pop    bx
 019B  58		   *	    pop    ax
 019C  5D		   *	    pop    bp
 019D  C2 0004		   *	    ret    00004h
 01A0					SUBMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
				
						mov al, LINHA_DST
						dec al
 01A0						mov bl, TotalCol
						inc bl
 01A0  55		   *	    push   bp
 01A1  8B EC		   *	    mov    bp, sp
 01A3  50		   *	    push   ax
 01A4  53		   *	    push   bx
 01A5  51		   *	    push   cx
 01A6  52		   *	    push   dx
 01A7  55		   *	    push   bp
 01A8  57		   *	    push   di
 01A9  56		   *	    push   si
 01AA  8A 46 04					mul bl
 01AD  FE C8					shl ax, 1
 01AF  8A 1E 03C6 R				
 01B3  FE C3					lea di, Matrix
 01B5  F6 E3					add di, ax
 01B7  D1 E0			
				
 01B9  8D 3E 03C9 R				mov al, LINHA_ORG
 01BD  03 F8					dec al
						mov bl, TotalCol
						inc bl
 01BF  8A 46 06					mul bl
 01C2  FE C8					shl ax, 1
 01C4  8A 1E 03C6 R		
 01C8  FE C3					lea si, Matrix
 01CA  F6 E3					add si, ax
 01CC  D1 E0			
						mov ch, 0
 01CE  8D 36 03C9 R				mov cl, NPlusOne
 01D2  03 F0					SUBMatrix@Loop:
							mov ax,   [di]
 01D4  B5 00						sub ax,   [si]
 01D6  8A 0E 03C8 R					mov [di], ax
 01DA				
 01DA  8B 05						add  di, 2
 01DC  03 04						add  si, 2
 01DE  89 05						loop SUBMatrix@Loop
				
 01E0  83 C7 02					ret
 01E3  83 C6 02				SUBMatrix endp
 01E6  E2 F2			
				;====================================================================
				; WRITE
 01E8  5E		   *	    pop    si
 01E9  5F		   *	    pop    di
 01EA  5D		   *	    pop    bp
 01EB  5A		   *	    pop    dx
 01EC  59		   *	    pop    cx
 01ED  5B		   *	    pop    bx
 01EE  58		   *	    pop    ax
 01EF  5D		   *	    pop    bp
 01F0  C2 0004		   *	    ret    00004h
 01F3				
					WriteToFile macro handle:req, offset_buf:req, len:req
 01F3						SaveRegs bx, cx, dx
						mov cx, len
 01F3  55		   *	    push   bp
 01F4  8B EC		   *	    mov    bp, sp
 01F6  50		   *	    push   ax
 01F7  53		   *	    push   bx
 01F8  51		   *	    push   cx
 01F9  52		   *	    push   dx
 01FA  55		   *	    push   bp
 01FB  57		   *	    push   di
 01FC  56		   *	    push   si
 01FD  8A 46 04					mov bx, handle
 0200  FE C8					lea dx, offset_buf
 0202  8A 1E 03C6 R				mov ah, 40h		int 21h
 0206  FE C3					RestoreRegs
 0208  F6 E3				endm
 020A  D1 E0				WRITEMatrix proc near uses RegsInvokeUses di si, NOME:ptr byte
						local buf[7]:byte, handle:word
 020C  8D 3E 03C9 R				mov   ah,          3Dh         ; open
 0210  03 F8					mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
 0212  8A 46 06					jc    create_file              ; if not exists
 0215  FE C8			
 0217  8A 1E 03C6 R				mov bx, ax      ; BX = file handle
 021B  FE C3					jmp file_opened
 021D  F6 E3			
 021F  D1 E0					create_file:
						mov ah, 3Ch  ; create
 0221  8D 36 03C9 R				mov cx, 0
 0225  03 F0					mov dx, NOME
						int 21h
 0227  B5 00					mov bx, ax
 0229  8A 0E 03C8 R		
 022D						file_opened:
 022D  8B 05					mov ah, 42h
 022F  2B 04					mov al, 02h ; SEEK_END
 0231  89 05					xor cx, cx
						xor dx, dx
 0233  83 C7 02					int 21h
 0236  83 C6 02			
 0239  E2 F2					.if (carry?)
							ErrorCantOpenNorCreate
							stc
 023B  5E		   *	    pop    si
 023C  5F		   *	    pop    di
 023D  5D		   *	    pop    bp
 023E  5A		   *	    pop    dx
 023F  59		   *	    pop    cx
 0240  5B		   *	    pop    bx
 0241  58		   *	    pop    ax
 0242  5D		   *	    pop    bp
 0243  C2 0004		   *	    ret    00004h
 0246							ret
						.endif
				
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
				
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
				
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
 0246							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
 0246  55		   *	    push   bp
 0247  8B EC		   *	    mov    bp, sp
 0249  83 C4 F6		   *	    add    sp, 0FFF6h
 024C  50		   *	    push   ax
 024D  53		   *	    push   bx
 024E  51		   *	    push   cx
 024F  52		   *	    push   dx
 0250  55		   *	    push   bp
 0251  57		   *	    push   di
 0252  56		   *	    push   si
 0253  B4 3D							jge WRITEMatrix@EndForCol
 0255  B0 02			
 0257  8B 56 04							.if (bl) ; no longer firstCol?
 025A  CD 21								WriteToFile handle, COLUMN_SEP, 1
 025C  72 04							.endif
				
 025E  8B D8							mov ax, sword ptr [di]
 0260  EB 0C			
								invoke string_from_sword, addr buf, ax ; ax now has length
 0262				
 0262  B4 3C							WriteToFile handle, buf, ax
 0264  B9 0000			
 0267  8B 56 04							add di, 2 ; size in bytes of a sword
 026A  CD 21			
 026C  8B D8							mov bl, 1 ; no longer first col
								inc cl    ; col ++
 026E								
 026E  B4 42							jmp WRITEMatrix@ForCol
 0270  B0 02						WRITEMatrix@EndForCol:
 0272  33 C9			
 0274  33 D2						WriteToFile handle, CRLF, 2
 0276  CD 21			
							inc ch ; row++
							
 0278  73 48		   *	    jae    @C0019
							jmp WRITEMatrix@ForRow
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
 027A  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     3				EXITM <-1> 
			     3				if DEFINED(@@nao_foi_possivel_abrir_ou_criar_o_arquivo)
			     4					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0019     textequ <>
			     5			??001A textequ <>
			     5			for       ??0018, <ax>
			     5				push  ??0018
			     5				??001A catstr <??0018>, ??0019, ??001A
			     5				??0019 catstr <, >
 027E  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??001A catstr <ax>, ??0019, ??001A
 = <ax>			     5				??0019 catstr <, >
			     5			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??001A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??001A
			     6			else
			     6				regStack catstr ??001A, REG_SET_DELIMITER, regStack
			     4			endif
 027F  8D 36 035E R	     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0283			   *@C001B:
			     4			endif
 0283  8A 04		     4			.repeat
 0285  88 05		     4				mov al,   [si]
 0287  46		     4				mov [di], al
 0288  47		     4				inc si
 0289  0A C0		   *	    or	al, al
 028B  75 F6		   *	    jne    @C001B
			     4				inc di
 028D  4E		     4			.until (al == 0)
 028E  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??001C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??001C eq 0
 = 			     6				??001D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??001D substr regStack, 1, (??001C - 1)
			     6				regStack substr regStack, (??001C + 1)
			     6			endif
			     5			exitm ??001D
			     5		%	for ??001B, __popRegs(regStack) 
			     5				pop ??001B
 028F  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??001F     textequ <>
			     5			??0020 textequ <>
			     5			for       ??001E, <ax>
			     5				push  ??001E
			     5				??0020 catstr <??001E>, ??001F, ??0020
			     5				??001F catstr <, >
 0290  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0020 catstr <ax>, ??001F, ??0020
 = <ax>			     5				??001F catstr <, >
			     5			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0020
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0020
			     6			else
			     6				regStack catstr ??0020, REG_SET_DELIMITER, regStack
			     4			endif
 0291  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0295			   *@C001D:
			     4			endif
 0295  8A 04		     4			.repeat
 0297  88 05		     4				mov al,   [si]
 0299  46		     4				mov [di], al
 029A  47		     4				inc si
 029B  0A C0		   *	    or	al, al
 029D  75 F6		   *	    jne    @C001D
			     4				inc di
 029F  4E		     4			.until (al == 0)
 02A0  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0022 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0022 eq 0
 = 			     6				??0023     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0023 substr regStack, 1, (??0022 - 1)
			     6				regStack substr regStack, (??0022 + 1)
			     6			endif
			     5			exitm ??0023
			     5		%	for ??0021, __popRegs(regStack) 
			     5				pop ??0021
 02A1  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
 02A2  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0026 catstr <ax>, ??0025, ??0026
 = <ax>			     5				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0026
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack
			     4			endif
 02A3  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 02A7			   *@C001F:
			     4			endif
 02A7  8A 04		     4			.repeat
 02A9  88 05		     4				mov al,   [si]
 02AB  46		     4				mov [di], al
 02AC  47		     4				inc si
 02AD  0A C0		   *	    or	al, al
 02AF  75 F6		   *	    jne    @C001F
			     4				inc di
 02B1  4E		     4			.until (al == 0)
 02B2  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0028 eq 0
 = 			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)
			     6				regStack substr regStack, (??0028 + 1)
			     6			endif
			     5			exitm ??0029
			     5		%	for ??0027, __popRegs(regStack) 
			     5				pop ??0027
 02B3  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 02B4  F9					WRITEMatrix@EndForRow:
				
 02B5  5E		   *	    pop    si
 02B6  5F		   *	    pop    di
 02B7  5D		   *	    pop    bp
 02B8  5A		   *	    pop    dx
 02B9  59		   *	    pop    cx
 02BA  5B		   *	    pop    bx
 02BB  58		   *	    pop    ax
 02BC  8B E5		   *	    mov    sp, bp
 02BE  5D		   *	    pop    bp
 02BF  C2 0002		   *	    ret    00002h
						; closeFile
 02C2			   *@C0019:
						mov ah, 3eh
 02C2  89 5E F6					mov bx, handle
 02C5  BB 0000					int 21h
				
 02C8  BF 03C9 R				; Reset Disk
 02CB  B9 0000					mov ah, 0Dh
						int 21h
 02CE				
 02CE  3A 2E 03C7 R				clc
 02D2  7D 5F					ret
					WRITEMatrix endp
 02D4  B3 00			;====================================================================
 02D6  B1 00			; Exiting
				
 02D8					ExitSuccess proc near
 02D8  3A 0E 03C8 R				mov al, 0
 02DC  7D 3D					jmp ExitAndClose
						ret
					ExitSuccess endp
 02DE  0A DB		   *	    or	bl, bl
 02E0  74 14		   *	    je     @C0021
				
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??002B     textequ <>
 = 			     2			??002C textequ <>
			     2			for       ??002A, <bx,cx,dx>
			     2				push  ??002A
			     2				??002C catstr <??002A>, ??002B, ??002C
			     2				??002B catstr <, >
			     2			endm
 02E2  53		     3				push  bx
 = bx			     3				??002C catstr <bx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 02E3  51		     3				push  cx
 = cx, bx		     3				??002C catstr <cx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 02E4  52		     3				push  dx
 = dx, cx, bx		     3				??002C catstr <dx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 = <dx, cx, bx>		     2			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
			     2			__pushRegs ??002C
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??002C
			     3			else
			     3				regStack catstr ??002C, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 02E5  B9 0001		     1			mov cx, 1
 02E8  8B 5E F6		     1			mov bx, handle
 02EB  8D 16 0000 R	     1			lea dx, COLUMN_SEP
 02EF  B4 40		     1			mov ah, 40h
 02F1  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??002E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??002E eq 0
 = <dx, cx, bx>		     3				??002F     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??002F substr regStack, 1, (??002E - 1)
			     3				regStack substr regStack, (??002E + 1)
			     3			endif
			     3			exitm ??002F
			     2		%	for ??002D, __popRegs(regStack) 
			     2				pop ??002D
			     2			endm
 02F3  5A		     3				pop dx
 02F4  59		     3				pop cx
 02F5  5B		     3				pop bx
					ExitFailure proc near
 02F6			   *@C0021:
						mov al, 1
 02F6  8B 05					jmp ExitAndClose
						ret
					ExitFailure endp
 02F8  50		   *	    push   ax
 02F9  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 02FC  50		   *	    push   ax
 02FD  E8 123F		   *	    call   string_from_sword
				
					ExitAndClose proc near
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0031     textequ <>
 = 			     2			??0032 textequ <>
			     2			for       ??0030, <bx,cx,dx>
			     2				push  ??0030
			     2				??0032 catstr <??0030>, ??0031, ??0032
			     2				??0031 catstr <, >
			     2			endm
 0300  53		     3				push  bx
 = bx			     3				??0032 catstr <bx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 0301  51		     3				push  cx
 = cx, bx		     3				??0032 catstr <cx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 0302  52		     3				push  dx
 = dx, cx, bx		     3				??0032 catstr <dx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 = <dx, cx, bx>		     2			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
			     2			__pushRegs ??0032
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0032
			     3			else
			     3				regStack catstr ??0032, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 0303  8B C8		     1			mov cx, ax
 0305  8B 5E F6		     1			mov bx, handle
 0308  8D 56 F9		     1			lea dx, buf
 030B  B4 40		     1			mov ah, 40h
 030D  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0034 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0034 eq 0
 = <dx, cx, bx>		     3				??0035     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0035 substr regStack, 1, (??0034 - 1)
			     3				regStack substr regStack, (??0034 + 1)
			     3			endif
			     3			exitm ??0035
			     2		%	for ??0033, __popRegs(regStack) 
			     2				pop ??0033
			     2			endm
 030F  5A		     3				pop dx
 0310  59		     3				pop cx
 0311  5B		     3				pop bx
						.if (FileIsOpen)
 0312  83 C7 02						CloseFileHandle
						.endif
 0315  B3 01					.exit
 0317  FE C1					ret
					ExitAndClose endp
 0319  EB BD			
 031B				;====================================================================
				; Reading input
				
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0037     textequ <>
 = 			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
 031B  53		     3				push  bx
 = bx			     3				??0038 catstr <bx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 031C  51		     3				push  cx
 = cx, bx		     3				??0038 catstr <cx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 031D  52		     3				push  dx
 = dx, cx, bx		     3				??0038 catstr <dx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 = <dx, cx, bx>		     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 031E  B9 0002		     1			mov cx, 2
 0321  8B 5E F6		     1			mov bx, handle
 0324  8D 16 0002 R	     1			lea dx, CRLF
 0328  B4 40		     1			mov ah, 40h
 032A  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
 = <dx, cx, bx>		     3				??003B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)
			     3				regStack substr regStack, (??003A + 1)
			     3			endif
			     3			exitm ??003B
			     2		%	for ??0039, __popRegs(regStack) 
			     2				pop ??0039
			     2			endm
 032C  5A		     3				pop dx
 032D  59		     3				pop cx
 032E  5B		     3				pop bx
					ReadCommand proc near uses si
 032F  FE C5					mov dx, offset CommandBuffer
						mov ah, 0Ah
 0331  EB 9B					int 21h
 0333				
						mov si, offset CommandBufferString
						mov bh, 0
 0333  B4 3E					mov bl, CommandBufferLength
 0335  8B 5E F6					
 0338  CD 21					mov byte ptr [CommandBufferString+bx], 0
				
				
 033A  B4 0D					putc CR
 033C  CD 21					putc LF
				
 033E  F8					invoke ParseCommand
						ret
 033F  5E		   *	    pop    si
 0340  5F		   *	    pop    di
 0341  5D		   *	    pop    bp
 0342  5A		   *	    pop    dx
 0343  59		   *	    pop    cx
 0344  5B		   *	    pop    bx
 0345  58		   *	    pop    ax
 0346  8B E5		   *	    mov    sp, bp
 0348  5D		   *	    pop    bp
 0349  C2 0002		   *	    ret    00002h
 034C					ReadCommand endp
				
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
 034C						LOCAL i, @@eq, @@ne, @@done		SaveRegs ax, bx
 034C  B0 00					i = 0
 034E  EB 06							mov bx, memString
 0350  C3							forc char, <constStr>
 0351							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
 0351							cmp al, '&char'
 0351  B0 01						jne @@ne
 0353  EB 01						i = i + 1
 0355  C3					endm 
 0356						mov ax, 1
						jmp @@done
 0356						@@ne:
							mov ax, 0
 0356  80 3E 0073 R 00	   *	    cmp    FileIsOpen, 000h
 035B  74 0D		   *	    je     @C0023
						@@done:
 035D  B4 3E		     1			mov ah, 3eh
 035F  8B 1E 0071 R	     1			mov bx, FileHandle
 0363  CD 21		     1			int 21h
			     1			
 0365  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
							cmp ax, 0			RestoreRegs
 036A			   *@C0023:
					endm
 036A  B4 4C		   *	    mov    ah, 04Ch
 036C  CD 21		   *	    int    021h
 036E  C3			
 036F					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw	endm
				
 036F					; Return the value read in result, and the end of the string read in si
 036F  56		   *	    push   si
 0370  BA 010B R			ReadNumFromString proc near uses RegsInvokeUses, string:ptr byte, result:ptr sword
 0373  B4 0A					mov ax, 0
 0375  CD 21					mov bx, 0
						mov si, string
 0377  BE 010D R				mov cx, 0
 037A  B7 00			
 037C  8A 1E 010C R				.if byte ptr [si] == '-'
							inc si
 0380  C6 87 010D R 00					mov cx, 1
						.endif
				
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??003D     textequ <>
 = 			     2			??003E textequ <>
			     2			for       ??003C, <ax,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
 0385  50		     3				push  ax
 = ax			     3				??003E catstr <ax>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 0386  52		     3				push  dx
 = dx, ax		     3				??003E catstr <dx>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 = <dx, ax>		     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack
			     3			endif
 0387  B4 02		     1			mov      ah, 02h
 0389  B2 0D		     1			mov      dl, CR
 038B  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
 = <dx, ax>		     3				??0041     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)
			     3				regStack substr regStack, (??0040 + 1)
			     3			endif
			     3			exitm ??0041
			     2		%	for ??003F, __popRegs(regStack) 
			     2				pop ??003F
			     2			endm
 038D  5A		     3				pop dx
 038E  58		     3				pop ax
							mov dx, 10
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0043     textequ <>
 = 			     2			??0044 textequ <>
			     2			for       ??0042, <ax,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
 038F  50		     3				push  ax
 = ax			     3				??0044 catstr <ax>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 0390  52		     3				push  dx
 = dx, ax		     3				??0044 catstr <dx>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 = <dx, ax>		     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack
			     3			endif
 0391  B4 02		     1			mov      ah, 02h
 0393  B2 0A		     1			mov      dl, LF
 0395  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
 = <dx, ax>		     3				??0047     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)
			     3				regStack substr regStack, (??0046 + 1)
			     3			endif
			     3			exitm ??0047
			     2		%	for ??0045, __popRegs(regStack) 
			     2				pop ??0045
			     2			endm
 0397  5A		     3				pop dx
 0398  58		     3				pop ax
							mul dx
				
 0399  E8 0060		   *	    call   ParseCommand
							mov bl, [si]
 039C  5E		   *	    pop    si
 039D  C3		   *	    ret    00000h
 039E							sub bl, '0'
							add ax, bx
				
							inc si
						.endw
				
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
				
						.if (cx)
							neg ax
						.endif
				
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
					ReadNumFromString endp
				
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)			stc		.else			mov resultReg, numberInMemory
							clc		.endif	endm
				
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
								.if (!zero?)			add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif	endm
				
				
 039E					;   AX = command ID (CMD_*)
 039E  55		   *	    push   bp
 039F  8B EC		   *	    mov    bp, sp
 03A1  50		   *	    push   ax
 03A2  53		   *	    push   bx
 03A3  51		   *	    push   cx
 03A4  52		   *	    push   dx
 03A5  55		   *	    push   bp
 03A6  B8 0000				;   BX = param1 (if any)
 03A9  BB 0000				;   CX = param2 (if any)
 03AC  8B 76 04				;   DX = offset of string (WRITE)
 03AF  B9 0000				ParseCommand proc near uses si di bp
						local a:sword
				
 03B2  80 3C 2D		   *	    cmp    byte ptr [si], '-'
 03B5  75 04		   *	    jne    @C0025
 03B7  46					mov si, offset CommandBufferString
 03B8  B9 0001					
						SkipSpacesInSI si
 03BB			   *@C0025:
				
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
 03BB  EB 0D		   *	    jmp    @C0027
 03BD			   *@C0028:
 03BD  BA 000A					jumpIfSIComparesTo <ADD> ParseCommand@ADD
 03C0  F7 E2					jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
 03C2  8A 1C					jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
 03C4  80 EB 30					jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
 03C7  03 C3				
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
 03C9  46				ParseCommand@error:
						stc
 03CA			   *@C0027:
 03CA  80 3C 30		   *	    cmp    byte ptr [si], '0'
 03CD  72 05		   *	    jb     @C0029
 03CF  80 3C 39		   *	    cmp    byte ptr [si], '9'
 03D2  76 E9		   *	    jbe    @C0028
 03D4			   *@C0029:
						ret
 03D4  8B 5E 04				ParseCommand@MUL:
 03D7  03 D9			
						skipAndRead si, a, bx
 03D9  3B F3		   *	    cmp    si, bx
 03DB  75 0A		   *	    jne    @C002B
 03DD  F9					.if (carry?)
							call ParseCommand@LINHA_AUSENTE
 03DE  5D		   *	    pop    bp
 03DF  5A		   *	    pop    dx
 03E0  59		   *	    pop    cx
 03E1  5B		   *	    pop    bx
 03E2  58		   *	    pop    ax
 03E3  5D		   *	    pop    bp
 03E4  C2 0004		   *	    ret    00004h
							jmp ParseCommand@error
 03E7			   *@C002B:
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
 03E7  0B C9		   *	    or	cx, cx
 03E9  74 02		   *	    je     @C002D
 03EB  F7 D8						jmp ParseCommand@error
						.elseif (bl < 1)
 03ED			   *@C002D:
							call ParseCommand@LINHA_INVALIDA
 03ED  8B 5E 06						jmp ParseCommand@error
 03F0  89 07					.endif
 03F2  F8					
						skipAndRead si, a, cx
 03F3  5D		   *	    pop    bp
 03F4  5A		   *	    pop    dx
 03F5  59		   *	    pop    cx
 03F6  5B		   *	    pop    bx
 03F7  58		   *	    pop    ax
 03F8  5D		   *	    pop    bp
 03F9  C2 0004		   *	    ret    00004h
 03FC						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
				
						mov ax, CMD_MUL
				
						jmp ParseCommand@success
				
					ParseCommand@ADD:
				
						skipAndRead si, a, bx
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
				
						skipAndRead si, a, cx
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
 03FC							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
 03FC  55		   *	    push   bp
 03FD  8B EC		   *	    mov    bp, sp
 03FF  83 C4 FE		   *	    add    sp, 0FFFEh
 0402  56		   *	    push   si
 0403  57		   *	    push   di
 0404  55		   *	    push   bp
 0405  BE 010D R					call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
 0408  EB 01		   *	    jmp    @C002F
 040A			   *@C0030:
			     1			.while (BYTE PTR [si] == ' ' )
 040A  46		     1				inc si
 040B			   *@C002F:
 040B  80 3C 20		   *	    cmp    byte ptr [si], ' '
 040E  74 FA		   *	    je     @C0030
			     1			.endw
				
						mov ax, CMD_ADD
			     1			StartsWith <MUL> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??004D     textequ <>
 = 			     3			??004E textequ <>
			     3			for       ??004C, <ax,bx>
			     3				push  ??004C
			     3				??004E catstr <??004C>, ??004D, ??004E
			     3				??004D catstr <, >
			     3			endm
 0410  50		     4				push  ax
 = ax			     4				??004E catstr <ax>, ??004D, ??004E
 = , 			     4				??004D catstr <, >
 0411  53		     4				push  bx
 = bx, ax		     4				??004E catstr <bx>, ??004D, ??004E
 = , 			     4				??004D catstr <, >
 = <bx, ax>		     3			??004E catstr OPEN_DELIMITER, ??004E, CLOSE_DELIMITER
			     3			__pushRegs ??004E
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??004E
			     4			else
			     4				regStack catstr ??004E, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0048 = 0
			     2			
 0412  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0048]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??004A
			     2	
			     2				??0048 = ??0048 + 1
			     2			endm 
 0414  8A 07		     3				mov al, [bx+??0048]
 0416  24 DF		     3				and al, 11011111b ; toUpperCase
 0418  3C 4D		     3				cmp al, 'M'
 041A  75 17		     3				jne ??004A
			     3	
 = 0001			     3				??0048 = ??0048 + 1
 041C  8A 47 01		     3				mov al, [bx+??0048]
 041F  24 DF		     3				and al, 11011111b ; toUpperCase
 0421  3C 55		     3				cmp al, 'U'
 0423  75 0E		     3				jne ??004A
			     3	
 = 0002			     3				??0048 = ??0048 + 1
 0425  8A 47 02		     3				mov al, [bx+??0048]
 0428  24 DF		     3				and al, 11011111b ; toUpperCase
 042A  3C 4C		     3				cmp al, 'L'
 042C  75 05		     3				jne ??004A
			     3	
 = 0003			     3				??0048 = ??0048 + 1
 042E  B8 0001		     2			mov ax, 1
			     2	
 0431  EB 03		     2			jmp ??004B
 0433			     2			??004A:
 0433  B8 0000		     2				mov ax, 0
			     2	
 0436			     2			??004B:
 0436  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0050 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0050 eq 0
 = <bx, ax>		     4				??0051     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0051 substr regStack, 1, (??0050 - 1)
			     4				regStack substr regStack, (??0050 + 1)
			     4			endif
			     4			exitm ??0051
			     3		%	for ??004F, __popRegs(regStack) 
			     3				pop ??004F
			     3			endm
 0439  5B		     4				pop bx
 043A  58		     4				pop ax
			     1			
 043B  74 06		   *	    je     @C0032
			     1			.if (!zero?)
 043D  83 C6 03		     1				add si, @SizeStr(MUL)
 0440  E9 0192		     1				jmp ParseCommand@MUL
 0443			   *@C0032:
			     1			.endif
						
			     1			StartsWith <ADD> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0057     textequ <>
 = 			     3			??0058 textequ <>
			     3			for       ??0056, <ax,bx>
			     3				push  ??0056
			     3				??0058 catstr <??0056>, ??0057, ??0058
			     3				??0057 catstr <, >
			     3			endm
 0443  50		     4				push  ax
 = ax			     4				??0058 catstr <ax>, ??0057, ??0058
 = , 			     4				??0057 catstr <, >
 0444  53		     4				push  bx
 = bx, ax		     4				??0058 catstr <bx>, ??0057, ??0058
 = , 			     4				??0057 catstr <, >
 = <bx, ax>		     3			??0058 catstr OPEN_DELIMITER, ??0058, CLOSE_DELIMITER
			     3			__pushRegs ??0058
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0058
			     4			else
			     4				regStack catstr ??0058, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0052 = 0
			     2			
 0445  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??0052]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0054
			     2	
			     2				??0052 = ??0052 + 1
			     2			endm 
 0447  8A 07		     3				mov al, [bx+??0052]
 0449  24 DF		     3				and al, 11011111b ; toUpperCase
 044B  3C 41		     3				cmp al, 'A'
 044D  75 17		     3				jne ??0054
			     3	
 = 0001			     3				??0052 = ??0052 + 1
 044F  8A 47 01		     3				mov al, [bx+??0052]
 0452  24 DF		     3				and al, 11011111b ; toUpperCase
 0454  3C 44		     3				cmp al, 'D'
 0456  75 0E		     3				jne ??0054
			     3	
 = 0002			     3				??0052 = ??0052 + 1
 0458  8A 47 02		     3				mov al, [bx+??0052]
 045B  24 DF		     3				and al, 11011111b ; toUpperCase
 045D  3C 44		     3				cmp al, 'D'
 045F  75 05		     3				jne ??0054
			     3	
 = 0003			     3				??0052 = ??0052 + 1
 0461  B8 0001		     2			mov ax, 1
			     2	
 0464  EB 03		     2			jmp ??0055
 0466			     2			??0054:
 0466  B8 0000		     2				mov ax, 0
			     2	
 0469			     2			??0055:
 0469  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??005A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005A eq 0
 = <bx, ax>		     4				??005B     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??005B substr regStack, 1, (??005A - 1)
			     4				regStack substr regStack, (??005A + 1)
			     4			endif
			     4			exitm ??005B
			     3		%	for ??0059, __popRegs(regStack) 
			     3				pop ??0059
			     3			endm
 046C  5B		     4				pop bx
 046D  58		     4				pop ax
			     1			
 046E  74 06		   *	    je     @C0034
			     1			.if (!zero?)
 0470  83 C6 03		     1				add si, @SizeStr(ADD)
 0473  E9 01BE		     1				jmp ParseCommand@ADD
 0476			   *@C0034:
			     1			.endif
						jmp ParseCommand@success
			     1			StartsWith <UNDO> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0061     textequ <>
 = 			     3			??0062 textequ <>
			     3			for       ??0060, <ax,bx>
			     3				push  ??0060
			     3				??0062 catstr <??0060>, ??0061, ??0062
			     3				??0061 catstr <, >
			     3			endm
 0476  50		     4				push  ax
 = ax			     4				??0062 catstr <ax>, ??0061, ??0062
 = , 			     4				??0061 catstr <, >
 0477  53		     4				push  bx
 = bx, ax		     4				??0062 catstr <bx>, ??0061, ??0062
 = , 			     4				??0061 catstr <, >
 = <bx, ax>		     3			??0062 catstr OPEN_DELIMITER, ??0062, CLOSE_DELIMITER
			     3			__pushRegs ??0062
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0062
			     4			else
			     4				regStack catstr ??0062, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??005C = 0
			     2			
 0478  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??005C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??005E
			     2	
			     2				??005C = ??005C + 1
			     2			endm 
 047A  8A 07		     3				mov al, [bx+??005C]
 047C  24 DF		     3				and al, 11011111b ; toUpperCase
 047E  3C 55		     3				cmp al, 'U'
 0480  75 20		     3				jne ??005E
			     3	
 = 0001			     3				??005C = ??005C + 1
 0482  8A 47 01		     3				mov al, [bx+??005C]
 0485  24 DF		     3				and al, 11011111b ; toUpperCase
 0487  3C 4E		     3				cmp al, 'N'
 0489  75 17		     3				jne ??005E
			     3	
 = 0002			     3				??005C = ??005C + 1
 048B  8A 47 02		     3				mov al, [bx+??005C]
 048E  24 DF		     3				and al, 11011111b ; toUpperCase
 0490  3C 44		     3				cmp al, 'D'
 0492  75 0E		     3				jne ??005E
			     3	
 = 0003			     3				??005C = ??005C + 1
 0494  8A 47 03		     3				mov al, [bx+??005C]
 0497  24 DF		     3				and al, 11011111b ; toUpperCase
 0499  3C 4F		     3				cmp al, 'O'
 049B  75 05		     3				jne ??005E
			     3	
 = 0004			     3				??005C = ??005C + 1
 049D  B8 0001		     2			mov ax, 1
			     2	
 04A0  EB 03		     2			jmp ??005F
 04A2			     2			??005E:
 04A2  B8 0000		     2				mov ax, 0
			     2	
 04A5			     2			??005F:
 04A5  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0064 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0064 eq 0
 = <bx, ax>		     4				??0065     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0065 substr regStack, 1, (??0064 - 1)
			     4				regStack substr regStack, (??0064 + 1)
			     4			endif
			     4			exitm ??0065
			     3		%	for ??0063, __popRegs(regStack) 
			     3				pop ??0063
			     3			endm
 04A8  5B		     4				pop bx
 04A9  58		     4				pop ax
			     1			
 04AA  74 06		   *	    je     @C0036
			     1			.if (!zero?)
 04AC  83 C6 04		     1				add si, @SizeStr(UNDO)
 04AF  E9 01FF		     1				jmp ParseCommand@UNDO
 04B2			   *@C0036:
			     1			.endif
				
			     1			StartsWith <WRITE> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??006B     textequ <>
 = 			     3			??006C textequ <>
			     3			for       ??006A, <ax,bx>
			     3				push  ??006A
			     3				??006C catstr <??006A>, ??006B, ??006C
			     3				??006B catstr <, >
			     3			endm
 04B2  50		     4				push  ax
 = ax			     4				??006C catstr <ax>, ??006B, ??006C
 = , 			     4				??006B catstr <, >
 04B3  53		     4				push  bx
 = bx, ax		     4				??006C catstr <bx>, ??006B, ??006C
 = , 			     4				??006B catstr <, >
 = <bx, ax>		     3			??006C catstr OPEN_DELIMITER, ??006C, CLOSE_DELIMITER
			     3			__pushRegs ??006C
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??006C
			     4			else
			     4				regStack catstr ??006C, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0066 = 0
			     2			
 04B4  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0066]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0068
			     2	
			     2				??0066 = ??0066 + 1
			     2			endm 
 04B6  8A 07		     3				mov al, [bx+??0066]
 04B8  24 DF		     3				and al, 11011111b ; toUpperCase
 04BA  3C 57		     3				cmp al, 'W'
 04BC  75 29		     3				jne ??0068
			     3	
 = 0001			     3				??0066 = ??0066 + 1
 04BE  8A 47 01		     3				mov al, [bx+??0066]
 04C1  24 DF		     3				and al, 11011111b ; toUpperCase
 04C3  3C 52		     3				cmp al, 'R'
 04C5  75 20		     3				jne ??0068
			     3	
 = 0002			     3				??0066 = ??0066 + 1
 04C7  8A 47 02		     3				mov al, [bx+??0066]
 04CA  24 DF		     3				and al, 11011111b ; toUpperCase
 04CC  3C 49		     3				cmp al, 'I'
 04CE  75 17		     3				jne ??0068
			     3	
 = 0003			     3				??0066 = ??0066 + 1
 04D0  8A 47 03		     3				mov al, [bx+??0066]
 04D3  24 DF		     3				and al, 11011111b ; toUpperCase
 04D5  3C 54		     3				cmp al, 'T'
 04D7  75 0E		     3				jne ??0068
			     3	
 = 0004			     3				??0066 = ??0066 + 1
 04D9  8A 47 04		     3				mov al, [bx+??0066]
 04DC  24 DF		     3				and al, 11011111b ; toUpperCase
 04DE  3C 45		     3				cmp al, 'E'
 04E0  75 05		     3				jne ??0068
			     3	
 = 0005			     3				??0066 = ??0066 + 1
 04E2  B8 0001		     2			mov ax, 1
			     2	
 04E5  EB 03		     2			jmp ??0069
 04E7			     2			??0068:
 04E7  B8 0000		     2				mov ax, 0
			     2	
 04EA			     2			??0069:
 04EA  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??006E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??006E eq 0
 = <bx, ax>		     4				??006F     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??006F substr regStack, 1, (??006E - 1)
			     4				regStack substr regStack, (??006E + 1)
			     4			endif
			     4			exitm ??006F
			     3		%	for ??006D, __popRegs(regStack) 
			     3				pop ??006D
			     3			endm
 04ED  5B		     4				pop bx
 04EE  58		     4				pop ax
			     1			
 04EF  74 06		   *	    je     @C0038
			     1			.if (!zero?)
 04F1  83 C6 05		     1				add si, @SizeStr(WRITE)
 04F4  E9 01BF		     1				jmp ParseCommand@WRITE
 04F7			   *@C0038:
			     1			.endif
					ParseCommand@UNDO:
			     1			StartsWith <EXIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0075     textequ <>
 = 			     3			??0076 textequ <>
			     3			for       ??0074, <ax,bx>
			     3				push  ??0074
			     3				??0076 catstr <??0074>, ??0075, ??0076
			     3				??0075 catstr <, >
			     3			endm
 04F7  50		     4				push  ax
 = ax			     4				??0076 catstr <ax>, ??0075, ??0076
 = , 			     4				??0075 catstr <, >
 04F8  53		     4				push  bx
 = bx, ax		     4				??0076 catstr <bx>, ??0075, ??0076
 = , 			     4				??0075 catstr <, >
 = <bx, ax>		     3			??0076 catstr OPEN_DELIMITER, ??0076, CLOSE_DELIMITER
			     3			__pushRegs ??0076
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0076
			     4			else
			     4				regStack catstr ??0076, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0070 = 0
			     2			
 04F9  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??0070]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0072
			     2	
			     2				??0070 = ??0070 + 1
			     2			endm 
 04FB  8A 07		     3				mov al, [bx+??0070]
 04FD  24 DF		     3				and al, 11011111b ; toUpperCase
 04FF  3C 45		     3				cmp al, 'E'
 0501  75 20		     3				jne ??0072
			     3	
 = 0001			     3				??0070 = ??0070 + 1
 0503  8A 47 01		     3				mov al, [bx+??0070]
 0506  24 DF		     3				and al, 11011111b ; toUpperCase
 0508  3C 58		     3				cmp al, 'X'
 050A  75 17		     3				jne ??0072
			     3	
 = 0002			     3				??0070 = ??0070 + 1
 050C  8A 47 02		     3				mov al, [bx+??0070]
 050F  24 DF		     3				and al, 11011111b ; toUpperCase
 0511  3C 49		     3				cmp al, 'I'
 0513  75 0E		     3				jne ??0072
			     3	
 = 0003			     3				??0070 = ??0070 + 1
 0515  8A 47 03		     3				mov al, [bx+??0070]
 0518  24 DF		     3				and al, 11011111b ; toUpperCase
 051A  3C 54		     3				cmp al, 'T'
 051C  75 05		     3				jne ??0072
			     3	
 = 0004			     3				??0070 = ??0070 + 1
 051E  B8 0001		     2			mov ax, 1
			     2	
 0521  EB 03		     2			jmp ??0073
 0523			     2			??0072:
 0523  B8 0000		     2				mov ax, 0
			     2	
 0526			     2			??0073:
 0526  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0078 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0078 eq 0
 = <bx, ax>		     4				??0079     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0079 substr regStack, 1, (??0078 - 1)
			     4				regStack substr regStack, (??0078 + 1)
			     4			endif
			     4			exitm ??0079
			     3		%	for ??0077, __popRegs(regStack) 
			     3				pop ??0077
			     3			endm
 0529  5B		     4				pop bx
 052A  58		     4				pop ax
			     1			
 052B  74 06		   *	    je     @C003A
			     1			.if (!zero?)
 052D  83 C6 04		     1				add si, @SizeStr(EXIT)
 0530  E9 019A		     1				jmp ParseCommand@EXIT
 0533			   *@C003A:
			     1			.endif
						mov ax, CMD_UNDO
			     1			StartsWith <QUIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??007F     textequ <>
 = 			     3			??0080 textequ <>
			     3			for       ??007E, <ax,bx>
			     3				push  ??007E
			     3				??0080 catstr <??007E>, ??007F, ??0080
			     3				??007F catstr <, >
			     3			endm
 0533  50		     4				push  ax
 = ax			     4				??0080 catstr <ax>, ??007F, ??0080
 = , 			     4				??007F catstr <, >
 0534  53		     4				push  bx
 = bx, ax		     4				??0080 catstr <bx>, ??007F, ??0080
 = , 			     4				??007F catstr <, >
 = <bx, ax>		     3			??0080 catstr OPEN_DELIMITER, ??0080, CLOSE_DELIMITER
			     3			__pushRegs ??0080
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0080
			     4			else
			     4				regStack catstr ??0080, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??007A = 0
			     2			
 0535  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??007A]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007C
			     2	
			     2				??007A = ??007A + 1
			     2			endm 
 0537  8A 07		     3				mov al, [bx+??007A]
 0539  24 DF		     3				and al, 11011111b ; toUpperCase
 053B  3C 51		     3				cmp al, 'Q'
 053D  75 20		     3				jne ??007C
			     3	
 = 0001			     3				??007A = ??007A + 1
 053F  8A 47 01		     3				mov al, [bx+??007A]
 0542  24 DF		     3				and al, 11011111b ; toUpperCase
 0544  3C 55		     3				cmp al, 'U'
 0546  75 17		     3				jne ??007C
			     3	
 = 0002			     3				??007A = ??007A + 1
 0548  8A 47 02		     3				mov al, [bx+??007A]
 054B  24 DF		     3				and al, 11011111b ; toUpperCase
 054D  3C 49		     3				cmp al, 'I'
 054F  75 0E		     3				jne ??007C
			     3	
 = 0003			     3				??007A = ??007A + 1
 0551  8A 47 03		     3				mov al, [bx+??007A]
 0554  24 DF		     3				and al, 11011111b ; toUpperCase
 0556  3C 54		     3				cmp al, 'T'
 0558  75 05		     3				jne ??007C
			     3	
 = 0004			     3				??007A = ??007A + 1
 055A  B8 0001		     2			mov ax, 1
			     2	
 055D  EB 03		     2			jmp ??007D
 055F			     2			??007C:
 055F  B8 0000		     2				mov ax, 0
			     2	
 0562			     2			??007D:
 0562  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0082 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0082 eq 0
 = <bx, ax>		     4				??0083     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0083 substr regStack, 1, (??0082 - 1)
			     4				regStack substr regStack, (??0082 + 1)
			     4			endif
			     4			exitm ??0083
			     3		%	for ??0081, __popRegs(regStack) 
			     3				pop ??0081
			     3			endm
 0565  5B		     4				pop bx
 0566  58		     4				pop ax
			     1			
 0567  74 06		   *	    je     @C003C
			     1			.if (!zero?)
 0569  83 C6 04		     1				add si, @SizeStr(QUIT)
 056C  E9 015E		     1				jmp ParseCommand@EXIT
 056F			   *@C003C:
			     1			.endif
						jmp ParseCommand@success
				
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 056F  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if DEFINED(@Comando)
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0085     textequ <>
 = 			     4			??0086 textequ <>
			     4			for       ??0084, <ax>
			     4				push  ??0084
			     4				??0086 catstr <??0084>, ??0085, ??0086
			     4				??0085 catstr <, >
			     4			endm
 0573  50		     5				push  ax
 = ax			     5				??0086 catstr <ax>, ??0085, ??0086
 = , 			     5				??0085 catstr <, >
 = <ax>			     4			??0086 catstr OPEN_DELIMITER, ??0086, CLOSE_DELIMITER
			     4			__pushRegs ??0086
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0086
			     5			else
			     5				regStack catstr ??0086, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@Comando>, <si>
 0574  8D 36 0310 R	     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0578			   *@C003E:
			     3			.repeat
 0578  8A 04		     3				mov al,   [si]
 057A  88 05		     3				mov [di], al
 057C  46		     3				inc si
 057D  47		     3				inc di
 057E  0A C0		   *	    or	al, al
 0580  75 F6		   *	    jne    @C003E
			     3			.until (al == 0)
 0582  4E		     3			dec    si
 0583  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??0088 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0088 eq 0
 = <ax>			     5				??0089     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??0089 substr regStack, 1, (??0088 - 1)
			     5				regStack substr regStack, (??0088 + 1)
			     5			endif
			     5			exitm ??0089
			     4		%	for ??0087, __popRegs(regStack) 
			     4				pop ??0087
			     4			endm
 0584  58		     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if DEFINED(@space)
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??008B     textequ <>
 = 			     4			??008C textequ <>
			     4			for       ??008A, <ax>
			     4				push  ??008A
			     4				??008C catstr <??008A>, ??008B, ??008C
			     4				??008B catstr <, >
			     4			endm
 0585  50		     5				push  ax
 = ax			     5				??008C catstr <ax>, ??008B, ??008C
 = , 			     5				??008B catstr <, >
 = <ax>			     4			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     4			__pushRegs ??008C
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??008C
			     5			else
			     5				regStack catstr ??008C, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@space>, <si>
 0586  8D 36 0345 R	     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 058A			   *@C0040:
			     3			.repeat
 058A  8A 04		     3				mov al,   [si]
 058C  88 05		     3				mov [di], al
 058E  46		     3				inc si
 058F  47		     3				inc di
 0590  0A C0		   *	    or	al, al
 0592  75 F6		   *	    jne    @C0040
			     3			.until (al == 0)
 0594  4E		     3			dec    si
 0595  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??008E instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??008E eq 0
 = <ax>			     5				??008F     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??008F substr regStack, 1, (??008E - 1)
			     5				regStack substr regStack, (??008E + 1)
			     5			endif
			     5			exitm ??008F
			     4		%	for ??008D, __popRegs(regStack) 
			     4				pop ??008D
			     4			endm
 0596  58		     5				pop ax
			     2				else
			     2					strcpy_c <@space>, di
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if DEFINED(@desconhecido)
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0091     textequ <>
 = 			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
 0597  50		     5				push  ax
 = ax			     5				??0092 catstr <ax>, ??0091, ??0092
 = , 			     5				??0091 catstr <, >
 = <ax>			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
 0598  8D 36 0338 R	     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 059C			   *@C0042:
			     3			.repeat
 059C  8A 04		     3				mov al,   [si]
 059E  88 05		     3				mov [di], al
 05A0  46		     3				inc si
 05A1  47		     3				inc di
 05A2  0A C0		   *	    or	al, al
 05A4  75 F6		   *	    jne    @C0042
			     3			.until (al == 0)
 05A6  4E		     3			dec    si
 05A7  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
 = <ax>			     5				??0095     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)
			     5				regStack substr regStack, (??0094 + 1)
			     5			endif
			     5			exitm ??0095
			     4		%	for ??0093, __popRegs(regStack) 
			     4				pop ??0093
			     4			endm
 05A8  58		     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0097     textequ <>
 = 			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
 05A9  50		     5				push  ax
 = ax			     5				??0098 catstr <ax>, ??0097, ??0098
 = , 			     5				??0097 catstr <, >
 = <ax>			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 05AA  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05AE			   *@C0044:
			     3			.repeat
 05AE  8A 04		     3				mov al,   [si]
 05B0  88 05		     3				mov [di], al
 05B2  46		     3				inc si
 05B3  47		     3				inc di
 05B4  0A C0		   *	    or	al, al
 05B6  75 F6		   *	    jne    @C0044
			     3			.until (al == 0)
 05B8  4E		     3			dec    si
 05B9  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
 = <ax>			     5				??009B     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)
			     5				regStack substr regStack, (??009A + 1)
			     5			endif
			     5			exitm ??009B
			     4		%	for ??0099, __popRegs(regStack) 
			     4				pop ??0099
			     4			endm
 05BA  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??009D     textequ <>
 = 			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
 05BB  50		     5				push  ax
 = ax			     5				??009E catstr <ax>, ??009D, ??009E
 = , 			     5				??009D catstr <, >
 = <ax>			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 05BC  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05C0			   *@C0046:
			     3			.repeat
 05C0  8A 04		     3				mov al,   [si]
 05C2  88 05		     3				mov [di], al
 05C4  46		     3				inc si
 05C5  47		     3				inc di
 05C6  0A C0		   *	    or	al, al
 05C8  75 F6		   *	    jne    @C0046
			     3			.until (al == 0)
 05CA  4E		     3			dec    si
 05CB  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
 = <ax>			     5				??00A1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)
			     5				regStack substr regStack, (??00A0 + 1)
			     5			endif
			     5			exitm ??00A1
			     4		%	for ??009F, __popRegs(regStack) 
			     4				pop ??009F
			     4			endm
 05CC  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
 05CD					ParseCommand@WRITE:
 05CD  F9					SkipSpacesInSI si
						
 05CE  5D		   *	    pop    bp
 05CF  5F		   *	    pop    di
 05D0  5E		   *	    pop    si
 05D1  8B E5		   *	    mov    sp, bp
 05D3  5D		   *	    pop    bp
 05D4  C3		   *	    ret    00000h
 05D5						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
			     1			SkipSpacesInSI si
 05D5  EB 01		   *	    jmp    @C0048
 05D7			   *@C0049:
			     2			.while (BYTE PTR [si] == ' ' )
 05D7  46		     2				inc si
 05D8			   *@C0048:
 05D8  80 3C 20		   *	    cmp    byte ptr [si], ' '
 05DB  74 FA		   *	    je     @C0049
			     2			.endw
 05DD  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 05E0  50		   *	    push   ax
 05E1  56		   *	    push   si
 05E2  E8 FDB9		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 05E5  73 03		   *	    jae    @C004B
			     1			.if            (carry?)
 05E7  F9		     1				stc
 05E8  EB 04		   *	    jmp    @C004D
 05EA			   *@C004B:
			     1			.else
 05EA  8B 5E FE		     1				mov bx, a
 05ED  F8		     1				clc
 05EE			   *@C004D:
			     1			.endif
							inc si
 05EE  73 07		   *	    jae    @C004E
 05F0  E8 012E					.endw
 05F3  EB D8					jmp ParseCommand@success
				
 05F5  EB 17		   *	    jmp    @C0050
 05F7			   *@C004E:
 05F7  3A 1E 03C7 R	   *	    cmp    bl, N
 05FB  76 07		   *	    jbe    @C0051
 05FD  E8 04B1				ParseCommand@EXIT:
 0600  EB CB					jmp ParseCommand@success
				
 0602  EB 0A		   *	    jmp    @C0053
 0604			   *@C0051:
 0604  80 FB 01		   *	    cmp    bl, 001h
 0607  73 05		   *	    jae    @C0054
 0609  E8 04A5				ParseCommand@success:
 060C  EB BF					SkipSpacesInSI si
						
 060E			   *@C0054:
 060E			   *@C0053:
 060E			   *@C0050:
						.if (byte ptr [si] != 0)
						
			     1			SkipSpacesInSI si
 060E  EB 01		   *	    jmp    @C0056
 0610			   *@C0057:
			     2			.while (BYTE PTR [si] == ' ' )
 0610  46		     2				inc si
 0611			   *@C0056:
 0611  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0614  74 FA		   *	    je     @C0057
			     2			.endw
 0616  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 0619  50		   *	    push   ax
 061A  56		   *	    push   si
 061B  E8 FD80		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 061E  73 03		   *	    jae    @C0059
			     1			.if            (carry?)
 0620  F9		     1				stc
 0621  EB 04		   *	    jmp    @C005B
 0623			   *@C0059:
			     1			.else
 0623  8B 4E FE		     1				mov cx, a
 0626  F8		     1				clc
 0627			   *@C005B:
			     1			.endif
							strcpy_all                                          NonTerminalErrorBuffer, \
 0627  73 05		   *	    jae    @C005C
 0629  E8 01CF						<@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
 062C  EB 9F						
							jmp ParseCommand@error
 062E			   *@C005C:
						.endif
 062E  B8 0001					clc
						ret
 0631  E9 009B				ParseCommand endp
				
 0634				
					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			SkipSpacesInSI si
 0634  EB 01		   *	    jmp    @C005E
 0636			   *@C005F:
			     2			.while (BYTE PTR [si] == ' ' )
 0636  46		     2				inc si
 0637			   *@C005E:
 0637  80 3C 20		   *	    cmp    byte ptr [si], ' '
 063A  74 FA		   *	    je     @C005F
			     2			.endw
 063C  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 063F  50		   *	    push   ax
 0640  56		   *	    push   si
 0641  E8 FD5A		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 0644  73 03		   *	    jae    @C0061
			     1			.if            (carry?)
 0646  F9		     1				stc
 0647  EB 04		   *	    jmp    @C0063
 0649			   *@C0061:
			     1			.else
 0649  8B 5E FE		     1				mov bx, a
 064C  F8		     1				clc
 064D			   *@C0063:
			     1			.endif
						ret
 064D  73 08		   *	    jae    @C0064
 064F  E8 028F				ParseCommand@LINHA_AUSENTE endp
 0652  E9 FF78			
					ParseCommand@CONSTANTE_AUSENTE proc near
 0655  EB 19		   *	    jmp    @C0066
 0657			   *@C0064:
 0657  3A 1E 03C7 R	   *	    cmp    bl, N
 065B  76 08		   *	    jbe    @C0067
 065D  E8 04BD					ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
 0660  E9 FF6A					ret
					ParseCommand@CONSTANTE_AUSENTE endp
 0663  EB 0B		   *	    jmp    @C0069
 0665			   *@C0067:
 0665  80 FB 01		   *	    cmp    bl, 001h
 0668  73 06		   *	    jae    @C006A
 066A  E8 04B0				
 066D  E9 FF5D				ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
 0670			   *@C006A:
 0670			   *@C0069:
 0670			   *@C0066:
						ret
					ParseCommand@LINHA_DST_AUSENTE endp
			     1			SkipSpacesInSI si
 0670  EB 01		   *	    jmp    @C006C
 0672			   *@C006D:
			     2			.while (BYTE PTR [si] == ' ' )
 0672  46		     2				inc si
 0673			   *@C006C:
 0673  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0676  74 FA		   *	    je     @C006D
			     2			.endw
 0678  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 067B  50		   *	    push   ax
 067C  56		   *	    push   si
 067D  E8 FD1E		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 0680  73 03		   *	    jae    @C006F
			     1			.if            (carry?)
 0682  F9		     1				stc
 0683  EB 04		   *	    jmp    @C0071
 0685			   *@C006F:
			     1			.else
 0685  8B 4E FE		     1				mov cx, a
 0688  F8		     1				clc
 0689			   *@C0071:
			     1			.endif
				
 0689  73 08		   *	    jae    @C0072
 068B  E8 033D				ParseCommand@LINHA_ORG_AUSENTE proc near
 068E  E9 FF3C					ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
						ret
 0691  EB 19		   *	    jmp    @C0074
 0693			   *@C0072:
 0693  3A 1E 03C7 R	   *	    cmp    bl, N
 0697  76 08		   *	    jbe    @C0075
 0699  E8 04FD				ParseCommand@LINHA_ORG_AUSENTE endp
 069C  E9 FF2E			
					ParseCommand@LINHA_INVALIDA proc near
 069F  EB 0B		   *	    jmp    @C0077
 06A1			   *@C0075:
 06A1  80 FB 01		   *	    cmp    bl, 001h
 06A4  73 06		   *	    jae    @C0078
 06A6  E8 04F0					ErrorNumberOutOfBounds <LINHA>
 06A9  E9 FF21					ret
					ParseCommand@LINHA_INVALIDA endp
 06AC			   *@C0078:
 06AC			   *@C0077:
 06AC			   *@C0074:
				
 06AC  B8 0003				ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
 06AF  EB 1E					ret
					ParseCommand@LINHA_DST_INVALIDA endp
 06B1				
 06B1  B8 0005				ParseCommand@LINHA_ORG_INVALIDA proc near
 06B4  EB 19					ErrorNumberOutOfBounds <LINHA_ORG>
						ret
 06B6					ParseCommand@LINHA_ORG_INVALIDA endp
				
 06B6  EB 01		   *	    jmp    @C007A
 06B8			   *@C007B:
			     1			.while (BYTE PTR [si] == ' ' )
 06B8  46		     1				inc si
 06B9			   *@C007A:
 06B9  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06BC  74 FA		   *	    je     @C007B
			     1			.endw
				
 06BE  8B D6			
 06C0  B8 0006			;====================================================================
				; Reading error reporting
 06C3  EB 01		   *	    jmp    @C007D
 06C5			   *@C007E:
 06C5  46				ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
 06C6			   *@C007D:
 06C6  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06C9  75 FA		   *	    jne    @C007E
 06CB  EB 02					jmp      ExitFailure
				
 06CD					ErrorRead:
 06CD  EB 00					printf_c <Erro na leitura do arquivo.>
						jmp      ExitFailure
 06CF				
					ErrorColumnCount:
 06CF  EB 01		   *	    jmp    @C0080
 06D1			   *@C0081:
			     1			.while (BYTE PTR [si] == ' ' )
 06D1  46		     1				inc si
 06D2			   *@C0080:
 06D2  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06D5  74 FA		   *	    je     @C0081
			     1			.endw
						print_FilePosition
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
 06D7  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06DA  74 3D		   *	    je     @C0083
						jmp      ExitFailure
				
					ErrorRowCount:
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 06DC  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if DEFINED(@@parametros_nao_reconhecidos_ao_final_do_comando)
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A3     textequ <>
 = 			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
 06E0  50		     5				push  ax
 = ax			     5				??00A4 catstr <ax>, ??00A3, ??00A4
 = , 			     5				??00A3 catstr <, >
 = <ax>			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
 06E1  8D 36 0388 R	     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06E5			   *@C0085:
			     3			.repeat
 06E5  8A 04		     3				mov al,   [si]
 06E7  88 05		     3				mov [di], al
 06E9  46		     3				inc si
 06EA  47		     3				inc di
 06EB  0A C0		   *	    or	al, al
 06ED  75 F6		   *	    jne    @C0085
			     3			.until (al == 0)
 06EF  4E		     3			dec    si
 06F0  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
 = <ax>			     5				??00A7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)
			     5				regStack substr regStack, (??00A6 + 1)
			     5			endif
			     5			exitm ??00A7
			     4		%	for ??00A5, __popRegs(regStack) 
			     4				pop ??00A5
			     4			endm
 06F1  58		     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A9     textequ <>
 = 			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
 06F2  50		     5				push  ax
 = ax			     5				??00AA catstr <ax>, ??00A9, ??00AA
 = , 			     5				??00A9 catstr <, >
 = <ax>			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 06F3  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06F7			   *@C0087:
			     3			.repeat
 06F7  8A 04		     3				mov al,   [si]
 06F9  88 05		     3				mov [di], al
 06FB  46		     3				inc si
 06FC  47		     3				inc di
 06FD  0A C0		   *	    or	al, al
 06FF  75 F6		   *	    jne    @C0087
			     3			.until (al == 0)
 0701  4E		     3			dec    si
 0702  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
 = <ax>			     5				??00AD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)
			     5				regStack substr regStack, (??00AC + 1)
			     5			endif
			     5			exitm ??00AD
			     4		%	for ??00AB, __popRegs(regStack) 
			     4				pop ??00AB
			     4			endm
 0703  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00AF     textequ <>
 = 			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
 0704  50		     5				push  ax
 = ax			     5				??00B0 catstr <ax>, ??00AF, ??00B0
 = , 			     5				??00AF catstr <, >
 = <ax>			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 0705  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0709			   *@C0089:
			     3			.repeat
 0709  8A 04		     3				mov al,   [si]
 070B  88 05		     3				mov [di], al
 070D  46		     3				inc si
 070E  47		     3				inc di
 070F  0A C0		   *	    or	al, al
 0711  75 F6		   *	    jne    @C0089
			     3			.until (al == 0)
 0713  4E		     3			dec    si
 0714  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
 = <ax>			     5				??00B3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)
			     5				regStack substr regStack, (??00B2 + 1)
			     5			endif
			     5			exitm ??00B3
			     4		%	for ??00B1, __popRegs(regStack) 
			     4				pop ??00B1
			     4			endm
 0715  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
 0716  E9 FEB4					print_TotalRowCol
						jmp      ExitFailure
 0719			   *@C0083:
 0719  F8			
					ErrorUnexpectedChar:
 071A  5D		   *	    pop    bp
 071B  5F		   *	    pop    di
 071C  5E		   *	    pop    si
 071D  8B E5		   *	    mov    sp, bp
 071F  5D		   *	    pop    bp
 0720  C3		   *	    ret    00000h
 0721						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
				
 0721						print_FilePosition
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< LINHA !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 0721  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00B5     textequ <>
			     5			??00B6 textequ <>
			     5			for       ??00B4, <ax>
			     5				push  ??00B4
			     5				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     5				??00B5 catstr <, >
 0725  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00B6 catstr <ax>, ??00B5, ??00B6
 = <ax>			     5				??00B5 catstr <, >
			     5			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00B6
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00B6
			     6			else
			     6				regStack catstr ??00B6, REG_SET_DELIMITER, regStack
			     4			endif
 0726  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 072A			   *@C008B:
			     4			endif
 072A  8A 04		     4			.repeat
 072C  88 05		     4				mov al,   [si]
 072E  46		     4				mov [di], al
 072F  47		     4				inc si
 0730  0A C0		   *	    or	al, al
 0732  75 F6		   *	    jne    @C008B
			     4				inc di
 0734  4E		     4			.until (al == 0)
 0735  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00B8 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00B8 eq 0
 = 			     6				??00B9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00B9 substr regStack, 1, (??00B8 - 1)
			     6				regStack substr regStack, (??00B8 + 1)
			     6			endif
			     5			exitm ??00B9
			     5		%	for ??00B7, __popRegs(regStack) 
			     5				pop ??00B7
 0736  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0737  C6 05 20		     5			endm
 073A  47		     5				mov byte ptr [di], ' '
 073B  C6 05 22		     5				inc di
 073E  47		     5				mov byte ptr [di], '"'
 073F  C6 05 4D		     5				inc di
 0742  47		     5				mov byte ptr [di], 'M'
 0743  C6 05 55		     5				inc di
 0746  47		     5				mov byte ptr [di], 'U'
 0747  C6 05 4C		     5				inc di
 074A  47		     5				mov byte ptr [di], 'L'
 074B  C6 05 22		     5				inc di
 074E  47		     5				mov byte ptr [di], '"'
 074F  C6 05 20		     5				inc di
 0752  47		     5				mov byte ptr [di], ' '
 0753  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00BB     textequ <>
			     5			??00BC textequ <>
			     5			for       ??00BA, <ax>
			     5				push  ??00BA
			     5				??00BC catstr <??00BA>, ??00BB, ??00BC
			     5				??00BB catstr <, >
 0756  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00BC catstr <ax>, ??00BB, ??00BC
 = <ax>			     5				??00BB catstr <, >
			     5			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00BC
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00BC
			     6			else
			     6				regStack catstr ??00BC, REG_SET_DELIMITER, regStack
			     4			endif
 0757  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 075B			   *@C008D:
			     4			endif
 075B  8A 04		     4			.repeat
 075D  88 05		     4				mov al,   [si]
 075F  46		     4				mov [di], al
 0760  47		     4				inc si
 0761  0A C0		   *	    or	al, al
 0763  75 F6		   *	    jne    @C008D
			     4				inc di
 0765  4E		     4			.until (al == 0)
 0766  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00BE instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00BE eq 0
 = 			     6				??00BF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00BF substr regStack, 1, (??00BE - 1)
			     6				regStack substr regStack, (??00BE + 1)
			     6			endif
			     5			exitm ??00BF
			     5		%	for ??00BD, __popRegs(regStack) 
			     5				pop ??00BD
 0767  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0768  C6 05 20		     5			endm
 076B  47		     5				mov byte ptr [di], ' '
 076C  C6 05 4C		     5				inc di
 076F  47		     5				mov byte ptr [di], 'L'
 0770  C6 05 49		     5				inc di
 0773  47		     5				mov byte ptr [di], 'I'
 0774  C6 05 4E		     5				inc di
 0777  47		     5				mov byte ptr [di], 'N'
 0778  C6 05 48		     5				inc di
 077B  47		     5				mov byte ptr [di], 'H'
 077C  C6 05 41		     5				inc di
 077F  47		     5				mov byte ptr [di], 'A'
 0780  C6 05 20		     5				inc di
 0783  47		     5				mov byte ptr [di], ' '
 0784  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
 0787  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C2 catstr <ax>, ??00C1, ??00C2
 = <ax>			     5				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack
			     4			endif
 0788  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 078C			   *@C008F:
			     4			endif
 078C  8A 04		     4			.repeat
 078E  88 05		     4				mov al,   [si]
 0790  46		     4				mov [di], al
 0791  47		     4				inc si
 0792  0A C0		   *	    or	al, al
 0794  75 F6		   *	    jne    @C008F
			     4				inc di
 0796  4E		     4			.until (al == 0)
 0797  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00C4 eq 0
 = 			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)
			     6				regStack substr regStack, (??00C4 + 1)
			     6			endif
			     5			exitm ??00C5
			     5		%	for ??00C3, __popRegs(regStack) 
			     5				pop ??00C3
 0798  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0799  C6 05 20		     5			endm
 079C  47		     5				mov byte ptr [di], ' '
 079D  C6 05 50		     5				inc di
 07A0  47		     5				mov byte ptr [di], 'P'
 07A1  C6 05 52		     5				inc di
 07A4  47		     5				mov byte ptr [di], 'R'
 07A5  C6 05 49		     5				inc di
 07A8  47		     5				mov byte ptr [di], 'I'
 07A9  C6 05 4D		     5				inc di
 07AC  47		     5				mov byte ptr [di], 'M'
 07AD  C6 05 45		     5				inc di
 07B0  47		     5				mov byte ptr [di], 'E'
 07B1  C6 05 49		     5				inc di
 07B4  47		     5				mov byte ptr [di], 'I'
 07B5  C6 05 52		     5				inc di
 07B8  47		     5				mov byte ptr [di], 'R'
 07B9  C6 05 4F		     5				inc di
 07BC  47		     5				mov byte ptr [di], 'O'
 07BD  C6 05 20		     5				inc di
 07C0  47		     5				mov byte ptr [di], ' '
 07C1  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
 07C4  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C8 catstr <ax>, ??00C7, ??00C8
 = <ax>			     5				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack
			     4			endif
 07C5  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07C9			   *@C0091:
			     4			endif
 07C9  8A 04		     4			.repeat
 07CB  88 05		     4				mov al,   [si]
 07CD  46		     4				mov [di], al
 07CE  47		     4				inc si
 07CF  0A C0		   *	    or	al, al
 07D1  75 F6		   *	    jne    @C0091
			     4				inc di
 07D3  4E		     4			.until (al == 0)
 07D4  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00CA eq 0
 = 			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)
			     6				regStack substr regStack, (??00CA + 1)
			     6			endif
			     5			exitm ??00CB
			     5		%	for ??00C9, __popRegs(regStack) 
			     5				pop ??00C9
 07D5  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
 07D6  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00CE catstr <ax>, ??00CD, ??00CE
 = <ax>			     5				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00CE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack
			     4			endif
 07D7  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07DB			   *@C0093:
			     4			endif
 07DB  8A 04		     4			.repeat
 07DD  88 05		     4				mov al,   [si]
 07DF  46		     4				mov [di], al
 07E0  47		     4				inc si
 07E1  0A C0		   *	    or	al, al
 07E3  75 F6		   *	    jne    @C0093
			     4				inc di
 07E5  4E		     4			.until (al == 0)
 07E6  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D0 eq 0
 = 			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)
			     6				regStack substr regStack, (??00D0 + 1)
			     6			endif
			     5			exitm ??00D1
			     5		%	for ??00CF, __popRegs(regStack) 
			     5				pop ??00CF
 07E7  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
 07E8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00D4 catstr <ax>, ??00D3, ??00D4
 = <ax>			     5				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00D4
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack
			     4			endif
 07E9  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07ED			   *@C0095:
			     4			endif
 07ED  8A 04		     4			.repeat
 07EF  88 05		     4				mov al,   [si]
 07F1  46		     4				mov [di], al
 07F2  47		     4				inc si
 07F3  0A C0		   *	    or	al, al
 07F5  75 F6		   *	    jne    @C0095
			     4				inc di
 07F7  4E		     4			.until (al == 0)
 07F8  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D6 eq 0
 = 			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)
			     6				regStack substr regStack, (??00D6 + 1)
			     6			endif
			     5			exitm ??00D7
			     5		%	for ??00D5, __popRegs(regStack) 
			     5				pop ??00D5
 07F9  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 07FA  C3					printf_c < Erro: caracter inexperado: ">
 07FB						invoke   printf_s, addr TheUnexpectedChar
				
 07FB						jmp ExitFailure
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< CONSTANTE !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 07FB  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
 07FF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00DA catstr <ax>, ??00D9, ??00DA
 = <ax>			     5				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00DA
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack
			     4			endif
 0800  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0804			   *@C0097:
			     4			endif
 0804  8A 04		     4			.repeat
 0806  88 05		     4				mov al,   [si]
 0808  46		     4				mov [di], al
 0809  47		     4				inc si
 080A  0A C0		   *	    or	al, al
 080C  75 F6		   *	    jne    @C0097
			     4				inc di
 080E  4E		     4			.until (al == 0)
 080F  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00DC eq 0
 = 			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)
			     6				regStack substr regStack, (??00DC + 1)
			     6			endif
			     5			exitm ??00DD
			     5		%	for ??00DB, __popRegs(regStack) 
			     5				pop ??00DB
 0810  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0811  C6 05 20		     5			endm
 0814  47		     5				mov byte ptr [di], ' '
 0815  C6 05 22		     5				inc di
 0818  47		     5				mov byte ptr [di], '"'
 0819  C6 05 4D		     5				inc di
 081C  47		     5				mov byte ptr [di], 'M'
 081D  C6 05 55		     5				inc di
 0820  47		     5				mov byte ptr [di], 'U'
 0821  C6 05 4C		     5				inc di
 0824  47		     5				mov byte ptr [di], 'L'
 0825  C6 05 22		     5				inc di
 0828  47		     5				mov byte ptr [di], '"'
 0829  C6 05 20		     5				inc di
 082C  47		     5				mov byte ptr [di], ' '
 082D  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
 0830  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E0 catstr <ax>, ??00DF, ??00E0
 = <ax>			     5				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E0
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack
			     4			endif
 0831  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0835			   *@C0099:
			     4			endif
 0835  8A 04		     4			.repeat
 0837  88 05		     4				mov al,   [si]
 0839  46		     4				mov [di], al
 083A  47		     4				inc si
 083B  0A C0		   *	    or	al, al
 083D  75 F6		   *	    jne    @C0099
			     4				inc di
 083F  4E		     4			.until (al == 0)
 0840  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E2 eq 0
 = 			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)
			     6				regStack substr regStack, (??00E2 + 1)
			     6			endif
			     5			exitm ??00E3
			     5		%	for ??00E1, __popRegs(regStack) 
			     5				pop ??00E1
 0841  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( CONSTANTE )
			     3					strcpy  CONSTANTE , di
			     3				else
			     4					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0842  C6 05 20		     5			endm
 0845  47		     5				mov byte ptr [di], ' '
 0846  C6 05 43		     5				inc di
 0849  47		     5				mov byte ptr [di], 'C'
 084A  C6 05 4F		     5				inc di
 084D  47		     5				mov byte ptr [di], 'O'
 084E  C6 05 4E		     5				inc di
 0851  47		     5				mov byte ptr [di], 'N'
 0852  C6 05 53		     5				inc di
 0855  47		     5				mov byte ptr [di], 'S'
 0856  C6 05 54		     5				inc di
 0859  47		     5				mov byte ptr [di], 'T'
 085A  C6 05 41		     5				inc di
 085D  47		     5				mov byte ptr [di], 'A'
 085E  C6 05 4E		     5				inc di
 0861  47		     5				mov byte ptr [di], 'N'
 0862  C6 05 54		     5				inc di
 0865  47		     5				mov byte ptr [di], 'T'
 0866  C6 05 45		     5				inc di
 0869  47		     5				mov byte ptr [di], 'E'
 086A  C6 05 20		     5				inc di
 086D  47		     5				mov byte ptr [di], ' '
 086E  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
 0871  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E6 catstr <ax>, ??00E5, ??00E6
 = <ax>			     5				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E6
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStack
			     4			endif
 0872  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0876			   *@C009B:
			     4			endif
 0876  8A 04		     4			.repeat
 0878  88 05		     4				mov al,   [si]
 087A  46		     4				mov [di], al
 087B  47		     4				inc si
 087C  0A C0		   *	    or	al, al
 087E  75 F6		   *	    jne    @C009B
			     4				inc di
 0880  4E		     4			.until (al == 0)
 0881  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E8 eq 0
 = 			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)
			     6				regStack substr regStack, (??00E8 + 1)
			     6			endif
			     5			exitm ??00E9
			     5		%	for ??00E7, __popRegs(regStack) 
			     5				pop ??00E7
 0882  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0883  C6 05 20		     5			endm
 0886  47		     5				mov byte ptr [di], ' '
 0887  C6 05 53		     5				inc di
 088A  47		     5				mov byte ptr [di], 'S'
 088B  C6 05 45		     5				inc di
 088E  47		     5				mov byte ptr [di], 'E'
 088F  C6 05 47		     5				inc di
 0892  47		     5				mov byte ptr [di], 'G'
 0893  C6 05 55		     5				inc di
 0896  47		     5				mov byte ptr [di], 'U'
 0897  C6 05 4E		     5				inc di
 089A  47		     5				mov byte ptr [di], 'N'
 089B  C6 05 44		     5				inc di
 089E  47		     5				mov byte ptr [di], 'D'
 089F  C6 05 4F		     5				inc di
 08A2  47		     5				mov byte ptr [di], 'O'
 08A3  C6 05 20		     5				inc di
 08A6  47		     5				mov byte ptr [di], ' '
 08A7  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
 08AA  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00EC catstr <ax>, ??00EB, ??00EC
 = <ax>			     5				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00EC
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack
			     4			endif
 08AB  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08AF			   *@C009D:
			     4			endif
 08AF  8A 04		     4			.repeat
 08B1  88 05		     4				mov al,   [si]
 08B3  46		     4				mov [di], al
 08B4  47		     4				inc si
 08B5  0A C0		   *	    or	al, al
 08B7  75 F6		   *	    jne    @C009D
			     4				inc di
 08B9  4E		     4			.until (al == 0)
 08BA  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00EE eq 0
 = 			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)
			     6				regStack substr regStack, (??00EE + 1)
			     6			endif
			     5			exitm ??00EF
			     5		%	for ??00ED, __popRegs(regStack) 
			     5				pop ??00ED
 08BB  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
 08BC  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F2 catstr <ax>, ??00F1, ??00F2
 = <ax>			     5				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStack
			     4			endif
 08BD  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08C1			   *@C009F:
			     4			endif
 08C1  8A 04		     4			.repeat
 08C3  88 05		     4				mov al,   [si]
 08C5  46		     4				mov [di], al
 08C6  47		     4				inc si
 08C7  0A C0		   *	    or	al, al
 08C9  75 F6		   *	    jne    @C009F
			     4				inc di
 08CB  4E		     4			.until (al == 0)
 08CC  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00F4 eq 0
 = 			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)
			     6				regStack substr regStack, (??00F4 + 1)
			     6			endif
			     5			exitm ??00F5
			     5		%	for ??00F3, __popRegs(regStack) 
			     5				pop ??00F3
 08CD  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
 08CE  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F8 catstr <ax>, ??00F7, ??00F8
 = <ax>			     5				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack
			     4			endif
 08CF  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08D3			   *@C00A1:
			     4			endif
 08D3  8A 04		     4			.repeat
 08D5  88 05		     4				mov al,   [si]
 08D7  46		     4				mov [di], al
 08D8  47		     4				inc si
 08D9  0A C0		   *	    or	al, al
 08DB  75 F6		   *	    jne    @C00A1
			     4				inc di
 08DD  4E		     4			.until (al == 0)
 08DE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00FA eq 0
 = 			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)
			     6				regStack substr regStack, (??00FA + 1)
			     6			endif
			     5			exitm ??00FB
			     5		%	for ??00F9, __popRegs(regStack) 
			     5				pop ??00F9
 08DF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 08E0  C3				ErrorInvalidN:
 08E1						print_FilePosition
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
 08E1						invoke   printf_u, N
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_DST !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 08E1  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
 08E5  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00FE catstr <ax>, ??00FD, ??00FE
 = <ax>			     5				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00FE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack
			     4			endif
 08E6  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08EA			   *@C00A3:
			     4			endif
 08EA  8A 04		     4			.repeat
 08EC  88 05		     4				mov al,   [si]
 08EE  46		     4				mov [di], al
 08EF  47		     4				inc si
 08F0  0A C0		   *	    or	al, al
 08F2  75 F6		   *	    jne    @C00A3
			     4				inc di
 08F4  4E		     4			.until (al == 0)
 08F5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0100 eq 0
 = 			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)
			     6				regStack substr regStack, (??0100 + 1)
			     6			endif
			     5			exitm ??0101
			     5		%	for ??00FF, __popRegs(regStack) 
			     5				pop ??00FF
 08F6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 08F7  C6 05 20		     5			endm
 08FA  47		     5				mov byte ptr [di], ' '
 08FB  C6 05 22		     5				inc di
 08FE  47		     5				mov byte ptr [di], '"'
 08FF  C6 05 41		     5				inc di
 0902  47		     5				mov byte ptr [di], 'A'
 0903  C6 05 44		     5				inc di
 0906  47		     5				mov byte ptr [di], 'D'
 0907  C6 05 44		     5				inc di
 090A  47		     5				mov byte ptr [di], 'D'
 090B  C6 05 22		     5				inc di
 090E  47		     5				mov byte ptr [di], '"'
 090F  C6 05 20		     5				inc di
 0912  47		     5				mov byte ptr [di], ' '
 0913  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
 0916  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0104 catstr <ax>, ??0103, ??0104
 = <ax>			     5				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0104
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack
			     4			endif
 0917  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 091B			   *@C00A5:
			     4			endif
 091B  8A 04		     4			.repeat
 091D  88 05		     4				mov al,   [si]
 091F  46		     4				mov [di], al
 0920  47		     4				inc si
 0921  0A C0		   *	    or	al, al
 0923  75 F6		   *	    jne    @C00A5
			     4				inc di
 0925  4E		     4			.until (al == 0)
 0926  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0106 eq 0
 = 			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)
			     6				regStack substr regStack, (??0106 + 1)
			     6			endif
			     5			exitm ??0107
			     5		%	for ??0105, __popRegs(regStack) 
			     5				pop ??0105
 0927  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0928  C6 05 20		     5			endm
 092B  47		     5				mov byte ptr [di], ' '
 092C  C6 05 4C		     5				inc di
 092F  47		     5				mov byte ptr [di], 'L'
 0930  C6 05 49		     5				inc di
 0933  47		     5				mov byte ptr [di], 'I'
 0934  C6 05 4E		     5				inc di
 0937  47		     5				mov byte ptr [di], 'N'
 0938  C6 05 48		     5				inc di
 093B  47		     5				mov byte ptr [di], 'H'
 093C  C6 05 41		     5				inc di
 093F  47		     5				mov byte ptr [di], 'A'
 0940  C6 05 5F		     5				inc di
 0943  47		     5				mov byte ptr [di], '_'
 0944  C6 05 44		     5				inc di
 0947  47		     5				mov byte ptr [di], 'D'
 0948  C6 05 53		     5				inc di
 094B  47		     5				mov byte ptr [di], 'S'
 094C  C6 05 54		     5				inc di
 094F  47		     5				mov byte ptr [di], 'T'
 0950  C6 05 20		     5				inc di
 0953  47		     5				mov byte ptr [di], ' '
 0954  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
 0957  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??010A catstr <ax>, ??0109, ??010A
 = <ax>			     5				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??010A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack
			     4			endif
 0958  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 095C			   *@C00A7:
			     4			endif
 095C  8A 04		     4			.repeat
 095E  88 05		     4				mov al,   [si]
 0960  46		     4				mov [di], al
 0961  47		     4				inc si
 0962  0A C0		   *	    or	al, al
 0964  75 F6		   *	    jne    @C00A7
			     4				inc di
 0966  4E		     4			.until (al == 0)
 0967  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??010C eq 0
 = 			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)
			     6				regStack substr regStack, (??010C + 1)
			     6			endif
			     5			exitm ??010D
			     5		%	for ??010B, __popRegs(regStack) 
			     5				pop ??010B
 0968  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0969  C6 05 20		     5			endm
 096C  47		     5				mov byte ptr [di], ' '
 096D  C6 05 50		     5				inc di
 0970  47		     5				mov byte ptr [di], 'P'
 0971  C6 05 52		     5				inc di
 0974  47		     5				mov byte ptr [di], 'R'
 0975  C6 05 49		     5				inc di
 0978  47		     5				mov byte ptr [di], 'I'
 0979  C6 05 4D		     5				inc di
 097C  47		     5				mov byte ptr [di], 'M'
 097D  C6 05 45		     5				inc di
 0980  47		     5				mov byte ptr [di], 'E'
 0981  C6 05 49		     5				inc di
 0984  47		     5				mov byte ptr [di], 'I'
 0985  C6 05 52		     5				inc di
 0988  47		     5				mov byte ptr [di], 'R'
 0989  C6 05 4F		     5				inc di
 098C  47		     5				mov byte ptr [di], 'O'
 098D  C6 05 20		     5				inc di
 0990  47		     5				mov byte ptr [di], ' '
 0991  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
 0994  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0110 catstr <ax>, ??010F, ??0110
 = <ax>			     5				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0110
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack
			     4			endif
 0995  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0999			   *@C00A9:
			     4			endif
 0999  8A 04		     4			.repeat
 099B  88 05		     4				mov al,   [si]
 099D  46		     4				mov [di], al
 099E  47		     4				inc si
 099F  0A C0		   *	    or	al, al
 09A1  75 F6		   *	    jne    @C00A9
			     4				inc di
 09A3  4E		     4			.until (al == 0)
 09A4  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0112 eq 0
 = 			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)
			     6				regStack substr regStack, (??0112 + 1)
			     6			endif
			     5			exitm ??0113
			     5		%	for ??0111, __popRegs(regStack) 
			     5				pop ??0111
 09A5  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
 09A6  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0116 catstr <ax>, ??0115, ??0116
 = <ax>			     5				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0116
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack
			     4			endif
 09A7  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09AB			   *@C00AB:
			     4			endif
 09AB  8A 04		     4			.repeat
 09AD  88 05		     4				mov al,   [si]
 09AF  46		     4				mov [di], al
 09B0  47		     4				inc si
 09B1  0A C0		   *	    or	al, al
 09B3  75 F6		   *	    jne    @C00AB
			     4				inc di
 09B5  4E		     4			.until (al == 0)
 09B6  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0118 eq 0
 = 			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)
			     6				regStack substr regStack, (??0118 + 1)
			     6			endif
			     5			exitm ??0119
			     5		%	for ??0117, __popRegs(regStack) 
			     5				pop ??0117
 09B7  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
 09B8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??011C catstr <ax>, ??011B, ??011C
 = <ax>			     5				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??011C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack
			     4			endif
 09B9  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09BD			   *@C00AD:
			     4			endif
 09BD  8A 04		     4			.repeat
 09BF  88 05		     4				mov al,   [si]
 09C1  46		     4				mov [di], al
 09C2  47		     4				inc si
 09C3  0A C0		   *	    or	al, al
 09C5  75 F6		   *	    jne    @C00AD
			     4				inc di
 09C7  4E		     4			.until (al == 0)
 09C8  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??011E eq 0
 = 			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)
			     6				regStack substr regStack, (??011E + 1)
			     6			endif
			     5			exitm ??011F
			     5		%	for ??011D, __popRegs(regStack) 
			     5				pop ??011D
 09C9  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 09CA  C3			
 09CB					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
 09CB						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_ORG !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 09CB  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
 09CF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0122 catstr <ax>, ??0121, ??0122
 = <ax>			     5				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0122
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack
			     4			endif
 09D0  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09D4			   *@C00AF:
			     4			endif
 09D4  8A 04		     4			.repeat
 09D6  88 05		     4				mov al,   [si]
 09D8  46		     4				mov [di], al
 09D9  47		     4				inc si
 09DA  0A C0		   *	    or	al, al
 09DC  75 F6		   *	    jne    @C00AF
			     4				inc di
 09DE  4E		     4			.until (al == 0)
 09DF  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0124 eq 0
 = 			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1)
			     6				regStack substr regStack, (??0124 + 1)
			     6			endif
			     5			exitm ??0125
			     5		%	for ??0123, __popRegs(regStack) 
			     5				pop ??0123
 09E0  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 09E1  C6 05 20		     5			endm
 09E4  47		     5				mov byte ptr [di], ' '
 09E5  C6 05 22		     5				inc di
 09E8  47		     5				mov byte ptr [di], '"'
 09E9  C6 05 41		     5				inc di
 09EC  47		     5				mov byte ptr [di], 'A'
 09ED  C6 05 44		     5				inc di
 09F0  47		     5				mov byte ptr [di], 'D'
 09F1  C6 05 44		     5				inc di
 09F4  47		     5				mov byte ptr [di], 'D'
 09F5  C6 05 22		     5				inc di
 09F8  47		     5				mov byte ptr [di], '"'
 09F9  C6 05 20		     5				inc di
 09FC  47		     5				mov byte ptr [di], ' '
 09FD  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
 0A00  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0128 catstr <ax>, ??0127, ??0128
 = <ax>			     5				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0128
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack
			     4			endif
 0A01  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A05			   *@C00B1:
			     4			endif
 0A05  8A 04		     4			.repeat
 0A07  88 05		     4				mov al,   [si]
 0A09  46		     4				mov [di], al
 0A0A  47		     4				inc si
 0A0B  0A C0		   *	    or	al, al
 0A0D  75 F6		   *	    jne    @C00B1
			     4				inc di
 0A0F  4E		     4			.until (al == 0)
 0A10  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??012A eq 0
 = 			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1)
			     6				regStack substr regStack, (??012A + 1)
			     6			endif
			     5			exitm ??012B
			     5		%	for ??0129, __popRegs(regStack) 
			     5				pop ??0129
 0A11  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A12  C6 05 20		     5			endm
 0A15  47		     5				mov byte ptr [di], ' '
 0A16  C6 05 4C		     5				inc di
 0A19  47		     5				mov byte ptr [di], 'L'
 0A1A  C6 05 49		     5				inc di
 0A1D  47		     5				mov byte ptr [di], 'I'
 0A1E  C6 05 4E		     5				inc di
 0A21  47		     5				mov byte ptr [di], 'N'
 0A22  C6 05 48		     5				inc di
 0A25  47		     5				mov byte ptr [di], 'H'
 0A26  C6 05 41		     5				inc di
 0A29  47		     5				mov byte ptr [di], 'A'
 0A2A  C6 05 5F		     5				inc di
 0A2D  47		     5				mov byte ptr [di], '_'
 0A2E  C6 05 4F		     5				inc di
 0A31  47		     5				mov byte ptr [di], 'O'
 0A32  C6 05 52		     5				inc di
 0A35  47		     5				mov byte ptr [di], 'R'
 0A36  C6 05 47		     5				inc di
 0A39  47		     5				mov byte ptr [di], 'G'
 0A3A  C6 05 20		     5				inc di
 0A3D  47		     5				mov byte ptr [di], ' '
 0A3E  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
 0A41  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??012E catstr <ax>, ??012D, ??012E
 = <ax>			     5				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??012E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack
			     4			endif
 0A42  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A46			   *@C00B3:
			     4			endif
 0A46  8A 04		     4			.repeat
 0A48  88 05		     4				mov al,   [si]
 0A4A  46		     4				mov [di], al
 0A4B  47		     4				inc si
 0A4C  0A C0		   *	    or	al, al
 0A4E  75 F6		   *	    jne    @C00B3
			     4				inc di
 0A50  4E		     4			.until (al == 0)
 0A51  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0130 eq 0
 = 			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)
			     6				regStack substr regStack, (??0130 + 1)
			     6			endif
			     5			exitm ??0131
			     5		%	for ??012F, __popRegs(regStack) 
			     5				pop ??012F
 0A52  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A53  C6 05 20		     5			endm
 0A56  47		     5				mov byte ptr [di], ' '
 0A57  C6 05 53		     5				inc di
 0A5A  47		     5				mov byte ptr [di], 'S'
 0A5B  C6 05 45		     5				inc di
 0A5E  47		     5				mov byte ptr [di], 'E'
 0A5F  C6 05 47		     5				inc di
 0A62  47		     5				mov byte ptr [di], 'G'
 0A63  C6 05 55		     5				inc di
 0A66  47		     5				mov byte ptr [di], 'U'
 0A67  C6 05 4E		     5				inc di
 0A6A  47		     5				mov byte ptr [di], 'N'
 0A6B  C6 05 44		     5				inc di
 0A6E  47		     5				mov byte ptr [di], 'D'
 0A6F  C6 05 4F		     5				inc di
 0A72  47		     5				mov byte ptr [di], 'O'
 0A73  C6 05 20		     5				inc di
 0A76  47		     5				mov byte ptr [di], ' '
 0A77  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
 0A7A  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0134 catstr <ax>, ??0133, ??0134
 = <ax>			     5				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0134
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack
			     4			endif
 0A7B  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A7F			   *@C00B5:
			     4			endif
 0A7F  8A 04		     4			.repeat
 0A81  88 05		     4				mov al,   [si]
 0A83  46		     4				mov [di], al
 0A84  47		     4				inc si
 0A85  0A C0		   *	    or	al, al
 0A87  75 F6		   *	    jne    @C00B5
			     4				inc di
 0A89  4E		     4			.until (al == 0)
 0A8A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0136 eq 0
 = 			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1)
			     6				regStack substr regStack, (??0136 + 1)
			     6			endif
			     5			exitm ??0137
			     5		%	for ??0135, __popRegs(regStack) 
			     5				pop ??0135
 0A8B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
 0A8C  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??013A catstr <ax>, ??0139, ??013A
 = <ax>			     5				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??013A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack
			     4			endif
 0A8D  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A91			   *@C00B7:
			     4			endif
 0A91  8A 04		     4			.repeat
 0A93  88 05		     4				mov al,   [si]
 0A95  46		     4				mov [di], al
 0A96  47		     4				inc si
 0A97  0A C0		   *	    or	al, al
 0A99  75 F6		   *	    jne    @C00B7
			     4				inc di
 0A9B  4E		     4			.until (al == 0)
 0A9C  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??013C eq 0
 = 			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)
			     6				regStack substr regStack, (??013C + 1)
			     6			endif
			     5			exitm ??013D
			     5		%	for ??013B, __popRegs(regStack) 
			     5				pop ??013B
 0A9D  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
 0A9E  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0140 catstr <ax>, ??013F, ??0140
 = <ax>			     5				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0140
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack
			     4			endif
 0A9F  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AA3			   *@C00B9:
			     4			endif
 0AA3  8A 04		     4			.repeat
 0AA5  88 05		     4				mov al,   [si]
 0AA7  46		     4				mov [di], al
 0AA8  47		     4				inc si
 0AA9  0A C0		   *	    or	al, al
 0AAB  75 F6		   *	    jne    @C00B9
			     4				inc di
 0AAD  4E		     4			.until (al == 0)
 0AAE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0142 eq 0
 = 			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)
			     6				regStack substr regStack, (??0142 + 1)
			     6			endif
			     5			exitm ??0143
			     5		%	for ??0141, __popRegs(regStack) 
			     5				pop ??0141
 0AAF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0AB0  C3			
 0AB1				
				;====================================================================
 0AB1				; Reading Functions
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0AB1  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
 0AB5  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0146 catstr <ax>, ??0145, ??0146
 = <ax>			     5				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0146
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack
			     4			endif
 0AB6  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0ABA			   *@C00BB:
			     4			endif
 0ABA  8A 04		     4			.repeat
 0ABC  88 05		     4				mov al,   [si]
 0ABE  46		     4				mov [di], al
 0ABF  47		     4				inc si
 0AC0  0A C0		   *	    or	al, al
 0AC2  75 F6		   *	    jne    @C00BB
			     4				inc di
 0AC4  4E		     4			.until (al == 0)
 0AC5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0148 eq 0
 = 			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)
			     6				regStack substr regStack, (??0148 + 1)
			     6			endif
			     5			exitm ??0149
			     5		%	for ??0147, __popRegs(regStack) 
			     5				pop ??0147
 0AC6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0AC7  C6 05 20		     5			endm
 0ACA  47		     5				mov byte ptr [di], ' '
 0ACB  C6 05 4C		     5				inc di
 0ACE  47		     5				mov byte ptr [di], 'L'
 0ACF  C6 05 49		     5				inc di
 0AD2  47		     5				mov byte ptr [di], 'I'
 0AD3  C6 05 4E		     5				inc di
 0AD6  47		     5				mov byte ptr [di], 'N'
 0AD7  C6 05 48		     5				inc di
 0ADA  47		     5				mov byte ptr [di], 'H'
 0ADB  C6 05 41		     5				inc di
 0ADE  47		     5				mov byte ptr [di], 'A'
 0ADF  C6 05 20		     5				inc di
 0AE2  47		     5				mov byte ptr [di], ' '
 0AE3  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
 0AE6  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??014C catstr <ax>, ??014B, ??014C
 = <ax>			     5				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??014C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack
			     4			endif
 0AE7  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AEB			   *@C00BD:
			     4			endif
 0AEB  8A 04		     4			.repeat
 0AED  88 05		     4				mov al,   [si]
 0AEF  46		     4				mov [di], al
 0AF0  47		     4				inc si
 0AF1  0A C0		   *	    or	al, al
 0AF3  75 F6		   *	    jne    @C00BD
			     4				inc di
 0AF5  4E		     4			.until (al == 0)
 0AF6  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??014E eq 0
 = 			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)
			     6				regStack substr regStack, (??014E + 1)
			     6			endif
			     5			exitm ??014F
			     5		%	for ??014D, __popRegs(regStack) 
			     5				pop ??014D
 0AF7  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
 0AF8  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0152 catstr <ax>, ??0151, ??0152
 = <ax>			     5				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0152
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack
			     4			endif
 0AF9  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AFD			   *@C00BF:
			     4			endif
 0AFD  8A 04		     4			.repeat
 0AFF  88 05		     4				mov al,   [si]
 0B01  46		     4				mov [di], al
 0B02  47		     4				inc si
 0B03  0A C0		   *	    or	al, al
 0B05  75 F6		   *	    jne    @C00BF
			     4				inc di
 0B07  4E		     4			.until (al == 0)
 0B08  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0154 eq 0
 = 			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)
			     6				regStack substr regStack, (??0154 + 1)
			     6			endif
			     5			exitm ??0155
			     5		%	for ??0153, __popRegs(regStack) 
			     5				pop ??0153
 0B09  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
 0B0A  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0158 catstr <ax>, ??0157, ??0158
 = <ax>			     5				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0158
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack
			     4			endif
 0B0B  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B0F			   *@C00C1:
			     4			endif
 0B0F  8A 04		     4			.repeat
 0B11  88 05		     4				mov al,   [si]
 0B13  46		     4				mov [di], al
 0B14  47		     4				inc si
 0B15  0A C0		   *	    or	al, al
 0B17  75 F6		   *	    jne    @C00C1
			     4				inc di
 0B19  4E		     4			.until (al == 0)
 0B1A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??015A eq 0
 = 			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)
			     6				regStack substr regStack, (??015A + 1)
			     6			endif
			     5			exitm ??015B
			     5		%	for ??0159, __popRegs(regStack) 
			     5				pop ??0159
 0B1B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0B1C  C3				HandleCR macro
 0B1D						invoke PeekChar		mov    bh, PeekBuffer		.if    bh != LF			jmp ErrorUnexpectedChar		.endif	endm
					
 0B1D					ReadEmptyLines proc near uses RegsInvokeUses
						invoke ReadChar
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_DST !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0B1D  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
 0B21  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??015E catstr <ax>, ??015D, ??015E
 = <ax>			     5				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??015E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack
			     4			endif
 0B22  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B26			   *@C00C3:
			     4			endif
 0B26  8A 04		     4			.repeat
 0B28  88 05		     4				mov al,   [si]
 0B2A  46		     4				mov [di], al
 0B2B  47		     4				inc si
 0B2C  0A C0		   *	    or	al, al
 0B2E  75 F6		   *	    jne    @C00C3
			     4				inc di
 0B30  4E		     4			.until (al == 0)
 0B31  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0160 eq 0
 = 			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)
			     6				regStack substr regStack, (??0160 + 1)
			     6			endif
			     5			exitm ??0161
			     5		%	for ??015F, __popRegs(regStack) 
			     5				pop ??015F
 0B32  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0B33  C6 05 20		     5			endm
 0B36  47		     5				mov byte ptr [di], ' '
 0B37  C6 05 4C		     5				inc di
 0B3A  47		     5				mov byte ptr [di], 'L'
 0B3B  C6 05 49		     5				inc di
 0B3E  47		     5				mov byte ptr [di], 'I'
 0B3F  C6 05 4E		     5				inc di
 0B42  47		     5				mov byte ptr [di], 'N'
 0B43  C6 05 48		     5				inc di
 0B46  47		     5				mov byte ptr [di], 'H'
 0B47  C6 05 41		     5				inc di
 0B4A  47		     5				mov byte ptr [di], 'A'
 0B4B  C6 05 5F		     5				inc di
 0B4E  47		     5				mov byte ptr [di], '_'
 0B4F  C6 05 44		     5				inc di
 0B52  47		     5				mov byte ptr [di], 'D'
 0B53  C6 05 53		     5				inc di
 0B56  47		     5				mov byte ptr [di], 'S'
 0B57  C6 05 54		     5				inc di
 0B5A  47		     5				mov byte ptr [di], 'T'
 0B5B  C6 05 20		     5				inc di
 0B5E  47		     5				mov byte ptr [di], ' '
 0B5F  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
 0B62  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0164 catstr <ax>, ??0163, ??0164
 = <ax>			     5				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0164
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack
			     4			endif
 0B63  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B67			   *@C00C5:
			     4			endif
 0B67  8A 04		     4			.repeat
 0B69  88 05		     4				mov al,   [si]
 0B6B  46		     4				mov [di], al
 0B6C  47		     4				inc si
 0B6D  0A C0		   *	    or	al, al
 0B6F  75 F6		   *	    jne    @C00C5
			     4				inc di
 0B71  4E		     4			.until (al == 0)
 0B72  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0166 eq 0
 = 			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)
			     6				regStack substr regStack, (??0166 + 1)
			     6			endif
			     5			exitm ??0167
			     5		%	for ??0165, __popRegs(regStack) 
			     5				pop ??0165
 0B73  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
 0B74  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??016A catstr <ax>, ??0169, ??016A
 = <ax>			     5				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??016A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack
			     4			endif
 0B75  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B79			   *@C00C7:
			     4			endif
 0B79  8A 04		     4			.repeat
 0B7B  88 05		     4				mov al,   [si]
 0B7D  46		     4				mov [di], al
 0B7E  47		     4				inc si
 0B7F  0A C0		   *	    or	al, al
 0B81  75 F6		   *	    jne    @C00C7
			     4				inc di
 0B83  4E		     4			.until (al == 0)
 0B84  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??016C eq 0
 = 			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)
			     6				regStack substr regStack, (??016C + 1)
			     6			endif
			     5			exitm ??016D
			     5		%	for ??016B, __popRegs(regStack) 
			     5				pop ??016B
 0B85  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
 0B86  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0170 catstr <ax>, ??016F, ??0170
 = <ax>			     5				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0170
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack
			     4			endif
 0B87  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B8B			   *@C00C9:
			     4			endif
 0B8B  8A 04		     4			.repeat
 0B8D  88 05		     4				mov al,   [si]
 0B8F  46		     4				mov [di], al
 0B90  47		     4				inc si
 0B91  0A C0		   *	    or	al, al
 0B93  75 F6		   *	    jne    @C00C9
			     4				inc di
 0B95  4E		     4			.until (al == 0)
 0B96  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0172 eq 0
 = 			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)
			     6				regStack substr regStack, (??0172 + 1)
			     6			endif
			     5			exitm ??0173
			     5		%	for ??0171, __popRegs(regStack) 
			     5				pop ??0171
 0B97  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0B98  C3					.while ax != 0
 0B99							mov bl, FileBuffer
				
 0B99							.if bl == LF
								inc FileLine
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_ORG !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0B99  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
 0B9D  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0176 catstr <ax>, ??0175, ??0176
 = <ax>			     5				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0176
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack
			     4			endif
 0B9E  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BA2			   *@C00CB:
			     4			endif
 0BA2  8A 04		     4			.repeat
 0BA4  88 05		     4				mov al,   [si]
 0BA6  46		     4				mov [di], al
 0BA7  47		     4				inc si
 0BA8  0A C0		   *	    or	al, al
 0BAA  75 F6		   *	    jne    @C00CB
			     4				inc di
 0BAC  4E		     4			.until (al == 0)
 0BAD  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0178 eq 0
 = 			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)
			     6				regStack substr regStack, (??0178 + 1)
			     6			endif
			     5			exitm ??0179
			     5		%	for ??0177, __popRegs(regStack) 
			     5				pop ??0177
 0BAE  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0BAF  C6 05 20		     5			endm
 0BB2  47		     5				mov byte ptr [di], ' '
 0BB3  C6 05 4C		     5				inc di
 0BB6  47		     5				mov byte ptr [di], 'L'
 0BB7  C6 05 49		     5				inc di
 0BBA  47		     5				mov byte ptr [di], 'I'
 0BBB  C6 05 4E		     5				inc di
 0BBE  47		     5				mov byte ptr [di], 'N'
 0BBF  C6 05 48		     5				inc di
 0BC2  47		     5				mov byte ptr [di], 'H'
 0BC3  C6 05 41		     5				inc di
 0BC6  47		     5				mov byte ptr [di], 'A'
 0BC7  C6 05 5F		     5				inc di
 0BCA  47		     5				mov byte ptr [di], '_'
 0BCB  C6 05 4F		     5				inc di
 0BCE  47		     5				mov byte ptr [di], 'O'
 0BCF  C6 05 52		     5				inc di
 0BD2  47		     5				mov byte ptr [di], 'R'
 0BD3  C6 05 47		     5				inc di
 0BD6  47		     5				mov byte ptr [di], 'G'
 0BD7  C6 05 20		     5				inc di
 0BDA  47		     5				mov byte ptr [di], ' '
 0BDB  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
 0BDE  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??017C catstr <ax>, ??017B, ??017C
 = <ax>			     5				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??017C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack
			     4			endif
 0BDF  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BE3			   *@C00CD:
			     4			endif
 0BE3  8A 04		     4			.repeat
 0BE5  88 05		     4				mov al,   [si]
 0BE7  46		     4				mov [di], al
 0BE8  47		     4				inc si
 0BE9  0A C0		   *	    or	al, al
 0BEB  75 F6		   *	    jne    @C00CD
			     4				inc di
 0BED  4E		     4			.until (al == 0)
 0BEE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??017E eq 0
 = 			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)
			     6				regStack substr regStack, (??017E + 1)
			     6			endif
			     5			exitm ??017F
			     5		%	for ??017D, __popRegs(regStack) 
			     5				pop ??017D
 0BEF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
 0BF0  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0182 catstr <ax>, ??0181, ??0182
 = <ax>			     5				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0182
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack
			     4			endif
 0BF1  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BF5			   *@C00CF:
			     4			endif
 0BF5  8A 04		     4			.repeat
 0BF7  88 05		     4				mov al,   [si]
 0BF9  46		     4				mov [di], al
 0BFA  47		     4				inc si
 0BFB  0A C0		   *	    or	al, al
 0BFD  75 F6		   *	    jne    @C00CF
			     4				inc di
 0BFF  4E		     4			.until (al == 0)
 0C00  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0184 eq 0
 = 			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)
			     6				regStack substr regStack, (??0184 + 1)
			     6			endif
			     5			exitm ??0185
			     5		%	for ??0183, __popRegs(regStack) 
			     5				pop ??0183
 0C01  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
 0C02  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0188 catstr <ax>, ??0187, ??0188
 = <ax>			     5				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0188
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStack
			     4			endif
 0C03  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0C07			   *@C00D1:
			     4			endif
 0C07  8A 04		     4			.repeat
 0C09  88 05		     4				mov al,   [si]
 0C0B  46		     4				mov [di], al
 0C0C  47		     4				inc si
 0C0D  0A C0		   *	    or	al, al
 0C0F  75 F6		   *	    jne    @C00D1
			     4				inc di
 0C11  4E		     4			.until (al == 0)
 0C12  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??018A eq 0
 = 			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)
			     6				regStack substr regStack, (??018A + 1)
			     6			endif
			     5			exitm ??018B
			     5		%	for ??0189, __popRegs(regStack) 
			     5				pop ??0189
 0C13  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0C14  C3							mov FileCol, 1
 0C15							.elseif bl == CR
								HandleCR
							.else
								jmp ErrorUnexpectedChar
							.endif
				
 0C15							invoke ReadChar
						.endw
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??018D     textequ <>
 = 			     2			??018E textequ <>
			     2			for       ??018C, <ax,dx>
			     2				push  ??018C
			     2				??018E catstr <??018C>, ??018D, ??018E
			     2				??018D catstr <, >
			     2			endm
 0C15  50		     3				push  ax
 = ax			     3				??018E catstr <ax>, ??018D, ??018E
 = , 			     3				??018D catstr <, >
 0C16  52		     3				push  dx
 = dx, ax		     3				??018E catstr <dx>, ??018D, ??018E
 = , 			     3				??018D catstr <, >
 = <dx, ax>		     2			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
			     2			__pushRegs ??018E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??018E
			     3			else
			     3				regStack catstr ??018E, REG_SET_DELIMITER, regStack
			     3			endif
 0C17  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C19  B2 45		     2				mov dl, 'E'
 0C1B  CD 21		     2				int 21h
 0C1D  B2 72		     2				mov dl, 'r'
 0C1F  CD 21		     2				int 21h
 0C21  B2 72		     2				mov dl, 'r'
 0C23  CD 21		     2				int 21h
 0C25  B2 6F		     2				mov dl, 'o'
 0C27  CD 21		     2				int 21h
 0C29  B2 20		     2				mov dl, ' '
 0C2B  CD 21		     2				int 21h
 0C2D  B2 6E		     2				mov dl, 'n'
 0C2F  CD 21		     2				int 21h
 0C31  B2 61		     2				mov dl, 'a'
 0C33  CD 21		     2				int 21h
 0C35  B2 20		     2				mov dl, ' '
 0C37  CD 21		     2				int 21h
 0C39  B2 61		     2				mov dl, 'a'
 0C3B  CD 21		     2				int 21h
 0C3D  B2 62		     2				mov dl, 'b'
 0C3F  CD 21		     2				int 21h
 0C41  B2 65		     2				mov dl, 'e'
 0C43  CD 21		     2				int 21h
 0C45  B2 72		     2				mov dl, 'r'
 0C47  CD 21		     2				int 21h
 0C49  B2 74		     2				mov dl, 't'
 0C4B  CD 21		     2				int 21h
 0C4D  B2 75		     2				mov dl, 'u'
 0C4F  CD 21		     2				int 21h
 0C51  B2 72		     2				mov dl, 'r'
 0C53  CD 21		     2				int 21h
 0C55  B2 61		     2				mov dl, 'a'
 0C57  CD 21		     2				int 21h
 0C59  B2 20		     2				mov dl, ' '
 0C5B  CD 21		     2				int 21h
 0C5D  B2 64		     2				mov dl, 'd'
 0C5F  CD 21		     2				int 21h
 0C61  B2 6F		     2				mov dl, 'o'
 0C63  CD 21		     2				int 21h
 0C65  B2 20		     2				mov dl, ' '
 0C67  CD 21		     2				int 21h
 0C69  B2 61		     2				mov dl, 'a'
 0C6B  CD 21		     2				int 21h
 0C6D  B2 72		     2				mov dl, 'r'
 0C6F  CD 21		     2				int 21h
 0C71  B2 71		     2				mov dl, 'q'
 0C73  CD 21		     2				int 21h
 0C75  B2 75		     2				mov dl, 'u'
 0C77  CD 21		     2				int 21h
 0C79  B2 69		     2				mov dl, 'i'
 0C7B  CD 21		     2				int 21h
 0C7D  B2 76		     2				mov dl, 'v'
 0C7F  CD 21		     2				int 21h
 0C81  B2 6F		     2				mov dl, 'o'
 0C83  CD 21		     2				int 21h
 0C85  B2 2E		     2				mov dl, '.'
 0C87  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0190 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0190 eq 0
 = <dx, ax>		     3				??0191     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0191 substr regStack, 1, (??0190 - 1)
			     3				regStack substr regStack, (??0190 + 1)
			     3			endif
			     3			exitm ??0191
			     2		%	for ??018F, __popRegs(regStack) 
			     2				pop ??018F
			     2			endm
 0C89  5A		     3				pop dx
 0C8A  58		     3				pop ax
 0C8B  E9 F6C3					ret
					ReadEmptyLines endp
 0C8E				
					OpenFile proc near
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??0193     textequ <>
 = 			     2			??0194 textequ <>
			     2			for       ??0192, <ax,dx>
			     2				push  ??0192
			     2				??0194 catstr <??0192>, ??0193, ??0194
			     2				??0193 catstr <, >
			     2			endm
 0C8E  50		     3				push  ax
 = ax			     3				??0194 catstr <ax>, ??0193, ??0194
 = , 			     3				??0193 catstr <, >
 0C8F  52		     3				push  dx
 = dx, ax		     3				??0194 catstr <dx>, ??0193, ??0194
 = , 			     3				??0193 catstr <, >
 = <dx, ax>		     2			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
			     2			__pushRegs ??0194
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0194
			     3			else
			     3				regStack catstr ??0194, REG_SET_DELIMITER, regStack
			     3			endif
 0C90  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C92  B2 45		     2				mov dl, 'E'
 0C94  CD 21		     2				int 21h
 0C96  B2 72		     2				mov dl, 'r'
 0C98  CD 21		     2				int 21h
 0C9A  B2 72		     2				mov dl, 'r'
 0C9C  CD 21		     2				int 21h
 0C9E  B2 6F		     2				mov dl, 'o'
 0CA0  CD 21		     2				int 21h
 0CA2  B2 20		     2				mov dl, ' '
 0CA4  CD 21		     2				int 21h
 0CA6  B2 6E		     2				mov dl, 'n'
 0CA8  CD 21		     2				int 21h
 0CAA  B2 61		     2				mov dl, 'a'
 0CAC  CD 21		     2				int 21h
 0CAE  B2 20		     2				mov dl, ' '
 0CB0  CD 21		     2				int 21h
 0CB2  B2 6C		     2				mov dl, 'l'
 0CB4  CD 21		     2				int 21h
 0CB6  B2 65		     2				mov dl, 'e'
 0CB8  CD 21		     2				int 21h
 0CBA  B2 69		     2				mov dl, 'i'
 0CBC  CD 21		     2				int 21h
 0CBE  B2 74		     2				mov dl, 't'
 0CC0  CD 21		     2				int 21h
 0CC2  B2 75		     2				mov dl, 'u'
 0CC4  CD 21		     2				int 21h
 0CC6  B2 72		     2				mov dl, 'r'
 0CC8  CD 21		     2				int 21h
 0CCA  B2 61		     2				mov dl, 'a'
 0CCC  CD 21		     2				int 21h
 0CCE  B2 20		     2				mov dl, ' '
 0CD0  CD 21		     2				int 21h
 0CD2  B2 64		     2				mov dl, 'd'
 0CD4  CD 21		     2				int 21h
 0CD6  B2 6F		     2				mov dl, 'o'
 0CD8  CD 21		     2				int 21h
 0CDA  B2 20		     2				mov dl, ' '
 0CDC  CD 21		     2				int 21h
 0CDE  B2 61		     2				mov dl, 'a'
 0CE0  CD 21		     2				int 21h
 0CE2  B2 72		     2				mov dl, 'r'
 0CE4  CD 21		     2				int 21h
 0CE6  B2 71		     2				mov dl, 'q'
 0CE8  CD 21		     2				int 21h
 0CEA  B2 75		     2				mov dl, 'u'
 0CEC  CD 21		     2				int 21h
 0CEE  B2 69		     2				mov dl, 'i'
 0CF0  CD 21		     2				int 21h
 0CF2  B2 76		     2				mov dl, 'v'
 0CF4  CD 21		     2				int 21h
 0CF6  B2 6F		     2				mov dl, 'o'
 0CF8  CD 21		     2				int 21h
 0CFA  B2 2E		     2				mov dl, '.'
 0CFC  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0196 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0196 eq 0
 = <dx, ax>		     3				??0197     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0197 substr regStack, 1, (??0196 - 1)
			     3				regStack substr regStack, (??0196 + 1)
			     3			endif
			     3			exitm ??0197
			     2		%	for ??0195, __popRegs(regStack) 
			     2				pop ??0195
			     2			endm
 0CFE  5A		     3				pop dx
 0CFF  58		     3				pop ax
 0D00  E9 F64E					SaveRegs ax,         dx
						mov      al,         0
 0D03						lea      dx,         FileName
						mov      ah,         3dh
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??0199     textequ <>
 = 			     4			??019A textequ <>
			     4			for       ??0198, <ax,dx>
			     4				push  ??0198
			     4				??019A catstr <??0198>, ??0199, ??019A
			     4				??0199 catstr <, >
			     4			endm
 0D03  50		     5				push  ax
 = ax			     5				??019A catstr <ax>, ??0199, ??019A
 = , 			     5				??0199 catstr <, >
 0D04  52		     5				push  dx
 = dx, ax		     5				??019A catstr <dx>, ??0199, ??019A
 = , 			     5				??0199 catstr <, >
 = <dx, ax>		     4			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     4			__pushRegs ??019A
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??019A
			     5			else
			     5				regStack catstr ??019A, REG_SET_DELIMITER, regStack
			     5			endif
 0D05  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D07  B2 28		     4				mov dl, '('
 0D09  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??019C instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??019C eq 0
 = <dx, ax>		     5				??019D     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??019D substr regStack, 1, (??019C - 1)
			     5				regStack substr regStack, (??019C + 1)
			     5			endif
			     5			exitm ??019D
			     4		%	for ??019B, __popRegs(regStack) 
			     4				pop ??019B
			     4			endm
 0D0B  5A		     5				pop dx
 0D0C  58		     5				pop ax
 0D0D  FF 36 03C1 R	   *	    push   FileLine
 0D11  E8 079F		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??019F     textequ <>
 = 			     4			??01A0 textequ <>
			     4			for       ??019E, <ax,dx>
			     4				push  ??019E
			     4				??01A0 catstr <??019E>, ??019F, ??01A0
			     4				??019F catstr <, >
			     4			endm
 0D14  50		     5				push  ax
 = ax			     5				??01A0 catstr <ax>, ??019F, ??01A0
 = , 			     5				??019F catstr <, >
 0D15  52		     5				push  dx
 = dx, ax		     5				??01A0 catstr <dx>, ??019F, ??01A0
 = , 			     5				??019F catstr <, >
 = <dx, ax>		     4			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     4			__pushRegs ??01A0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01A0
			     5			else
			     5				regStack catstr ??01A0, REG_SET_DELIMITER, regStack
			     5			endif
 0D16  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D18  B2 3A		     4				mov dl, ':'
 0D1A  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A2 eq 0
 = <dx, ax>		     5				??01A3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01A3 substr regStack, 1, (??01A2 - 1)
			     5				regStack substr regStack, (??01A2 + 1)
			     5			endif
			     5			exitm ??01A3
			     4		%	for ??01A1, __popRegs(regStack) 
			     4				pop ??01A1
			     4			endm
 0D1C  5A		     5				pop dx
 0D1D  58		     5				pop ax
 0D1E  FF 36 03BF R	   *	    push   FileCol
 0D22  E8 078E		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01A5     textequ <>
 = 			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
 0D25  50		     5				push  ax
 = ax			     5				??01A6 catstr <ax>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 0D26  52		     5				push  dx
 = dx, ax		     5				??01A6 catstr <dx>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 = <dx, ax>		     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack
			     5			endif
 0D27  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D29  B2 29		     4				mov dl, ')'
 0D2B  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
 = <dx, ax>		     5				??01A9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)
			     5				regStack substr regStack, (??01A8 + 1)
			     5			endif
			     5			exitm ??01A9
			     4		%	for ??01A7, __popRegs(regStack) 
			     4				pop ??01A7
			     4			endm
 0D2D  5A		     5				pop dx
 0D2E  58		     5				pop ax
						int      21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01AB     textequ <>
 = 			     2			??01AC textequ <>
			     2			for       ??01AA, <ax,dx>
			     2				push  ??01AA
			     2				??01AC catstr <??01AA>, ??01AB, ??01AC
			     2				??01AB catstr <, >
			     2			endm
 0D2F  50		     3				push  ax
 = ax			     3				??01AC catstr <ax>, ??01AB, ??01AC
 = , 			     3				??01AB catstr <, >
 0D30  52		     3				push  dx
 = dx, ax		     3				??01AC catstr <dx>, ??01AB, ??01AC
 = , 			     3				??01AB catstr <, >
 = <dx, ax>		     2			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     2			__pushRegs ??01AC
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01AC
			     3			else
			     3				regStack catstr ??01AC, REG_SET_DELIMITER, regStack
			     3			endif
 0D31  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0D33  B2 20		     2				mov dl, ' '
 0D35  CD 21		     2				int 21h
 0D37  B2 45		     2				mov dl, 'E'
 0D39  CD 21		     2				int 21h
 0D3B  B2 72		     2				mov dl, 'r'
 0D3D  CD 21		     2				int 21h
 0D3F  B2 72		     2				mov dl, 'r'
 0D41  CD 21		     2				int 21h
 0D43  B2 6F		     2				mov dl, 'o'
 0D45  CD 21		     2				int 21h
 0D47  B2 3A		     2				mov dl, ':'
 0D49  CD 21		     2				int 21h
 0D4B  B2 20		     2				mov dl, ' '
 0D4D  CD 21		     2				int 21h
 0D4F  B2 61		     2				mov dl, 'a'
 0D51  CD 21		     2				int 21h
 0D53  B2 20		     2				mov dl, ' '
 0D55  CD 21		     2				int 21h
 0D57  B2 71		     2				mov dl, 'q'
 0D59  CD 21		     2				int 21h
 0D5B  B2 75		     2				mov dl, 'u'
 0D5D  CD 21		     2				int 21h
 0D5F  B2 61		     2				mov dl, 'a'
 0D61  CD 21		     2				int 21h
 0D63  B2 6E		     2				mov dl, 'n'
 0D65  CD 21		     2				int 21h
 0D67  B2 74		     2				mov dl, 't'
 0D69  CD 21		     2				int 21h
 0D6B  B2 69		     2				mov dl, 'i'
 0D6D  CD 21		     2				int 21h
 0D6F  B2 64		     2				mov dl, 'd'
 0D71  CD 21		     2				int 21h
 0D73  B2 61		     2				mov dl, 'a'
 0D75  CD 21		     2				int 21h
 0D77  B2 64		     2				mov dl, 'd'
 0D79  CD 21		     2				int 21h
 0D7B  B2 65		     2				mov dl, 'e'
 0D7D  CD 21		     2				int 21h
 0D7F  B2 20		     2				mov dl, ' '
 0D81  CD 21		     2				int 21h
 0D83  B2 64		     2				mov dl, 'd'
 0D85  CD 21		     2				int 21h
 0D87  B2 65		     2				mov dl, 'e'
 0D89  CD 21		     2				int 21h
 0D8B  B2 20		     2				mov dl, ' '
 0D8D  CD 21		     2				int 21h
 0D8F  B2 63		     2				mov dl, 'c'
 0D91  CD 21		     2				int 21h
 0D93  B2 6F		     2				mov dl, 'o'
 0D95  CD 21		     2				int 21h
 0D97  B2 6C		     2				mov dl, 'l'
 0D99  CD 21		     2				int 21h
 0D9B  B2 75		     2				mov dl, 'u'
 0D9D  CD 21		     2				int 21h
 0D9F  B2 6E		     2				mov dl, 'n'
 0DA1  CD 21		     2				int 21h
 0DA3  B2 61		     2				mov dl, 'a'
 0DA5  CD 21		     2				int 21h
 0DA7  B2 73		     2				mov dl, 's'
 0DA9  CD 21		     2				int 21h
 0DAB  B2 20		     2				mov dl, ' '
 0DAD  CD 21		     2				int 21h
 0DAF  B2 64		     2				mov dl, 'd'
 0DB1  CD 21		     2				int 21h
 0DB3  B2 65		     2				mov dl, 'e'
 0DB5  CD 21		     2				int 21h
 0DB7  B2 76		     2				mov dl, 'v'
 0DB9  CD 21		     2				int 21h
 0DBB  B2 65		     2				mov dl, 'e'
 0DBD  CD 21		     2				int 21h
 0DBF  B2 20		     2				mov dl, ' '
 0DC1  CD 21		     2				int 21h
 0DC3  B2 73		     2				mov dl, 's'
 0DC5  CD 21		     2				int 21h
 0DC7  B2 65		     2				mov dl, 'e'
 0DC9  CD 21		     2				int 21h
 0DCB  B2 72		     2				mov dl, 'r'
 0DCD  CD 21		     2				int 21h
 0DCF  B2 20		     2				mov dl, ' '
 0DD1  CD 21		     2				int 21h
 0DD3  B2 69		     2				mov dl, 'i'
 0DD5  CD 21		     2				int 21h
 0DD7  B2 67		     2				mov dl, 'g'
 0DD9  CD 21		     2				int 21h
 0DDB  B2 75		     2				mov dl, 'u'
 0DDD  CD 21		     2				int 21h
 0DDF  B2 61		     2				mov dl, 'a'
 0DE1  CD 21		     2				int 21h
 0DE3  B2 6C		     2				mov dl, 'l'
 0DE5  CD 21		     2				int 21h
 0DE7  B2 20		     2				mov dl, ' '
 0DE9  CD 21		     2				int 21h
 0DEB  B2 65		     2				mov dl, 'e'
 0DED  CD 21		     2				int 21h
 0DEF  B2 6D		     2				mov dl, 'm'
 0DF1  CD 21		     2				int 21h
 0DF3  B2 20		     2				mov dl, ' '
 0DF5  CD 21		     2				int 21h
 0DF7  B2 74		     2				mov dl, 't'
 0DF9  CD 21		     2				int 21h
 0DFB  B2 6F		     2				mov dl, 'o'
 0DFD  CD 21		     2				int 21h
 0DFF  B2 64		     2				mov dl, 'd'
 0E01  CD 21		     2				int 21h
 0E03  B2 61		     2				mov dl, 'a'
 0E05  CD 21		     2				int 21h
 0E07  B2 73		     2				mov dl, 's'
 0E09  CD 21		     2				int 21h
 0E0B  B2 20		     2				mov dl, ' '
 0E0D  CD 21		     2				int 21h
 0E0F  B2 61		     2				mov dl, 'a'
 0E11  CD 21		     2				int 21h
 0E13  B2 73		     2				mov dl, 's'
 0E15  CD 21		     2				int 21h
 0E17  B2 20		     2				mov dl, ' '
 0E19  CD 21		     2				int 21h
 0E1B  B2 6C		     2				mov dl, 'l'
 0E1D  CD 21		     2				int 21h
 0E1F  B2 69		     2				mov dl, 'i'
 0E21  CD 21		     2				int 21h
 0E23  B2 6E		     2				mov dl, 'n'
 0E25  CD 21		     2				int 21h
 0E27  B2 68		     2				mov dl, 'h'
 0E29  CD 21		     2				int 21h
 0E2B  B2 61		     2				mov dl, 'a'
 0E2D  CD 21		     2				int 21h
 0E2F  B2 73		     2				mov dl, 's'
 0E31  CD 21		     2				int 21h
 0E33  B2 2E		     2				mov dl, '.'
 0E35  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01AE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01AE eq 0
 = <dx, ax>		     3				??01AF     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01AF substr regStack, 1, (??01AE - 1)
			     3				regStack substr regStack, (??01AE + 1)
			     3			endif
			     3			exitm ??01AF
			     2		%	for ??01AD, __popRegs(regStack) 
			     2				pop ??01AD
			     2			endm
 0E37  5A		     3				pop dx
 0E38  58		     3				pop ax
 0E39  E9 F515					.if (carry?)
							call ErrorOpen
 0E3C						.endif
						mov      FileHandle, ax
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01B1     textequ <>
 = 			     2			??01B2 textequ <>
			     2			for       ??01B0, <ax,dx>
			     2				push  ??01B0
			     2				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     2				??01B1 catstr <, >
			     2			endm
 0E3C  50		     3				push  ax
 = ax			     3				??01B2 catstr <ax>, ??01B1, ??01B2
 = , 			     3				??01B1 catstr <, >
 0E3D  52		     3				push  dx
 = dx, ax		     3				??01B2 catstr <dx>, ??01B1, ??01B2
 = , 			     3				??01B1 catstr <, >
 = <dx, ax>		     2			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     2			__pushRegs ??01B2
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01B2
			     3			else
			     3				regStack catstr ??01B2, REG_SET_DELIMITER, regStack
			     3			endif
 0E3E  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0E40  B2 45		     2				mov dl, 'E'
 0E42  CD 21		     2				int 21h
 0E44  B2 72		     2				mov dl, 'r'
 0E46  CD 21		     2				int 21h
 0E48  B2 72		     2				mov dl, 'r'
 0E4A  CD 21		     2				int 21h
 0E4C  B2 6F		     2				mov dl, 'o'
 0E4E  CD 21		     2				int 21h
 0E50  B2 3A		     2				mov dl, ':'
 0E52  CD 21		     2				int 21h
 0E54  B2 20		     2				mov dl, ' '
 0E56  CD 21		     2				int 21h
 0E58  B2 61		     2				mov dl, 'a'
 0E5A  CD 21		     2				int 21h
 0E5C  B2 20		     2				mov dl, ' '
 0E5E  CD 21		     2				int 21h
 0E60  B2 71		     2				mov dl, 'q'
 0E62  CD 21		     2				int 21h
 0E64  B2 75		     2				mov dl, 'u'
 0E66  CD 21		     2				int 21h
 0E68  B2 61		     2				mov dl, 'a'
 0E6A  CD 21		     2				int 21h
 0E6C  B2 6E		     2				mov dl, 'n'
 0E6E  CD 21		     2				int 21h
 0E70  B2 74		     2				mov dl, 't'
 0E72  CD 21		     2				int 21h
 0E74  B2 69		     2				mov dl, 'i'
 0E76  CD 21		     2				int 21h
 0E78  B2 64		     2				mov dl, 'd'
 0E7A  CD 21		     2				int 21h
 0E7C  B2 61		     2				mov dl, 'a'
 0E7E  CD 21		     2				int 21h
 0E80  B2 64		     2				mov dl, 'd'
 0E82  CD 21		     2				int 21h
 0E84  B2 65		     2				mov dl, 'e'
 0E86  CD 21		     2				int 21h
 0E88  B2 20		     2				mov dl, ' '
 0E8A  CD 21		     2				int 21h
 0E8C  B2 64		     2				mov dl, 'd'
 0E8E  CD 21		     2				int 21h
 0E90  B2 65		     2				mov dl, 'e'
 0E92  CD 21		     2				int 21h
 0E94  B2 20		     2				mov dl, ' '
 0E96  CD 21		     2				int 21h
 0E98  B2 6C		     2				mov dl, 'l'
 0E9A  CD 21		     2				int 21h
 0E9C  B2 69		     2				mov dl, 'i'
 0E9E  CD 21		     2				int 21h
 0EA0  B2 6E		     2				mov dl, 'n'
 0EA2  CD 21		     2				int 21h
 0EA4  B2 68		     2				mov dl, 'h'
 0EA6  CD 21		     2				int 21h
 0EA8  B2 61		     2				mov dl, 'a'
 0EAA  CD 21		     2				int 21h
 0EAC  B2 73		     2				mov dl, 's'
 0EAE  CD 21		     2				int 21h
 0EB0  B2 20		     2				mov dl, ' '
 0EB2  CD 21		     2				int 21h
 0EB4  B2 64		     2				mov dl, 'd'
 0EB6  CD 21		     2				int 21h
 0EB8  B2 65		     2				mov dl, 'e'
 0EBA  CD 21		     2				int 21h
 0EBC  B2 76		     2				mov dl, 'v'
 0EBE  CD 21		     2				int 21h
 0EC0  B2 65		     2				mov dl, 'e'
 0EC2  CD 21		     2				int 21h
 0EC4  B2 20		     2				mov dl, ' '
 0EC6  CD 21		     2				int 21h
 0EC8  B2 73		     2				mov dl, 's'
 0ECA  CD 21		     2				int 21h
 0ECC  B2 65		     2				mov dl, 'e'
 0ECE  CD 21		     2				int 21h
 0ED0  B2 72		     2				mov dl, 'r'
 0ED2  CD 21		     2				int 21h
 0ED4  B2 20		     2				mov dl, ' '
 0ED6  CD 21		     2				int 21h
 0ED8  B2 31		     2				mov dl, '1'
 0EDA  CD 21		     2				int 21h
 0EDC  B2 20		     2				mov dl, ' '
 0EDE  CD 21		     2				int 21h
 0EE0  B2 61		     2				mov dl, 'a'
 0EE2  CD 21		     2				int 21h
 0EE4  B2 20		     2				mov dl, ' '
 0EE6  CD 21		     2				int 21h
 0EE8  B2 6D		     2				mov dl, 'm'
 0EEA  CD 21		     2				int 21h
 0EEC  B2 65		     2				mov dl, 'e'
 0EEE  CD 21		     2				int 21h
 0EF0  B2 6E		     2				mov dl, 'n'
 0EF2  CD 21		     2				int 21h
 0EF4  B2 6F		     2				mov dl, 'o'
 0EF6  CD 21		     2				int 21h
 0EF8  B2 73		     2				mov dl, 's'
 0EFA  CD 21		     2				int 21h
 0EFC  B2 20		     2				mov dl, ' '
 0EFE  CD 21		     2				int 21h
 0F00  B2 71		     2				mov dl, 'q'
 0F02  CD 21		     2				int 21h
 0F04  B2 75		     2				mov dl, 'u'
 0F06  CD 21		     2				int 21h
 0F08  B2 65		     2				mov dl, 'e'
 0F0A  CD 21		     2				int 21h
 0F0C  B2 20		     2				mov dl, ' '
 0F0E  CD 21		     2				int 21h
 0F10  B2 61		     2				mov dl, 'a'
 0F12  CD 21		     2				int 21h
 0F14  B2 20		     2				mov dl, ' '
 0F16  CD 21		     2				int 21h
 0F18  B2 71		     2				mov dl, 'q'
 0F1A  CD 21		     2				int 21h
 0F1C  B2 75		     2				mov dl, 'u'
 0F1E  CD 21		     2				int 21h
 0F20  B2 61		     2				mov dl, 'a'
 0F22  CD 21		     2				int 21h
 0F24  B2 6E		     2				mov dl, 'n'
 0F26  CD 21		     2				int 21h
 0F28  B2 74		     2				mov dl, 't'
 0F2A  CD 21		     2				int 21h
 0F2C  B2 69		     2				mov dl, 'i'
 0F2E  CD 21		     2				int 21h
 0F30  B2 64		     2				mov dl, 'd'
 0F32  CD 21		     2				int 21h
 0F34  B2 61		     2				mov dl, 'a'
 0F36  CD 21		     2				int 21h
 0F38  B2 64		     2				mov dl, 'd'
 0F3A  CD 21		     2				int 21h
 0F3C  B2 65		     2				mov dl, 'e'
 0F3E  CD 21		     2				int 21h
 0F40  B2 20		     2				mov dl, ' '
 0F42  CD 21		     2				int 21h
 0F44  B2 64		     2				mov dl, 'd'
 0F46  CD 21		     2				int 21h
 0F48  B2 65		     2				mov dl, 'e'
 0F4A  CD 21		     2				int 21h
 0F4C  B2 20		     2				mov dl, ' '
 0F4E  CD 21		     2				int 21h
 0F50  B2 63		     2				mov dl, 'c'
 0F52  CD 21		     2				int 21h
 0F54  B2 6F		     2				mov dl, 'o'
 0F56  CD 21		     2				int 21h
 0F58  B2 6C		     2				mov dl, 'l'
 0F5A  CD 21		     2				int 21h
 0F5C  B2 75		     2				mov dl, 'u'
 0F5E  CD 21		     2				int 21h
 0F60  B2 6E		     2				mov dl, 'n'
 0F62  CD 21		     2				int 21h
 0F64  B2 61		     2				mov dl, 'a'
 0F66  CD 21		     2				int 21h
 0F68  B2 73		     2				mov dl, 's'
 0F6A  CD 21		     2				int 21h
 0F6C  B2 2E		     2				mov dl, '.'
 0F6E  CD 21		     2				int 21h
 0F70  B2 20		     2				mov dl, ' '
 0F72  CD 21		     2				int 21h
 0F74  B2 4F		     2				mov dl, 'O'
 0F76  CD 21		     2				int 21h
 0F78  B2 20		     2				mov dl, ' '
 0F7A  CD 21		     2				int 21h
 0F7C  B2 65		     2				mov dl, 'e'
 0F7E  CD 21		     2				int 21h
 0F80  B2 6E		     2				mov dl, 'n'
 0F82  CD 21		     2				int 21h
 0F84  B2 63		     2				mov dl, 'c'
 0F86  CD 21		     2				int 21h
 0F88  B2 6F		     2				mov dl, 'o'
 0F8A  CD 21		     2				int 21h
 0F8C  B2 6E		     2				mov dl, 'n'
 0F8E  CD 21		     2				int 21h
 0F90  B2 74		     2				mov dl, 't'
 0F92  CD 21		     2				int 21h
 0F94  B2 72		     2				mov dl, 'r'
 0F96  CD 21		     2				int 21h
 0F98  B2 61		     2				mov dl, 'a'
 0F9A  CD 21		     2				int 21h
 0F9C  B2 64		     2				mov dl, 'd'
 0F9E  CD 21		     2				int 21h
 0FA0  B2 6F		     2				mov dl, 'o'
 0FA2  CD 21		     2				int 21h
 0FA4  B2 20		     2				mov dl, ' '
 0FA6  CD 21		     2				int 21h
 0FA8  B2 66		     2				mov dl, 'f'
 0FAA  CD 21		     2				int 21h
 0FAC  B2 6F		     2				mov dl, 'o'
 0FAE  CD 21		     2				int 21h
 0FB0  B2 69		     2				mov dl, 'i'
 0FB2  CD 21		     2				int 21h
 0FB4  B2 3A		     2				mov dl, ':'
 0FB6  CD 21		     2				int 21h
 0FB8  B2 20		     2				mov dl, ' '
 0FBA  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01B4 eq 0
 = <dx, ax>		     3				??01B5     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01B5 substr regStack, 1, (??01B4 - 1)
			     3				regStack substr regStack, (??01B4 + 1)
			     3			endif
			     3			exitm ??01B5
			     2		%	for ??01B3, __popRegs(regStack) 
			     2				pop ??01B3
			     2			endm
 0FBC  5A		     3				pop dx
 0FBD  58		     3				pop ax
						mov      FileIsOpen, 1
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01B7     textequ <>
 = 			     4			??01B8 textequ <>
			     4			for       ??01B6, <ax,dx>
			     4				push  ??01B6
			     4				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     4				??01B7 catstr <, >
			     4			endm
 0FBE  50		     5				push  ax
 = ax			     5				??01B8 catstr <ax>, ??01B7, ??01B8
 = , 			     5				??01B7 catstr <, >
 0FBF  52		     5				push  dx
 = dx, ax		     5				??01B8 catstr <dx>, ??01B7, ??01B8
 = , 			     5				??01B7 catstr <, >
 = <dx, ax>		     4			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     4			__pushRegs ??01B8
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01B8
			     5			else
			     5				regStack catstr ??01B8, REG_SET_DELIMITER, regStack
			     5			endif
 0FC0  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FC2  B2 28		     4				mov dl, '('
 0FC4  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01BA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01BA eq 0
 = <dx, ax>		     5				??01BB     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01BB substr regStack, 1, (??01BA - 1)
			     5				regStack substr regStack, (??01BA + 1)
			     5			endif
			     5			exitm ??01BB
			     4		%	for ??01B9, __popRegs(regStack) 
			     4				pop ??01B9
			     4			endm
 0FC6  5A		     5				pop dx
 0FC7  58		     5				pop ax
 0FC8  A0 03C5 R	   *	    mov    al, TotalRow
 0FCB  32 E4		   *	    xor    ah, ah
 0FCD  50		   *	    push   ax
 0FCE  E8 04E2		   *	    call   printf_u
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01BD     textequ <>
 = 			     4			??01BE textequ <>
			     4			for       ??01BC, <ax,dx>
			     4				push  ??01BC
			     4				??01BE catstr <??01BC>, ??01BD, ??01BE
			     4				??01BD catstr <, >
			     4			endm
 0FD1  50		     5				push  ax
 = ax			     5				??01BE catstr <ax>, ??01BD, ??01BE
 = , 			     5				??01BD catstr <, >
 0FD2  52		     5				push  dx
 = dx, ax		     5				??01BE catstr <dx>, ??01BD, ??01BE
 = , 			     5				??01BD catstr <, >
 = <dx, ax>		     4			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     4			__pushRegs ??01BE
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01BE
			     5			else
			     5				regStack catstr ??01BE, REG_SET_DELIMITER, regStack
			     5			endif
 0FD3  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FD5  B2 3A		     4				mov dl, ':'
 0FD7  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C0 eq 0
 = <dx, ax>		     5				??01C1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01C1 substr regStack, 1, (??01C0 - 1)
			     5				regStack substr regStack, (??01C0 + 1)
			     5			endif
			     5			exitm ??01C1
			     4		%	for ??01BF, __popRegs(regStack) 
			     4				pop ??01BF
			     4			endm
 0FD9  5A		     5				pop dx
 0FDA  58		     5				pop ax
 0FDB  A0 03C6 R	   *	    mov    al, TotalCol
 0FDE  32 E4		   *	    xor    ah, ah
 0FE0  50		   *	    push   ax
 0FE1  E8 04CF		   *	    call   printf_u
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C3     textequ <>
 = 			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
 0FE4  50		     5				push  ax
 = ax			     5				??01C4 catstr <ax>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 0FE5  52		     5				push  dx
 = dx, ax		     5				??01C4 catstr <dx>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 = <dx, ax>		     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack
			     5			endif
 0FE6  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FE8  B2 29		     4				mov dl, ')'
 0FEA  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
 = <dx, ax>		     5				??01C7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)
			     5				regStack substr regStack, (??01C6 + 1)
			     5			endif
			     5			exitm ??01C7
			     4		%	for ??01C5, __popRegs(regStack) 
			     4				pop ??01C5
			     4			endm
 0FEC  5A		     5				pop dx
 0FED  58		     5				pop ax
 0FEE  E9 F360					RestoreRegs
						ret
 0FF1					OpenFile endp
 0FF1  8A 1E 000D R		
 0FF5  88 1E 03BC R			ReadChar proc near uses RegsReturningOnAX
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C9     textequ <>
 = 			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
 0FF9  50		     5				push  ax
 = ax			     5				??01CA catstr <ax>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 0FFA  52		     5				push  dx
 = dx, ax		     5				??01CA catstr <dx>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 = <dx, ax>		     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack
			     5			endif
 0FFB  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FFD  B2 28		     4				mov dl, '('
 0FFF  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
 = <dx, ax>		     5				??01CD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)
			     5				regStack substr regStack, (??01CC + 1)
			     5			endif
			     5			exitm ??01CD
			     4		%	for ??01CB, __popRegs(regStack) 
			     4				pop ??01CB
			     4			endm
 1001  5A		     5				pop dx
 1002  58		     5				pop ax
 1003  FF 36 03C1 R	   *	    push   FileLine
 1007  E8 04A9		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01CF     textequ <>
 = 			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
 100A  50		     5				push  ax
 = ax			     5				??01D0 catstr <ax>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 100B  52		     5				push  dx
 = dx, ax		     5				??01D0 catstr <dx>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 = <dx, ax>		     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStack
			     5			endif
 100C  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 100E  B2 3A		     4				mov dl, ':'
 1010  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
 = <dx, ax>		     5				??01D3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)
			     5				regStack substr regStack, (??01D2 + 1)
			     5			endif
			     5			exitm ??01D3
			     4		%	for ??01D1, __popRegs(regStack) 
			     4				pop ??01D1
			     4			endm
 1012  5A		     5				pop dx
 1013  58		     5				pop ax
 1014  FF 36 03BF R	   *	    push   FileCol
 1018  E8 0498		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01D5     textequ <>
 = 			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
 101B  50		     5				push  ax
 = ax			     5				??01D6 catstr <ax>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 101C  52		     5				push  dx
 = dx, ax		     5				??01D6 catstr <dx>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 = <dx, ax>		     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack
			     5			endif
 101D  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 101F  B2 29		     4				mov dl, ')'
 1021  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
 = <dx, ax>		     5				??01D9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)
			     5				regStack substr regStack, (??01D8 + 1)
			     5			endif
			     5			exitm ??01D9
			     4		%	for ??01D7, __popRegs(regStack) 
			     4				pop ??01D7
			     4			endm
 1023  5A		     5				pop dx
 1024  58		     5				pop ax
						ret
					ReadChar endp
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01DB     textequ <>
 = 			     2			??01DC textequ <>
			     2			for       ??01DA, <ax,dx>
			     2				push  ??01DA
			     2				??01DC catstr <??01DA>, ??01DB, ??01DC
			     2				??01DB catstr <, >
			     2			endm
 1025  50		     3				push  ax
 = ax			     3				??01DC catstr <ax>, ??01DB, ??01DC
 = , 			     3				??01DB catstr <, >
 1026  52		     3				push  dx
 = dx, ax		     3				??01DC catstr <dx>, ??01DB, ??01DC
 = , 			     3				??01DB catstr <, >
 = <dx, ax>		     2			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     2			__pushRegs ??01DC
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01DC
			     3			else
			     3				regStack catstr ??01DC, REG_SET_DELIMITER, regStack
			     3			endif
 1027  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 1029  B2 20		     2				mov dl, ' '
 102B  CD 21		     2				int 21h
 102D  B2 45		     2				mov dl, 'E'
 102F  CD 21		     2				int 21h
 1031  B2 72		     2				mov dl, 'r'
 1033  CD 21		     2				int 21h
 1035  B2 72		     2				mov dl, 'r'
 1037  CD 21		     2				int 21h
 1039  B2 6F		     2				mov dl, 'o'
 103B  CD 21		     2				int 21h
 103D  B2 3A		     2				mov dl, ':'
 103F  CD 21		     2				int 21h
 1041  B2 20		     2				mov dl, ' '
 1043  CD 21		     2				int 21h
 1045  B2 63		     2				mov dl, 'c'
 1047  CD 21		     2				int 21h
 1049  B2 61		     2				mov dl, 'a'
 104B  CD 21		     2				int 21h
 104D  B2 72		     2				mov dl, 'r'
 104F  CD 21		     2				int 21h
 1051  B2 61		     2				mov dl, 'a'
 1053  CD 21		     2				int 21h
 1055  B2 63		     2				mov dl, 'c'
 1057  CD 21		     2				int 21h
 1059  B2 74		     2				mov dl, 't'
 105B  CD 21		     2				int 21h
 105D  B2 65		     2				mov dl, 'e'
 105F  CD 21		     2				int 21h
 1061  B2 72		     2				mov dl, 'r'
 1063  CD 21		     2				int 21h
 1065  B2 20		     2				mov dl, ' '
 1067  CD 21		     2				int 21h
 1069  B2 69		     2				mov dl, 'i'
 106B  CD 21		     2				int 21h
 106D  B2 6E		     2				mov dl, 'n'
 106F  CD 21		     2				int 21h
 1071  B2 65		     2				mov dl, 'e'
 1073  CD 21		     2				int 21h
 1075  B2 78		     2				mov dl, 'x'
 1077  CD 21		     2				int 21h
 1079  B2 70		     2				mov dl, 'p'
 107B  CD 21		     2				int 21h
 107D  B2 65		     2				mov dl, 'e'
 107F  CD 21		     2				int 21h
 1081  B2 72		     2				mov dl, 'r'
 1083  CD 21		     2				int 21h
 1085  B2 61		     2				mov dl, 'a'
 1087  CD 21		     2				int 21h
 1089  B2 64		     2				mov dl, 'd'
 108B  CD 21		     2				int 21h
 108D  B2 6F		     2				mov dl, 'o'
 108F  CD 21		     2				int 21h
 1091  B2 3A		     2				mov dl, ':'
 1093  CD 21		     2				int 21h
 1095  B2 20		     2				mov dl, ' '
 1097  CD 21		     2				int 21h
 1099  B2 22		     2				mov dl, '"'
 109B  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01DE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01DE eq 0
 = <dx, ax>		     3				??01DF     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01DF substr regStack, 1, (??01DE - 1)
			     3				regStack substr regStack, (??01DE + 1)
			     3			endif
			     3			exitm ??01DF
			     2		%	for ??01DD, __popRegs(regStack) 
			     2				pop ??01DD
			     2			endm
 109D  5A		     3				pop dx
 109E  58		     3				pop ax
				
 109F  8D 06 03BC R	   *	    lea    ax, TheUnexpectedChar
 10A3  50		   *	    push   ax
 10A4  E8 03EA		   *	    call   printf_s
					ReadCharTo proc near uses RegsReturningOnAX, Buffer:ptr byte
 10A7  E9 F2A7					mov dx, Buffer
						mov bx, FileHandle
 10AA						mov ah, 3Fh
						mov cx, 1
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01E1     textequ <>
 = 			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
 10AA  50		     5				push  ax
 = ax			     5				??01E2 catstr <ax>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 10AB  52		     5				push  dx
 = dx, ax		     5				??01E2 catstr <dx>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 = <dx, ax>		     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStack
			     5			endif
 10AC  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10AE  B2 28		     4				mov dl, '('
 10B0  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
 = <dx, ax>		     5				??01E5     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)
			     5				regStack substr regStack, (??01E4 + 1)
			     5			endif
			     5			exitm ??01E5
			     4		%	for ??01E3, __popRegs(regStack) 
			     4				pop ??01E3
			     4			endm
 10B2  5A		     5				pop dx
 10B3  58		     5				pop ax
 10B4  FF 36 03C1 R	   *	    push   FileLine
 10B8  E8 03F8		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01E7     textequ <>
 = 			     4			??01E8 textequ <>
			     4			for       ??01E6, <ax,dx>
			     4				push  ??01E6
			     4				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     4				??01E7 catstr <, >
			     4			endm
 10BB  50		     5				push  ax
 = ax			     5				??01E8 catstr <ax>, ??01E7, ??01E8
 = , 			     5				??01E7 catstr <, >
 10BC  52		     5				push  dx
 = dx, ax		     5				??01E8 catstr <dx>, ??01E7, ??01E8
 = , 			     5				??01E7 catstr <, >
 = <dx, ax>		     4			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     4			__pushRegs ??01E8
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01E8
			     5			else
			     5				regStack catstr ??01E8, REG_SET_DELIMITER, regStack
			     5			endif
 10BD  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10BF  B2 3A		     4				mov dl, ':'
 10C1  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01EA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01EA eq 0
 = <dx, ax>		     5				??01EB     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01EB substr regStack, 1, (??01EA - 1)
			     5				regStack substr regStack, (??01EA + 1)
			     5			endif
			     5			exitm ??01EB
			     4		%	for ??01E9, __popRegs(regStack) 
			     4				pop ??01E9
			     4			endm
 10C3  5A		     5				pop dx
 10C4  58		     5				pop ax
 10C5  FF 36 03BF R	   *	    push   FileCol
 10C9  E8 03E7		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01ED     textequ <>
 = 			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
 10CC  50		     5				push  ax
 = ax			     5				??01EE catstr <ax>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 10CD  52		     5				push  dx
 = dx, ax		     5				??01EE catstr <dx>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 = <dx, ax>		     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack
			     5			endif
 10CE  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10D0  B2 29		     4				mov dl, ')'
 10D2  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
 = <dx, ax>		     5				??01F1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)
			     5				regStack substr regStack, (??01F0 + 1)
			     5			endif
			     5			exitm ??01F1
			     4		%	for ??01EF, __popRegs(regStack) 
			     4				pop ??01EF
			     4			endm
 10D4  5A		     5				pop dx
 10D5  58		     5				pop ax
						int 21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01F3     textequ <>
 = 			     2			??01F4 textequ <>
			     2			for       ??01F2, <ax,dx>
			     2				push  ??01F2
			     2				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     2				??01F3 catstr <, >
			     2			endm
 10D6  50		     3				push  ax
 = ax			     3				??01F4 catstr <ax>, ??01F3, ??01F4
 = , 			     3				??01F3 catstr <, >
 10D7  52		     3				push  dx
 = dx, ax		     3				??01F4 catstr <dx>, ??01F3, ??01F4
 = , 			     3				??01F3 catstr <, >
 = <dx, ax>		     2			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     2			__pushRegs ??01F4
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01F4
			     3			else
			     3				regStack catstr ??01F4, REG_SET_DELIMITER, regStack
			     3			endif
 10D8  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 10DA  B2 20		     2				mov dl, ' '
 10DC  CD 21		     2				int 21h
 10DE  B2 45		     2				mov dl, 'E'
 10E0  CD 21		     2				int 21h
 10E2  B2 72		     2				mov dl, 'r'
 10E4  CD 21		     2				int 21h
 10E6  B2 72		     2				mov dl, 'r'
 10E8  CD 21		     2				int 21h
 10EA  B2 6F		     2				mov dl, 'o'
 10EC  CD 21		     2				int 21h
 10EE  B2 3A		     2				mov dl, ':'
 10F0  CD 21		     2				int 21h
 10F2  B2 20		     2				mov dl, ' '
 10F4  CD 21		     2				int 21h
 10F6  B2 4E		     2				mov dl, 'N'
 10F8  CD 21		     2				int 21h
 10FA  B2 20		     2				mov dl, ' '
 10FC  CD 21		     2				int 21h
 10FE  B2 64		     2				mov dl, 'd'
 1100  CD 21		     2				int 21h
 1102  B2 65		     2				mov dl, 'e'
 1104  CD 21		     2				int 21h
 1106  B2 76		     2				mov dl, 'v'
 1108  CD 21		     2				int 21h
 110A  B2 65		     2				mov dl, 'e'
 110C  CD 21		     2				int 21h
 110E  B2 20		     2				mov dl, ' '
 1110  CD 21		     2				int 21h
 1112  B2 65		     2				mov dl, 'e'
 1114  CD 21		     2				int 21h
 1116  B2 73		     2				mov dl, 's'
 1118  CD 21		     2				int 21h
 111A  B2 74		     2				mov dl, 't'
 111C  CD 21		     2				int 21h
 111E  B2 61		     2				mov dl, 'a'
 1120  CD 21		     2				int 21h
 1122  B2 72		     2				mov dl, 'r'
 1124  CD 21		     2				int 21h
 1126  B2 20		     2				mov dl, ' '
 1128  CD 21		     2				int 21h
 112A  B2 65		     2				mov dl, 'e'
 112C  CD 21		     2				int 21h
 112E  B2 6E		     2				mov dl, 'n'
 1130  CD 21		     2				int 21h
 1132  B2 74		     2				mov dl, 't'
 1134  CD 21		     2				int 21h
 1136  B2 72		     2				mov dl, 'r'
 1138  CD 21		     2				int 21h
 113A  B2 65		     2				mov dl, 'e'
 113C  CD 21		     2				int 21h
 113E  B2 20		     2				mov dl, ' '
 1140  CD 21		     2				int 21h
 1142  B2 32		     2				mov dl, '2'
 1144  CD 21		     2				int 21h
 1146  B2 20		     2				mov dl, ' '
 1148  CD 21		     2				int 21h
 114A  B2 65		     2				mov dl, 'e'
 114C  CD 21		     2				int 21h
 114E  B2 20		     2				mov dl, ' '
 1150  CD 21		     2				int 21h
 1152  B2 37		     2				mov dl, '7'
 1154  CD 21		     2				int 21h
 1156  B2 2E		     2				mov dl, '.'
 1158  CD 21		     2				int 21h
 115A  B2 20		     2				mov dl, ' '
 115C  CD 21		     2				int 21h
 115E  B2 4E		     2				mov dl, 'N'
 1160  CD 21		     2				int 21h
 1162  B2 20		     2				mov dl, ' '
 1164  CD 21		     2				int 21h
 1166  B2 65		     2				mov dl, 'e'
 1168  CD 21		     2				int 21h
 116A  B2 6E		     2				mov dl, 'n'
 116C  CD 21		     2				int 21h
 116E  B2 63		     2				mov dl, 'c'
 1170  CD 21		     2				int 21h
 1172  B2 6F		     2				mov dl, 'o'
 1174  CD 21		     2				int 21h
 1176  B2 6E		     2				mov dl, 'n'
 1178  CD 21		     2				int 21h
 117A  B2 74		     2				mov dl, 't'
 117C  CD 21		     2				int 21h
 117E  B2 72		     2				mov dl, 'r'
 1180  CD 21		     2				int 21h
 1182  B2 61		     2				mov dl, 'a'
 1184  CD 21		     2				int 21h
 1186  B2 64		     2				mov dl, 'd'
 1188  CD 21		     2				int 21h
 118A  B2 6F		     2				mov dl, 'o'
 118C  CD 21		     2				int 21h
 118E  B2 3A		     2				mov dl, ':'
 1190  CD 21		     2				int 21h
 1192  B2 20		     2				mov dl, ' '
 1194  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01F6 eq 0
 = <dx, ax>		     3				??01F7     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01F7 substr regStack, 1, (??01F6 - 1)
			     3				regStack substr regStack, (??01F6 + 1)
			     3			endif
			     3			exitm ??01F7
			     2		%	for ??01F5, __popRegs(regStack) 
			     2				pop ??01F5
			     2			endm
 1196  5A		     3				pop dx
 1197  58		     3				pop ax
						.if (carry?)
 1198  A0 03C7 R	   *	    mov    al, N
 119B  32 E4		   *	    xor    ah, ah
 119D  50		   *	    push   ax
 119E  E8 0312		   *	    call   printf_u
 11A1  E9 F1AD						call ErrorRead
						.endif
 11A4				
						; EOF
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01F9     textequ <>
 = 			     2			??01FA textequ <>
			     2			for       ??01F8, <ax,dx>
			     2				push  ??01F8
			     2				??01FA catstr <??01F8>, ??01F9, ??01FA
			     2				??01F9 catstr <, >
			     2			endm
 11A4  50		     3				push  ax
 = ax			     3				??01FA catstr <ax>, ??01F9, ??01FA
 = , 			     3				??01F9 catstr <, >
 11A5  52		     3				push  dx
 = dx, ax		     3				??01FA catstr <dx>, ??01F9, ??01FA
 = , 			     3				??01F9 catstr <, >
 = <dx, ax>		     2			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     2			__pushRegs ??01FA
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01FA
			     3			else
			     3				regStack catstr ??01FA, REG_SET_DELIMITER, regStack
			     3			endif
 11A6  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 11A8  B2 55		     2				mov dl, 'U'
 11AA  CD 21		     2				int 21h
 11AC  B2 6E		     2				mov dl, 'n'
 11AE  CD 21		     2				int 21h
 11B0  B2 61		     2				mov dl, 'a'
 11B2  CD 21		     2				int 21h
 11B4  B2 62		     2				mov dl, 'b'
 11B6  CD 21		     2				int 21h
 11B8  B2 6C		     2				mov dl, 'l'
 11BA  CD 21		     2				int 21h
 11BC  B2 65		     2				mov dl, 'e'
 11BE  CD 21		     2				int 21h
 11C0  B2 20		     2				mov dl, ' '
 11C2  CD 21		     2				int 21h
 11C4  B2 74		     2				mov dl, 't'
 11C6  CD 21		     2				int 21h
 11C8  B2 6F		     2				mov dl, 'o'
 11CA  CD 21		     2				int 21h
 11CC  B2 20		     2				mov dl, ' '
 11CE  CD 21		     2				int 21h
 11D0  B2 70		     2				mov dl, 'p'
 11D2  CD 21		     2				int 21h
 11D4  B2 61		     2				mov dl, 'a'
 11D6  CD 21		     2				int 21h
 11D8  B2 72		     2				mov dl, 'r'
 11DA  CD 21		     2				int 21h
 11DC  B2 73		     2				mov dl, 's'
 11DE  CD 21		     2				int 21h
 11E0  B2 65		     2				mov dl, 'e'
 11E2  CD 21		     2				int 21h
 11E4  B2 20		     2				mov dl, ' '
 11E6  CD 21		     2				int 21h
 11E8  B2 63		     2				mov dl, 'c'
 11EA  CD 21		     2				int 21h
 11EC  B2 6F		     2				mov dl, 'o'
 11EE  CD 21		     2				int 21h
 11F0  B2 6D		     2				mov dl, 'm'
 11F2  CD 21		     2				int 21h
 11F4  B2 6D		     2				mov dl, 'm'
 11F6  CD 21		     2				int 21h
 11F8  B2 61		     2				mov dl, 'a'
 11FA  CD 21		     2				int 21h
 11FC  B2 6E		     2				mov dl, 'n'
 11FE  CD 21		     2				int 21h
 1200  B2 64		     2				mov dl, 'd'
 1202  CD 21		     2				int 21h
 1204  B2 3A		     2				mov dl, ':'
 1206  CD 21		     2				int 21h
 1208  B2 20		     2				mov dl, ' '
 120A  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01FC instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01FC eq 0
 = <dx, ax>		     3				??01FD     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01FD substr regStack, 1, (??01FC - 1)
			     3				regStack substr regStack, (??01FC + 1)
			     3			endif
			     3			exitm ??01FD
			     2		%	for ??01FB, __popRegs(regStack) 
			     2				pop ??01FB
			     2			endm
 120C  5A		     3				pop dx
 120D  58		     3				pop ax
						.if ax == 0
 120E  8D 06 010D R	   *	    lea    ax, CommandBufferString
 1212  50		   *	    push   ax
 1213  E8 027B		   *	    call   printf_s
 1216  E9 F138						mov bx,           dx
							mov byte ptr[bx], 0
						.endif
				
						ret
					ReadCharTo endp
				
					MoveBack proc near uses RegsInvokeUses
						; Move back by one byte
						mov bx, FileHandle
				
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
 1219						mov al, 1
 1219  50		   *	    push   ax
 121A  53		   *	    push   bx
 121B  51		   *	    push   cx
 121C  52		   *	    push   dx
 121D  55		   *	    push   bp
						int 21h
 121E  E8 0059		   *	    call   ReadChar
						.if (carry?)
 1221  EB 31		   *	    jmp    @C00D3
 1223			   *@C00D4:
 1223  8A 1E 000D R					call ErrorRead
						.endif
						ret
 1227  80 FB 0A		   *	    cmp    bl, LF
 122A  75 0C		   *	    jne    @C00D5
 122C  FF 06 03C1 R			MoveBack endp
 1230  C7 06 03BF R 0001	
					PeekChar proc near uses RegsReturningOnAX
 1236  EB 19		   *	    jmp    @C00D7
 1238			   *@C00D5:
 1238  80 FB 0D		   *	    cmp    bl, CR
 123B  75 11		   *	    jne    @C00D8
						invoke ReadCharTo, addr PeekBuffer
			     1			invoke PeekChar
 123D  E8 009A		   *	    call   PeekChar
 1240  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 1244  80 FF 0A		   *	    cmp    bh, LF
 1247  74 08		   *	    je     @C00DA
 1249  E9 FDA5		     1				jmp ErrorUnexpectedChar
			     1			.endif
						invoke MoveBack
 124C  EB 03		   *	    jmp    @C00DC
 124E			   *@C00D8:
 124E  E9 FDA0					ret
					PeekChar endp
				
					ReadNum proc near uses RegsInvokeUses, result:ptr word
 1251			   *@C00DC:
 1251			   *@C00D7:
 1251			   *@C00DA:
 1251  E8 0026		   *	    call   ReadChar
						invoke ReadChar
 1254			   *@C00D3:
 1254  0B C0		   *	    or	ax, ax
 1256  75 CB		   *	    jne    @C00D4
						mov    ax, 0
 1258  5D		   *	    pop    bp
 1259  5A		   *	    pop    dx
 125A  59		   *	    pop    cx
 125B  5B		   *	    pop    bx
 125C  58		   *	    pop    ax
 125D  C3		   *	    ret    00000h
 125E						mov    bx, 0
						mov    cx, 10
 125E						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
			     1			local reg, comma, regpushed
 = 			     1			??01FF     textequ <>
 = 			     1			??0200 textequ <>
			     1			for       ??01FE, <ax,dx>
			     1				push  ??01FE
			     1				??0200 catstr <??01FE>, ??01FF, ??0200
			     1				??01FF catstr <, >
			     1			endm
 125E  50		     2				push  ax
 = ax			     2				??0200 catstr <ax>, ??01FF, ??0200
 = , 			     2				??01FF catstr <, >
 125F  52		     2				push  dx
 = dx, ax		     2				??0200 catstr <dx>, ??01FF, ??0200
 = , 			     2				??01FF catstr <, >
 = <dx, ax>		     1			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     1			__pushRegs ??0200
 = 0000			     2			size_s sizestr regStack
			     2			if     size_s eq 0
 = <dx, ax>		     2				regStack catstr ??0200
			     2			else
			     2				regStack catstr ??0200, REG_SET_DELIMITER, regStack
			     2			endif
 1260  B0 00						mul cx
 1262  8D 16 0005 R		
 1266  B4 3D						sub bl, '0'
 1268  CD 21						add ax, bx
				
 126A  73 03		   *	    jae    @C00DE
 126C  E8 F9A6						push   ax
							invoke ReadChar
 126F			   *@C00DE:
 126F  A3 0071 R					pop    ax
 1272  C6 06 0073 R 01					mov    bl, FileBuffer
						.endw
			     1			local reg
			     2			local regs_end, regs
 = 0000			     2			??0202 instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??0202 eq 0
 = <dx, ax>		     2				??0203     substr regStack, 1
 = 			     2				regStack textequ <>
			     2			else
			     2				??0203 substr regStack, 1, (??0202 - 1)
			     2				regStack substr regStack, (??0202 + 1)
			     2			endif
			     2			exitm ??0203
			     1		%	for ??0201, __popRegs(regStack) 
			     1				pop ??0201
			     1			endm
 1277  5A		     2				pop dx
 1278  58		     2				pop ax
 1279  C3					invoke MoveBack
 127A				
						mov bx,           result
 127A						mov word ptr[bx], ax
 127A  53		   *	    push   bx
 127B  51		   *	    push   cx
 127C  52		   *	    push   dx
 127D  55		   *	    push   bp
						ret
 127E  8D 06 000D R	   *	    lea    ax, FileBuffer
 1282  50		   *	    push   ax
 1283  E8 0009		   *	    call   ReadCharTo
 1286  FF 06 03BF R			ReadNum endp
				
 128A  5D		   *	    pop    bp
 128B  5A		   *	    pop    dx
 128C  59		   *	    pop    cx
 128D  5B		   *	    pop    bx
 128E  C3		   *	    ret    00000h
 128F					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
 128F						ReadMatrixLoop:
 128F  55		   *	    push   bp
 1290  8B EC		   *	    mov    bp, sp
 1292  53		   *	    push   bx
 1293  51		   *	    push   cx
 1294  52		   *	    push   dx
 1295  55		   *	    push   bp
 1296  8B 56 04						invoke ReadChar
 1299  8B 1E 0071 R					.if    ax == 0  ; EOF
 129D  B4 3F							mov al,       TotalCol
 129F  B9 0001							inc al                 ; TotalCol starts at 0
 12A2  CD 21							mov NPlusOne, al
								dec al                 ; ax = N
 12A4  73 03		   *	    jae    @C00E0
 12A6  E8 F9E5							mov N,        al       ; TotalCol starts at 0
								dec al
 12A9			   *@C00E0:
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
 12A9  0B C0		   *	    or	ax, ax
 12AB  75 05		   *	    jne    @C00E2
 12AD  8B DA								jmp ErrorInvalidN
 12AF  C6 07 00							.endif
								jmp EndReading
 12B2			   *@C00E2:
							.endif
				
 12B2  5D		   *	    pop    bp
 12B3  5A		   *	    pop    dx
 12B4  59		   *	    pop    cx
 12B5  5B		   *	    pop    bx
 12B6  5D		   *	    pop    bp
 12B7  C2 0002		   *	    ret    00002h
 12BA							mov bl, FileBuffer
				
 12BA							.if bl == 3Bh
								inc Col
 12BA  50		   *	    push   ax
 12BB  53		   *	    push   bx
 12BC  51		   *	    push   cx
 12BD  52		   *	    push   dx
 12BE  55		   *	    push   bp
 12BF  8B 1E 0071 R					.elseif bl == LF
								inc FileLine
 12C3  B4 42							mov FileCol, 1
 12C5  B9 FFFF							;====================================================================
 12C8  BA FFFF							; On a new line, the number of columns should always be the same
 12CB  B0 01							mov al,      Col
 12CD  CD 21							.if Row == 0
									mov TotalCol, al
 12CF  73 03		   *	    jae    @C00E4
 12D1  E8 F9BA							.elseif TotalCol != al
									jmp ErrorColumnCount
 12D4			   *@C00E4:
								.endif
 12D4  5D		   *	    pop    bp
 12D5  5A		   *	    pop    dx
 12D6  59		   *	    pop    cx
 12D7  5B		   *	    pop    bx
 12D8  58		   *	    pop    ax
 12D9  C3		   *	    ret    00000h
 12DA								;====================================================================
								; If next line is empty, all next lines should be empty
 12DA								invoke PeekChar
 12DA  53		   *	    push   bx
 12DB  51		   *	    push   cx
 12DC  52		   *	    push   dx
 12DD  55		   *	    push   bp
								mov    bh, PeekBuffer
 12DE  8D 06 03BB R	   *	    lea    ax, PeekBuffer
 12E2  50		   *	    push   ax
 12E3  E8 FFA9		   *	    call   ReadCharTo
								.if    bh == LF || bh == CR
 12E6  E8 FFD1		   *	    call   MoveBack
									invoke ReadEmptyLines
 12E9  5D		   *	    pop    bp
 12EA  5A		   *	    pop    dx
 12EB  59		   *	    pop    cx
 12EC  5B		   *	    pop    bx
 12ED  C3		   *	    ret    00000h
 12EE								;====================================================================
								; Otherwise, next line must have data
 12EE								.else
 12EE  55		   *	    push   bp
 12EF  8B EC		   *	    mov    bp, sp
 12F1  50		   *	    push   ax
 12F2  53		   *	    push   bx
 12F3  51		   *	    push   cx
 12F4  52		   *	    push   dx
 12F5  55		   *	    push   bp
									inc Row
 12F6  E8 FF81		   *	    call   ReadChar
 12F9  B8 0000								inc TotalRow
 12FC  BB 0000								mov Col, 0
 12FF  B9 000A							.endif
 1302  8A 1E 000D R					.elseif bl == CR
							; accept CR only before LF
 1306  EB 10		   *	    jmp    @C00E6
 1308			   *@C00E7:
 1308  F7 E1							HandleCR
							.elseif (bl == '-')
 130A  80 EB 30							CurrentIndexToBx
 130D  03 C3							invoke ReadNum, bx
								neg    sword ptr [bx]
 130F  50						.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
 1310  E8 FF67		   *	    call   ReadChar
 1313  58							CurrentIndexToBx
 1314  8A 1E 000D R						invoke ReadNum, bx
							.else
 1318			   *@C00E6:
 1318  80 FB 39		   *	    cmp    bl, '9'
 131B  77 05		   *	    ja     @C00E8
 131D  80 FB 30		   *	    cmp    bl, '0'
 1320  73 E6		   *	    jae    @C00E7
 1322			   *@C00E8:
								jmp ErrorUnexpectedChar
 1322  E8 FF95		   *	    call   MoveBack
							.endif
 1325  8B 5E 04						jmp ReadMatrixLoop
 1328  89 07					EndReading:
							CloseFileHandle
 132A  5D		   *	    pop    bp
 132B  5A		   *	    pop    dx
 132C  59		   *	    pop    cx
 132D  5B		   *	    pop    bx
 132E  58		   *	    pop    ax
 132F  5D		   *	    pop    bp
 1330  C2 0002		   *	    ret    00002h
 1333						ret
					ReadMatrix endp
 1333				
 1333  50		   *	    push   ax
 1334  53		   *	    push   bx
 1335  51		   *	    push   cx
 1336  52		   *	    push   dx
 1337  55		   *	    push   bp
				;====================================================================
 1338  E8 FF23		   *	    call   OpenFile
 133B				; Printf
				
 133B  E8 FF3C		   *	    call   ReadChar
					PrintMatrix proc near uses RegsInvokeUses
 133E  0B C0		   *	    or	ax, ax
 1340  75 28		   *	    jne    @C00EA
 1342  A0 03C6 R				mov      bx, offset Matrix
 1345  FE C0					mov      dx, 8
 1347  A2 03C8 R				mov      cx, 0             ; High has row, Low has column
 134A  FE C8					.ForRow:                   ; for (row = 0; row < N; row++)
 134C  A2 03C7 R					cmp ch, N      ; row < N
 134F  FE C8						jge .EndForRow
				
 1351  38 06 03C5 R	   *	    cmp    TotalRow, al
 1355  74 05		   *	    je     @C00EC
 1357  E9 FAE2						mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
 135A  EB 0B		   *	    jmp    @C00EE
 135C			   *@C00EC:
 135C  3C 02		   *	    cmp    al, 002h
 135E  72 04		   *	    jb     @C00F0
 1360  3C 07		   *	    cmp    al, 007h
 1362  76 03		   *	    jbe    @C00EF
 1364			   *@C00F0:
 1364  E9 FD43							cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
 1367			   *@C00EF:
 1367			   *@C00EE:
 1367  E9 00CC			
								mov ax, sword ptr [bx]
 136A			   *@C00EA:
								invoke printf_d_padded, ax, dx
 136A  8A 1E 000D R		
								add bx, 2 ; size in bytes of a sword
				
 136E  80 FB 3B		   *	    cmp    bl, 03Bh
 1371  75 07		   *	    jne    @C00F2
 1373  FE 06 03C4 R						inc cl      ; col ++
								jmp .ForCol
 1377  E9 00B9		   *	    jmp    @C00F4
 137A			   *@C00F2:
 137A  80 FB 0A		   *	    cmp    bl, LF
 137D  75 47		   *	    jne    @C00F5
 137F  FF 06 03C1 R					.EndForCol:
 1383  C7 06 03BF R 0001				putc CR
							putc LF
				
 1389  A0 03C4 R					inc ch      ; row++
							jmp .ForRow
 138C  80 3E 03C3 R 00	   *	    cmp    Row, 000h
 1391  75 05		   *	    jne    @C00F7
 1393  A2 03C6 R				.EndForRow:
						ret
 1396  EB 09		   *	    jmp    @C00F9
 1398			   *@C00F7:
 1398  38 06 03C6 R	   *	    cmp    TotalCol, al
 139C  74 03		   *	    je     @C00FA
 139E  E9 F962				PrintMatrix endp
				
					printf_s proc near uses RegsInvokeUses, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
 13A1			   *@C00FA:
 13A1			   *@C00F9:
 13A1  E8 FF36		   *	    call   PeekChar
 13A4  8A 3E 03BB R					mov ah, 2
							mov dl, [bx]
 13A8  80 FF 0A		   *	    cmp    bh, LF
 13AB  74 05		   *	    je     @C00FD
 13AD  80 FF 0D		   *	    cmp    bh, CR
 13B0  75 05		   *	    jne    @C00FC
 13B2			   *@C00FD:
							int 21H
 13B2  E8 FE64		   *	    call   ReadEmptyLines
							inc bx
						.endw
						ret
 13B5  EB 7C		   *	    jmp    @C00FF
 13B7			   *@C00FC:
 13B7  FE 06 03C3 R			printf_s endp
 13BB  FE 06 03C5 R		
 13BF  C6 06 03C4 R 00			printf_u proc near uses RegsInvokeUses, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
 13C4  EB 6D		   *	    jmp    @C0100
 13C6			   *@C00F5:
 13C6  80 FB 0D		   *	    cmp    bl, CR
 13C9  75 11		   *	    jne    @C0101
						invoke printf_s, addr buf
						ret
			     1			invoke PeekChar
 13CB  E8 FF0C		   *	    call   PeekChar
 13CE  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 13D2  80 FF 0A		   *	    cmp    bh, LF
 13D5  74 5C		   *	    je     @C0103
 13D7  E9 FC17		     1				jmp ErrorUnexpectedChar
			     1			.endif
					printf_u endp
 13DA  EB 57		   *	    jmp    @C0105
 13DC			   *@C0101:
 13DC  80 FB 2D		   *	    cmp    bl, '-'
 13DF  75 22		   *	    jne    @C0106
				
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??0205     textequ <>
 = 			     2			??0206 textequ <>
			     2			for       ??0204, <ax>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
 13E1  50		     3				push  ax
 = ax			     3				??0206 catstr <ax>, ??0205, ??0206
 = , 			     3				??0205 catstr <, >
 = <ax>			     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack
			     3			endif
 13E2  A0 03C6 R	     1			mov      al, TotalCol
 13E5  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 13E7  8A 1E 03C3 R	     1			mov bl, Row
 13EB  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 13EF  F6 E3		     1			mul bl
 13F1  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 13F3  D1 E0		     1			shl ax, 1
 13F5  05 03C9 R	     1			add ax, offset Matrix
			     1	
 13F8  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
 = <ax>			     3				??0209     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)
			     3				regStack substr regStack, (??0208 + 1)
			     3			endif
			     3			exitm ??0209
			     2		%	for ??0207, __popRegs(regStack) 
			     2				pop ??0207
			     2			endm
 13FA  58		     3				pop ax
					printf_d proc near uses RegsInvokeUses, number:sword
 13FB  53		   *	    push   bx
 13FC  E8 FEEF		   *	    call   ReadNum
 13FF  F7 1F					local  buf[7]:byte
						invoke string_from_sword, addr buf, number
 1401  EB 30		   *	    jmp    @C0108
 1403			   *@C0106:
 1403  80 FB 39		   *	    cmp    bl, '9'
 1406  77 28		   *	    ja     @C0109
 1408  80 FB 30		   *	    cmp    bl, '0'
 140B  72 23		   *	    jb     @C0109
						invoke printf_s, addr buf
 140D  E8 FEAA		   *	    call   MoveBack
						ret
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??020B     textequ <>
 = 			     2			??020C textequ <>
			     2			for       ??020A, <ax>
			     2				push  ??020A
			     2				??020C catstr <??020A>, ??020B, ??020C
			     2				??020B catstr <, >
			     2			endm
 1410  50		     3				push  ax
 = ax			     3				??020C catstr <ax>, ??020B, ??020C
 = , 			     3				??020B catstr <, >
 = <ax>			     2			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     2			__pushRegs ??020C
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??020C
			     3			else
			     3				regStack catstr ??020C, REG_SET_DELIMITER, regStack
			     3			endif
 1411  A0 03C6 R	     1			mov      al, TotalCol
 1414  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 1416  8A 1E 03C3 R	     1			mov bl, Row
 141A  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 141E  F6 E3		     1			mul bl
 1420  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 1422  D1 E0		     1			shl ax, 1
 1424  05 03C9 R	     1			add ax, offset Matrix
			     1	
 1427  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??020E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??020E eq 0
 = <ax>			     3				??020F     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??020F substr regStack, 1, (??020E - 1)
			     3				regStack substr regStack, (??020E + 1)
			     3			endif
			     3			exitm ??020F
			     2		%	for ??020D, __popRegs(regStack) 
			     2				pop ??020D
			     2			endm
 1429  58		     3				pop ax
					printf_d endp
 142A  53		   *	    push   bx
 142B  E8 FEC0		   *	    call   ReadNum
					
 142E  EB 03		   *	    jmp    @C010C
 1430			   *@C0109:
 1430  E9 FBBE				printf_d_padded proc near uses RegsInvokeUses, number:sword, padTo:sword
						local  buf[7]:byte
 1433			   *@C010C:
 1433			   *@C0108:
 1433			   *@C0105:
 1433			   *@C0100:
 1433			   *@C00F4:
 1433			   *@C00FF:
 1433			   *@C0103:
 1433  E9 FF05					invoke string_from_sword, addr buf, number
 1436						; string_from_sword gives length on AX
						mov    cx, padTo
 1436  B4 3E		     1			mov ah, 3eh
 1438  8B 1E 0071 R	     1			mov bx, FileHandle
 143C  CD 21		     1			int 21h
			     1			
 143E  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
						sub    cx, ax
 1443  5D		   *	    pop    bp
 1444  5A		   *	    pop    dx
 1445  59		   *	    pop    cx
 1446  5B		   *	    pop    bx
 1447  58		   *	    pop    ax
 1448  C3		   *	    ret    00000h
 1449						.WHILE (sword ptr cx > 0)
							putc SPACE
							dec  cx
						.ENDW
						invoke printf_s, addr buf
 1449						ret
 1449  50		   *	    push   ax
 144A  53		   *	    push   bx
 144B  51		   *	    push   cx
 144C  52		   *	    push   dx
 144D  55		   *	    push   bp
 144E  BB 03C9 R			printf_d_padded endp
 1451  BA 0008			
 1454  B9 0000				; length of string goes to ax (including sign)
 1457					string_from_sword proc near uses RegsReturningOnAX, string:ptr byte, number:sword
 1457  3A 2E 03C7 R				mov dx, number
 145B  7D 2E					mov bx, string
						mov cx, 0
 145D  B1 00					.if (sword ptr dx < 0)
 145F							mov byte ptr[bx], '-'
 145F  3A 0E 03C8 R					inc bx
 1463  7D 0E						inc cx
							neg dx
 1465  8B 07					.endif
						invoke string_from_word, bx, dx
 1467  52		   *	    push   dx
 1468  50		   *	    push   ax
 1469  E8 0095		   *	    call   printf_d_padded
						add ax, cx
 146C  83 C3 02					ret
					string_from_sword endp
 146F  FE C1			
 1471  EB EC				; length of string goes to ax
 1473					string_from_word proc near uses RegsReturningOnAX si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0211     textequ <>
 = 			     2			??0212 textequ <>
			     2			for       ??0210, <ax,dx>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
 1473  50		     3				push  ax
 = ax			     3				??0212 catstr <ax>, ??0211, ??0212
 = , 			     3				??0211 catstr <, >
 1474  52		     3				push  dx
 = dx, ax		     3				??0212 catstr <dx>, ??0211, ??0212
 = , 			     3				??0211 catstr <, >
 = <dx, ax>		     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack
			     3			endif
 1475  B4 02		     1			mov      ah, 02h
 1477  B2 0D		     1			mov      dl, CR
 1479  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
 = <dx, ax>		     3				??0215     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)
			     3				regStack substr regStack, (??0214 + 1)
			     3			endif
			     3			exitm ??0215
			     2		%	for ??0213, __popRegs(regStack) 
			     2				pop ??0213
			     2			endm
 147B  5A		     3				pop dx
 147C  58		     3				pop ax
				
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0217     textequ <>
 = 			     2			??0218 textequ <>
			     2			for       ??0216, <ax,dx>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
 147D  50		     3				push  ax
 = ax			     3				??0218 catstr <ax>, ??0217, ??0218
 = , 			     3				??0217 catstr <, >
 147E  52		     3				push  dx
 = dx, ax		     3				??0218 catstr <dx>, ??0217, ??0218
 = , 			     3				??0217 catstr <, >
 = <dx, ax>		     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack
			     3			endif
 147F  B4 02		     1			mov      ah, 02h
 1481  B2 0A		     1			mov      dl, LF
 1483  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
 = <dx, ax>		     3				??021B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)
			     3				regStack substr regStack, (??021A + 1)
			     3			endif
			     3			exitm ??021B
			     2		%	for ??0219, __popRegs(regStack) 
			     2				pop ??0219
			     2			endm
 1485  5A		     3				pop dx
 1486  58		     3				pop ax
						mov divisor, 10000
 1487  FE C5					mov first,   1     ; anything not 0 is true
 1489  EB CC			
 148B						mov ax,    number
						mov value, ax
 148B  5D		   *	    pop    bp
 148C  5A		   *	    pop    dx
 148D  59		   *	    pop    cx
 148E  5B		   *	    pop    bx
 148F  58		   *	    pop    ax
 1490  C3		   *	    ret    00000h
 1491				
						mov bx, string
 1491						mov cx, 5
 1491  55		   *	    push   bp
 1492  8B EC		   *	    mov    bp, sp
 1494  50		   *	    push   ax
 1495  53		   *	    push   bx
 1496  51		   *	    push   cx
 1497  52		   *	    push   dx
 1498  55		   *	    push   bp
 1499  8B 5E 04					.repeat
							mov dx,    0
 149C  EB 07		   *	    jmp    @C010D
 149E			   *@C010E:
 149E  B4 02						mov ax,    value
 14A0  8A 17						div divisor
 14A2  CD 21						mov value, dx
 14A4  43			
							.if (ax != 0) || (!first) ; no zeroes on the left
 14A5			   *@C010D:
 14A5  80 3F 00		   *	    cmp    byte ptr [bx], 000h
 14A8  75 F4		   *	    jne    @C010E
								add al,            '0'
 14AA  5D		   *	    pop    bp
 14AB  5A		   *	    pop    dx
 14AC  59		   *	    pop    cx
 14AD  5B		   *	    pop    bx
 14AE  58		   *	    pop    ax
 14AF  5D		   *	    pop    bp
 14B0  C2 0002		   *	    ret    00002h
 14B3								mov byte ptr [bx], al
								inc bx
 14B3								mov first,         0
							.endif
 14B3  55		   *	    push   bp
 14B4  8B EC		   *	    mov    bp, sp
 14B6  83 C4 FA		   *	    add    sp, 0FFFAh
 14B9  50		   *	    push   ax
 14BA  53		   *	    push   bx
 14BB  51		   *	    push   cx
 14BC  52		   *	    push   dx
 14BD  55		   *	    push   bp
				
 14BE  FF 76 04		   *	    push   word  ptr ss:[bp]+00004h
 14C1  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14C4  50		   *	    push   ax
 14C5  E8 00A2		   *	    call   string_from_word
							mov dx,      0
 14C8  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14CB  50		   *	    push   ax
 14CC  E8 FFC2		   *	    call   printf_s
							mov ax,      divisor
 14CF  5D		   *	    pop    bp
 14D0  5A		   *	    pop    dx
 14D1  59		   *	    pop    cx
 14D2  5B		   *	    pop    bx
 14D3  58		   *	    pop    ax
 14D4  8B E5		   *	    mov    sp, bp
 14D6  5D		   *	    pop    bp
 14D7  C2 0002		   *	    ret    00002h
 14DA							mov si,      10
							div si
 14DA							mov divisor, ax
				
 14DA  55		   *	    push   bp
 14DB  8B EC		   *	    mov    bp, sp
 14DD  83 C4 F8		   *	    add    sp, 0FFF8h
 14E0  50		   *	    push   ax
 14E1  53		   *	    push   bx
 14E2  51		   *	    push   cx
 14E3  52		   *	    push   dx
 14E4  55		   *	    push   bp
						.untilcxz
 14E5  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 14E8  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14EB  50		   *	    push   ax
 14EC  E8 0050		   *	    call   string_from_sword
				
 14EF  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14F2  50		   *	    push   ax
 14F3  E8 FF9B		   *	    call   printf_s
						.if (first)
 14F6  5D		   *	    pop    bp
 14F7  5A		   *	    pop    dx
 14F8  59		   *	    pop    cx
 14F9  5B		   *	    pop    bx
 14FA  58		   *	    pop    ax
 14FB  8B E5		   *	    mov    sp, bp
 14FD  5D		   *	    pop    bp
 14FE  C2 0002		   *	    ret    00002h
 1501							mov byte ptr [bx], '0'
							inc bx
 1501						.endif
				
 1501  55		   *	    push   bp
 1502  8B EC		   *	    mov    bp, sp
 1504  83 C4 F8		   *	    add    sp, 0FFF8h
 1507  50		   *	    push   ax
 1508  53		   *	    push   bx
 1509  51		   *	    push   cx
 150A  52		   *	    push   dx
 150B  55		   *	    push   bp
						mov cx, string
 150C  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 150F  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 1512  50		   *	    push   ax
 1513  E8 0029		   *	    call   string_from_sword
						mov ax, bx
 1516  8B 4E 06					sub ax, cx     ; ax = bx - string = len
 1519  2B C8			
						mov byte ptr [bx], 0
 151B  EB 0B		   *	    jmp    @C0110
 151D			   *@C0111:
						ret
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??021D     textequ <>
 = 			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
 151D  50		     3				push  ax
 = ax			     3				??021E catstr <ax>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 151E  52		     3				push  dx
 = dx, ax		     3				??021E catstr <dx>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 = <dx, ax>		     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack
			     3			endif
 151F  B4 02		     1			mov      ah, 02h
 1521  B2 20		     1			mov      dl, SPACE
 1523  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
 = <dx, ax>		     3				??0221     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)
			     3				regStack substr regStack, (??0220 + 1)
			     3			endif
			     3			exitm ??0221
			     2		%	for ??021F, __popRegs(regStack) 
			     2				pop ??021F
			     2			endm
 1525  5A		     3				pop dx
 1526  58		     3				pop ax
 1527  49				string_from_word endp
				
 1528			   *@C0110:
 1528  83 F9 00		   *	    cmp    sword ptr cx, 000h
 152B  7F F0		   *	    jg     @C0111
				;--------------------------------------------------------------------
 152D  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 1530  50		   *	    push   ax
 1531  E8 FF5D		   *	    call   printf_s
				end
 1534  5D		   *	    pop    bp
 1535  5A		   *	    pop    dx
 1536  59		   *	    pop    cx
 1537  5B		   *	    pop    bx
 1538  58		   *	    pop    ax
 1539  8B E5		   *	    mov    sp, bp
 153B  5D		   *	    pop    bp
 153C  C2 0004		   *	    ret    00004h
 153F
 153F
 153F  55		   *	    push   bp
 1540  8B EC		   *	    mov    bp, sp
 1542  53		   *	    push   bx
 1543  51		   *	    push   cx
 1544  52		   *	    push   dx
 1545  55		   *	    push   bp
 1546  8B 56 06
 1549  8B 5E 04
 154C  B9 0000
 154F  83 FA 00		   *	    cmp    sword ptr dx, 000h
 1552  7D 07		   *	    jge    @C0113
 1554  C6 07 2D
 1557  43
 1558  41
 1559  F7 DA
 155B			   *@C0113:
 155B  52		   *	    push   dx
 155C  53		   *	    push   bx
 155D  E8 000A		   *	    call   string_from_word
 1560  03 C1
 1562  5D		   *	    pop    bp
 1563  5A		   *	    pop    dx
 1564  59		   *	    pop    cx
 1565  5B		   *	    pop    bx
 1566  5D		   *	    pop    bp
 1567  C2 0004		   *	    ret    00004h
 156A
 156A
 156A  55		   *	    push   bp
 156B  8B EC		   *	    mov    bp, sp
 156D  83 C4 FA		   *	    add    sp, 0FFFAh
 1570  53		   *	    push   bx
 1571  51		   *	    push   cx
 1572  52		   *	    push   dx
 1573  55		   *	    push   bp
 1574  56		   *	    push   si
 1575  C7 46 FC 2710
 157A  C6 46 FB 01
 157E  8B 46 06
 1581  89 46 FE
 1584  8B 5E 04
 1587  B9 0005
 158A			   *@C0115:
 158A  BA 0000
 158D  8B 46 FE
 1590  F7 76 FC
 1593  89 56 FE
 1596  0B C0		   *	    or	ax, ax
 1598  75 06		   *	    jne    @C0117
 159A  80 7E FB 00	   *	    cmp    first, 000h
 159E  75 09		   *	    jne    @C0116
 15A0			   *@C0117:
 15A0  04 30
 15A2  88 07
 15A4  43
 15A5  C6 46 FB 00
 15A9			   *@C0116:
 15A9  BA 0000
 15AC  8B 46 FC
 15AF  BE 000A
 15B2  F7 F6
 15B4  89 46 FC
 15B7  E2 D1		   *	    loop   @C0115
 15B9  80 7E FB 00	   *	    cmp    first, 000h
 15BD  74 04		   *	    je     @C0119
 15BF  C6 07 30
 15C2  43
 15C3			   *@C0119:
 15C3  8B 4E 04
 15C6  8B C3
 15C8  2B C1
 15CA  C6 07 00
 15CD  5E		   *	    pop    si
 15CE  5D		   *	    pop    bp
 15CF  5A		   *	    pop    dx
 15D0  59		   *	    pop    cx
 15D1  5B		   *	    pop    bx
 15D2  8B E5		   *	    mov    sp, bp
 15D4  5D		   *	    pop    bp
 15D5  C2 0004		   *	    ret    00004h
 15D8
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 10:06:38
main.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CloseFileHandle  . . . . . . . .	Proc
CurrentIndexToBx . . . . . . . .	Proc
DEFINED  . . . . . . . . . . . .	Func
ErrorCantOpenNorCreate . . . . .	Proc
ErrorCommandExpectsNumber  . . .	Proc
ErrorNumberOutOfBounds . . . . .	Proc
HandleCR . . . . . . . . . . . .	Proc
RestoreRegs  . . . . . . . . . .	Proc
SaveRegs . . . . . . . . . . . .	Proc
SkipSpacesInSI . . . . . . . . .	Proc
StartsWith . . . . . . . . . . .	Proc
WriteToFile  . . . . . . . . . .	Proc
__popRegs  . . . . . . . . . . .	Func
__pushRegs . . . . . . . . . . .	Proc
jumpIfSIComparesTo . . . . . . .	Proc
print_FilePosition . . . . . . .	Proc
print_Pair . . . . . . . . . . .	Proc
print_TotalRowCol  . . . . . . .	Proc
printf_c . . . . . . . . . . . .	Proc
putc . . . . . . . . . . . . . .	Proc
skipAndRead  . . . . . . . . . .	Proc
strcpy_all . . . . . . . . . . .	Proc
strcpy_c . . . . . . . . . . . .	Proc
strcpy . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 042B	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 15D8	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ADDMatrix  . . . . . . . . . . .	P Near	 01A0	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  ADDMatrix@Loop . . . . . . . .	L Near	 01DA	  _TEXT	
DIVMatrix  . . . . . . . . . . .	P Near	 0168	  _TEXT	Length= 0038 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  DIVMatrix@Loop . . . . . . . .	L Near	 018A	  _TEXT	
ExitAndClose . . . . . . . . . .	P Near	 0356	  _TEXT	Length= 0019 Public STDCALL
ExitFailure  . . . . . . . . . .	P Near	 0351	  _TEXT	Length= 0005 Public STDCALL
ExitSuccess  . . . . . . . . . .	P Near	 034C	  _TEXT	Length= 0005 Public STDCALL
MULMatrix  . . . . . . . . . . .	P Near	 0131	  _TEXT	Length= 0037 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  MULMatrix@Loop . . . . . . . .	L Near	 0153	  _TEXT	
Main@ADD . . . . . . . . . . . .	P Near	 0091	  _TEXT	Length= 0020 Public STDCALL
Main@MUL . . . . . . . . . . . .	P Near	 00B1	  _TEXT	Length= 001C Public STDCALL
Main@UNDO  . . . . . . . . . . .	P Near	 00CD	  _TEXT	Length= 005F Public STDCALL
Main@WRITE . . . . . . . . . . .	P Near	 012C	  _TEXT	Length= 0005 Public STDCALL
MoveBack . . . . . . . . . . . .	P Near	 12BA	  _TEXT	Length= 0020 Public STDCALL
OpenFile . . . . . . . . . . . .	P Near	 125E	  _TEXT	Length= 001C Public STDCALL
ParseCommand@CONSTANTE_AUSENTE .	P Near	 07FB	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_AUSENTE . . .	P Near	 0721	  _TEXT	Length= 00DA Public STDCALL
ParseCommand@LINHA_DST_AUSENTE .	P Near	 08E1	  _TEXT	Length= 00EA Public STDCALL
ParseCommand@LINHA_DST_INVALIDA 	P Near	 0B1D	  _TEXT	Length= 007C Public STDCALL
ParseCommand@LINHA_INVALIDA  . .	P Near	 0AB1	  _TEXT	Length= 006C Public STDCALL
ParseCommand@LINHA_ORG_AUSENTE .	P Near	 09CB	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_ORG_INVALIDA 	P Near	 0B99	  _TEXT	Length= 007C Public STDCALL
ParseCommand . . . . . . . . . .	P Near	 03FC	  _TEXT	Length= 0325 Public STDCALL
  a  . . . . . . . . . . . . . .	Word	 bp - 0002
  ??004A . . . . . . . . . . . .	L Near	 0433	  _TEXT	
  ??004B . . . . . . . . . . . .	L Near	 0436	  _TEXT	
  ??0054 . . . . . . . . . . . .	L Near	 0466	  _TEXT	
  ??0055 . . . . . . . . . . . .	L Near	 0469	  _TEXT	
  ??005E . . . . . . . . . . . .	L Near	 04A2	  _TEXT	
  ??005F . . . . . . . . . . . .	L Near	 04A5	  _TEXT	
  ??0068 . . . . . . . . . . . .	L Near	 04E7	  _TEXT	
  ??0069 . . . . . . . . . . . .	L Near	 04EA	  _TEXT	
  ??0072 . . . . . . . . . . . .	L Near	 0523	  _TEXT	
  ??0073 . . . . . . . . . . . .	L Near	 0526	  _TEXT	
  ??007C . . . . . . . . . . . .	L Near	 055F	  _TEXT	
  ??007D . . . . . . . . . . . .	L Near	 0562	  _TEXT	
  ParseCommand@error . . . . . .	L Near	 05CD	  _TEXT	
  ParseCommand@MUL . . . . . . .	L Near	 05D5	  _TEXT	
  ParseCommand@ADD . . . . . . .	L Near	 0634	  _TEXT	
  ParseCommand@UNDO  . . . . . .	L Near	 06B1	  _TEXT	
  ParseCommand@WRITE . . . . . .	L Near	 06B6	  _TEXT	
  ParseCommand@EXIT  . . . . . .	L Near	 06CD	  _TEXT	
  ParseCommand@success . . . . .	L Near	 06CF	  _TEXT	
PeekChar . . . . . . . . . . . .	P Near	 12DA	  _TEXT	Length= 0014 Public STDCALL
PrintMatrix  . . . . . . . . . .	P Near	 1449	  _TEXT	Length= 0048 Public STDCALL
  .ForRow  . . . . . . . . . . .	L Near	 1457	  _TEXT	
  .ForCol  . . . . . . . . . . .	L Near	 145F	  _TEXT	
  .EndForCol . . . . . . . . . .	L Near	 1473	  _TEXT	
  .EndForRow . . . . . . . . . .	L Near	 148B	  _TEXT	
ReadCharTo . . . . . . . . . . .	P Near	 128F	  _TEXT	Length= 002B Public STDCALL
  Buffer . . . . . . . . . . . .	Word	 bp + 0004
ReadChar . . . . . . . . . . . .	P Near	 127A	  _TEXT	Length= 0015 Public STDCALL
ReadCommand  . . . . . . . . . .	P Near	 036F	  _TEXT	Length= 002F Public STDCALL
ReadEmptyLines . . . . . . . . .	P Near	 1219	  _TEXT	Length= 0045 Public STDCALL
ReadMatrix . . . . . . . . . . .	P Near	 1333	  _TEXT	Length= 0120 Public STDCALL
  ReadMatrixLoop . . . . . . . .	L Near	 133B	  _TEXT	
  EndReading . . . . . . . . . .	L Near	 1436	  _TEXT	
ReadNumFromString  . . . . . . .	P Near	 039E	  _TEXT	Length= 005E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  result . . . . . . . . . . . .	Word	 bp + 0006
ReadNum  . . . . . . . . . . . .	P Near	 12EE	  _TEXT	Length= 0045 Public STDCALL
  result . . . . . . . . . . . .	Word	 bp + 0004
SUBMatrix  . . . . . . . . . . .	P Near	 01F3	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  SUBMatrix@Loop . . . . . . . .	L Near	 022D	  _TEXT	
WRITEMatrix  . . . . . . . . . .	P Near	 0246	  _TEXT	Length= 0106 Public STDCALL
  NOME . . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
  handle . . . . . . . . . . . .	Word	 bp - 000A
  create_file  . . . . . . . . .	L Near	 0262	  _TEXT	
  file_opened  . . . . . . . . .	L Near	 026E	  _TEXT	
  WRITEMatrix@ForRow . . . . . .	L Near	 02CE	  _TEXT	
  WRITEMatrix@ForCol . . . . . .	L Near	 02D8	  _TEXT	
  WRITEMatrix@EndForCol  . . . .	L Near	 031B	  _TEXT	
  WRITEMatrix@EndForRow  . . . .	L Near	 0333	  _TEXT	
printf_d_padded  . . . . . . . .	P Near	 1501	  _TEXT	Length= 003E Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  padTo  . . . . . . . . . . . .	Word	 bp + 0006
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_d . . . . . . . . . . . .	P Near	 14DA	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_s . . . . . . . . . . . .	P Near	 1491	  _TEXT	Length= 0022 Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
printf_u . . . . . . . . . . . .	P Near	 14B3	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0006
string_from_sword  . . . . . . .	P Near	 153F	  _TEXT	Length= 002B Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
string_from_word . . . . . . . .	P Near	 156A	  _TEXT	Length= 006E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
  value  . . . . . . . . . . . .	Word	 bp - 0002
  divisor  . . . . . . . . . . .	Word	 bp - 0004
  first  . . . . . . . . . . . .	Byte	 bp - 0005


Symbols:

                N a m e                 Type     Value    Attr

??0001 . . . . . . . . . . . . .	Text   	 , 
??0002 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0004 . . . . . . . . . . . . .	Number	 0000h	 
??0005 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0007 . . . . . . . . . . . . .	Text   	 , 
??0008 . . . . . . . . . . . . .	Text   	 <dx, ax>
??000A . . . . . . . . . . . . .	Number	 0000h	 
??000B . . . . . . . . . . . . .	Text   	 <dx, ax>
??000D . . . . . . . . . . . . .	Text   	 , 
??000E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0010 . . . . . . . . . . . . .	Number	 0000h	 
??0011 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0013 . . . . . . . . . . . . .	Text   	 , 
??0014 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0016 . . . . . . . . . . . . .	Number	 0000h	 
??0017 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0019 . . . . . . . . . . . . .	Text   	 , 
??001A . . . . . . . . . . . . .	Text   	 <ax>
??001C . . . . . . . . . . . . .	Number	 0000h	 
??001D . . . . . . . . . . . . .	Text   	 <ax>
??001F . . . . . . . . . . . . .	Text   	 , 
??0020 . . . . . . . . . . . . .	Text   	 <ax>
??0022 . . . . . . . . . . . . .	Number	 0000h	 
??0023 . . . . . . . . . . . . .	Text   	 <ax>
??0025 . . . . . . . . . . . . .	Text   	 , 
??0026 . . . . . . . . . . . . .	Text   	 <ax>
??0028 . . . . . . . . . . . . .	Number	 0000h	 
??0029 . . . . . . . . . . . . .	Text   	 <ax>
??002B . . . . . . . . . . . . .	Text   	 , 
??002C . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??002E . . . . . . . . . . . . .	Number	 0000h	 
??002F . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0031 . . . . . . . . . . . . .	Text   	 , 
??0032 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0034 . . . . . . . . . . . . .	Number	 0000h	 
??0035 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0037 . . . . . . . . . . . . .	Text   	 , 
??0038 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003A . . . . . . . . . . . . .	Number	 0000h	 
??003B . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003D . . . . . . . . . . . . .	Text   	 , 
??003E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0040 . . . . . . . . . . . . .	Number	 0000h	 
??0041 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0043 . . . . . . . . . . . . .	Text   	 , 
??0044 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0046 . . . . . . . . . . . . .	Number	 0000h	 
??0047 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0048 . . . . . . . . . . . . .	Number	 0003h	 
??004D . . . . . . . . . . . . .	Text   	 , 
??004E . . . . . . . . . . . . .	Text   	 <bx, ax>
??0050 . . . . . . . . . . . . .	Number	 0000h	 
??0051 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0052 . . . . . . . . . . . . .	Number	 0003h	 
??0057 . . . . . . . . . . . . .	Text   	 , 
??0058 . . . . . . . . . . . . .	Text   	 <bx, ax>
??005A . . . . . . . . . . . . .	Number	 0000h	 
??005B . . . . . . . . . . . . .	Text   	 <bx, ax>
??005C . . . . . . . . . . . . .	Number	 0004h	 
??0061 . . . . . . . . . . . . .	Text   	 , 
??0062 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0064 . . . . . . . . . . . . .	Number	 0000h	 
??0065 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0066 . . . . . . . . . . . . .	Number	 0005h	 
??006B . . . . . . . . . . . . .	Text   	 , 
??006C . . . . . . . . . . . . .	Text   	 <bx, ax>
??006E . . . . . . . . . . . . .	Number	 0000h	 
??006F . . . . . . . . . . . . .	Text   	 <bx, ax>
??0070 . . . . . . . . . . . . .	Number	 0004h	 
??0075 . . . . . . . . . . . . .	Text   	 , 
??0076 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0078 . . . . . . . . . . . . .	Number	 0000h	 
??0079 . . . . . . . . . . . . .	Text   	 <bx, ax>
??007A . . . . . . . . . . . . .	Number	 0004h	 
??007F . . . . . . . . . . . . .	Text   	 , 
??0080 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0082 . . . . . . . . . . . . .	Number	 0000h	 
??0083 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0085 . . . . . . . . . . . . .	Text   	 , 
??0086 . . . . . . . . . . . . .	Text   	 <ax>
??0088 . . . . . . . . . . . . .	Number	 0000h	 
??0089 . . . . . . . . . . . . .	Text   	 <ax>
??008B . . . . . . . . . . . . .	Text   	 , 
??008C . . . . . . . . . . . . .	Text   	 <ax>
??008E . . . . . . . . . . . . .	Number	 0000h	 
??008F . . . . . . . . . . . . .	Text   	 <ax>
??0091 . . . . . . . . . . . . .	Text   	 , 
??0092 . . . . . . . . . . . . .	Text   	 <ax>
??0094 . . . . . . . . . . . . .	Number	 0000h	 
??0095 . . . . . . . . . . . . .	Text   	 <ax>
??0097 . . . . . . . . . . . . .	Text   	 , 
??0098 . . . . . . . . . . . . .	Text   	 <ax>
??009A . . . . . . . . . . . . .	Number	 0000h	 
??009B . . . . . . . . . . . . .	Text   	 <ax>
??009D . . . . . . . . . . . . .	Text   	 , 
??009E . . . . . . . . . . . . .	Text   	 <ax>
??00A0 . . . . . . . . . . . . .	Number	 0000h	 
??00A1 . . . . . . . . . . . . .	Text   	 <ax>
??00A3 . . . . . . . . . . . . .	Text   	 , 
??00A4 . . . . . . . . . . . . .	Text   	 <ax>
??00A6 . . . . . . . . . . . . .	Number	 0000h	 
??00A7 . . . . . . . . . . . . .	Text   	 <ax>
??00A9 . . . . . . . . . . . . .	Text   	 , 
??00AA . . . . . . . . . . . . .	Text   	 <ax>
??00AC . . . . . . . . . . . . .	Number	 0000h	 
??00AD . . . . . . . . . . . . .	Text   	 <ax>
??00AF . . . . . . . . . . . . .	Text   	 , 
??00B0 . . . . . . . . . . . . .	Text   	 <ax>
??00B2 . . . . . . . . . . . . .	Number	 0000h	 
??00B3 . . . . . . . . . . . . .	Text   	 <ax>
??00B5 . . . . . . . . . . . . .	Text   	 , 
??00B6 . . . . . . . . . . . . .	Text   	 <ax>
??00B8 . . . . . . . . . . . . .	Number	 0000h	 
??00B9 . . . . . . . . . . . . .	Text   	 <ax>
??00BB . . . . . . . . . . . . .	Text   	 , 
??00BC . . . . . . . . . . . . .	Text   	 <ax>
??00BE . . . . . . . . . . . . .	Number	 0000h	 
??00BF . . . . . . . . . . . . .	Text   	 <ax>
??00C1 . . . . . . . . . . . . .	Text   	 , 
??00C2 . . . . . . . . . . . . .	Text   	 <ax>
??00C4 . . . . . . . . . . . . .	Number	 0000h	 
??00C5 . . . . . . . . . . . . .	Text   	 <ax>
??00C7 . . . . . . . . . . . . .	Text   	 , 
??00C8 . . . . . . . . . . . . .	Text   	 <ax>
??00CA . . . . . . . . . . . . .	Number	 0000h	 
??00CB . . . . . . . . . . . . .	Text   	 <ax>
??00CD . . . . . . . . . . . . .	Text   	 , 
??00CE . . . . . . . . . . . . .	Text   	 <ax>
??00D0 . . . . . . . . . . . . .	Number	 0000h	 
??00D1 . . . . . . . . . . . . .	Text   	 <ax>
??00D3 . . . . . . . . . . . . .	Text   	 , 
??00D4 . . . . . . . . . . . . .	Text   	 <ax>
??00D6 . . . . . . . . . . . . .	Number	 0000h	 
??00D7 . . . . . . . . . . . . .	Text   	 <ax>
??00D9 . . . . . . . . . . . . .	Text   	 , 
??00DA . . . . . . . . . . . . .	Text   	 <ax>
??00DC . . . . . . . . . . . . .	Number	 0000h	 
??00DD . . . . . . . . . . . . .	Text   	 <ax>
??00DF . . . . . . . . . . . . .	Text   	 , 
??00E0 . . . . . . . . . . . . .	Text   	 <ax>
??00E2 . . . . . . . . . . . . .	Number	 0000h	 
??00E3 . . . . . . . . . . . . .	Text   	 <ax>
??00E5 . . . . . . . . . . . . .	Text   	 , 
??00E6 . . . . . . . . . . . . .	Text   	 <ax>
??00E8 . . . . . . . . . . . . .	Number	 0000h	 
??00E9 . . . . . . . . . . . . .	Text   	 <ax>
??00EB . . . . . . . . . . . . .	Text   	 , 
??00EC . . . . . . . . . . . . .	Text   	 <ax>
??00EE . . . . . . . . . . . . .	Number	 0000h	 
??00EF . . . . . . . . . . . . .	Text   	 <ax>
??00F1 . . . . . . . . . . . . .	Text   	 , 
??00F2 . . . . . . . . . . . . .	Text   	 <ax>
??00F4 . . . . . . . . . . . . .	Number	 0000h	 
??00F5 . . . . . . . . . . . . .	Text   	 <ax>
??00F7 . . . . . . . . . . . . .	Text   	 , 
??00F8 . . . . . . . . . . . . .	Text   	 <ax>
??00FA . . . . . . . . . . . . .	Number	 0000h	 
??00FB . . . . . . . . . . . . .	Text   	 <ax>
??00FD . . . . . . . . . . . . .	Text   	 , 
??00FE . . . . . . . . . . . . .	Text   	 <ax>
??0100 . . . . . . . . . . . . .	Number	 0000h	 
??0101 . . . . . . . . . . . . .	Text   	 <ax>
??0103 . . . . . . . . . . . . .	Text   	 , 
??0104 . . . . . . . . . . . . .	Text   	 <ax>
??0106 . . . . . . . . . . . . .	Number	 0000h	 
??0107 . . . . . . . . . . . . .	Text   	 <ax>
??0109 . . . . . . . . . . . . .	Text   	 , 
??010A . . . . . . . . . . . . .	Text   	 <ax>
??010C . . . . . . . . . . . . .	Number	 0000h	 
??010D . . . . . . . . . . . . .	Text   	 <ax>
??010F . . . . . . . . . . . . .	Text   	 , 
??0110 . . . . . . . . . . . . .	Text   	 <ax>
??0112 . . . . . . . . . . . . .	Number	 0000h	 
??0113 . . . . . . . . . . . . .	Text   	 <ax>
??0115 . . . . . . . . . . . . .	Text   	 , 
??0116 . . . . . . . . . . . . .	Text   	 <ax>
??0118 . . . . . . . . . . . . .	Number	 0000h	 
??0119 . . . . . . . . . . . . .	Text   	 <ax>
??011B . . . . . . . . . . . . .	Text   	 , 
??011C . . . . . . . . . . . . .	Text   	 <ax>
??011E . . . . . . . . . . . . .	Number	 0000h	 
??011F . . . . . . . . . . . . .	Text   	 <ax>
??0121 . . . . . . . . . . . . .	Text   	 , 
??0122 . . . . . . . . . . . . .	Text   	 <ax>
??0124 . . . . . . . . . . . . .	Number	 0000h	 
??0125 . . . . . . . . . . . . .	Text   	 <ax>
??0127 . . . . . . . . . . . . .	Text   	 , 
??0128 . . . . . . . . . . . . .	Text   	 <ax>
??012A . . . . . . . . . . . . .	Number	 0000h	 
??012B . . . . . . . . . . . . .	Text   	 <ax>
??012D . . . . . . . . . . . . .	Text   	 , 
??012E . . . . . . . . . . . . .	Text   	 <ax>
??0130 . . . . . . . . . . . . .	Number	 0000h	 
??0131 . . . . . . . . . . . . .	Text   	 <ax>
??0133 . . . . . . . . . . . . .	Text   	 , 
??0134 . . . . . . . . . . . . .	Text   	 <ax>
??0136 . . . . . . . . . . . . .	Number	 0000h	 
??0137 . . . . . . . . . . . . .	Text   	 <ax>
??0139 . . . . . . . . . . . . .	Text   	 , 
??013A . . . . . . . . . . . . .	Text   	 <ax>
??013C . . . . . . . . . . . . .	Number	 0000h	 
??013D . . . . . . . . . . . . .	Text   	 <ax>
??013F . . . . . . . . . . . . .	Text   	 , 
??0140 . . . . . . . . . . . . .	Text   	 <ax>
??0142 . . . . . . . . . . . . .	Number	 0000h	 
??0143 . . . . . . . . . . . . .	Text   	 <ax>
??0145 . . . . . . . . . . . . .	Text   	 , 
??0146 . . . . . . . . . . . . .	Text   	 <ax>
??0148 . . . . . . . . . . . . .	Number	 0000h	 
??0149 . . . . . . . . . . . . .	Text   	 <ax>
??014B . . . . . . . . . . . . .	Text   	 , 
??014C . . . . . . . . . . . . .	Text   	 <ax>
??014E . . . . . . . . . . . . .	Number	 0000h	 
??014F . . . . . . . . . . . . .	Text   	 <ax>
??0151 . . . . . . . . . . . . .	Text   	 , 
??0152 . . . . . . . . . . . . .	Text   	 <ax>
??0154 . . . . . . . . . . . . .	Number	 0000h	 
??0155 . . . . . . . . . . . . .	Text   	 <ax>
??0157 . . . . . . . . . . . . .	Text   	 , 
??0158 . . . . . . . . . . . . .	Text   	 <ax>
??015A . . . . . . . . . . . . .	Number	 0000h	 
??015B . . . . . . . . . . . . .	Text   	 <ax>
??015D . . . . . . . . . . . . .	Text   	 , 
??015E . . . . . . . . . . . . .	Text   	 <ax>
??0160 . . . . . . . . . . . . .	Number	 0000h	 
??0161 . . . . . . . . . . . . .	Text   	 <ax>
??0163 . . . . . . . . . . . . .	Text   	 , 
??0164 . . . . . . . . . . . . .	Text   	 <ax>
??0166 . . . . . . . . . . . . .	Number	 0000h	 
??0167 . . . . . . . . . . . . .	Text   	 <ax>
??0169 . . . . . . . . . . . . .	Text   	 , 
??016A . . . . . . . . . . . . .	Text   	 <ax>
??016C . . . . . . . . . . . . .	Number	 0000h	 
??016D . . . . . . . . . . . . .	Text   	 <ax>
??016F . . . . . . . . . . . . .	Text   	 , 
??0170 . . . . . . . . . . . . .	Text   	 <ax>
??0172 . . . . . . . . . . . . .	Number	 0000h	 
??0173 . . . . . . . . . . . . .	Text   	 <ax>
??0175 . . . . . . . . . . . . .	Text   	 , 
??0176 . . . . . . . . . . . . .	Text   	 <ax>
??0178 . . . . . . . . . . . . .	Number	 0000h	 
??0179 . . . . . . . . . . . . .	Text   	 <ax>
??017B . . . . . . . . . . . . .	Text   	 , 
??017C . . . . . . . . . . . . .	Text   	 <ax>
??017E . . . . . . . . . . . . .	Number	 0000h	 
??017F . . . . . . . . . . . . .	Text   	 <ax>
??0181 . . . . . . . . . . . . .	Text   	 , 
??0182 . . . . . . . . . . . . .	Text   	 <ax>
??0184 . . . . . . . . . . . . .	Number	 0000h	 
??0185 . . . . . . . . . . . . .	Text   	 <ax>
??0187 . . . . . . . . . . . . .	Text   	 , 
??0188 . . . . . . . . . . . . .	Text   	 <ax>
??018A . . . . . . . . . . . . .	Number	 0000h	 
??018B . . . . . . . . . . . . .	Text   	 <ax>
??018D . . . . . . . . . . . . .	Text   	 , 
??018E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0190 . . . . . . . . . . . . .	Number	 0000h	 
??0191 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0193 . . . . . . . . . . . . .	Text   	 , 
??0194 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0196 . . . . . . . . . . . . .	Number	 0000h	 
??0197 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0199 . . . . . . . . . . . . .	Text   	 , 
??019A . . . . . . . . . . . . .	Text   	 <dx, ax>
??019C . . . . . . . . . . . . .	Number	 0000h	 
??019D . . . . . . . . . . . . .	Text   	 <dx, ax>
??019F . . . . . . . . . . . . .	Text   	 , 
??01A0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A2 . . . . . . . . . . . . .	Number	 0000h	 
??01A3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A5 . . . . . . . . . . . . .	Text   	 , 
??01A6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A8 . . . . . . . . . . . . .	Number	 0000h	 
??01A9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AB . . . . . . . . . . . . .	Text   	 , 
??01AC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AE . . . . . . . . . . . . .	Number	 0000h	 
??01AF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B1 . . . . . . . . . . . . .	Text   	 , 
??01B2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B4 . . . . . . . . . . . . .	Number	 0000h	 
??01B5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B7 . . . . . . . . . . . . .	Text   	 , 
??01B8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BA . . . . . . . . . . . . .	Number	 0000h	 
??01BB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BD . . . . . . . . . . . . .	Text   	 , 
??01BE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C0 . . . . . . . . . . . . .	Number	 0000h	 
??01C1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C3 . . . . . . . . . . . . .	Text   	 , 
??01C4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C6 . . . . . . . . . . . . .	Number	 0000h	 
??01C7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C9 . . . . . . . . . . . . .	Text   	 , 
??01CA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CC . . . . . . . . . . . . .	Number	 0000h	 
??01CD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CF . . . . . . . . . . . . .	Text   	 , 
??01D0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D2 . . . . . . . . . . . . .	Number	 0000h	 
??01D3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D5 . . . . . . . . . . . . .	Text   	 , 
??01D6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D8 . . . . . . . . . . . . .	Number	 0000h	 
??01D9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DB . . . . . . . . . . . . .	Text   	 , 
??01DC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DE . . . . . . . . . . . . .	Number	 0000h	 
??01DF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E1 . . . . . . . . . . . . .	Text   	 , 
??01E2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E4 . . . . . . . . . . . . .	Number	 0000h	 
??01E5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E7 . . . . . . . . . . . . .	Text   	 , 
??01E8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01EA . . . . . . . . . . . . .	Number	 0000h	 
??01EB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01ED . . . . . . . . . . . . .	Text   	 , 
??01EE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F0 . . . . . . . . . . . . .	Number	 0000h	 
??01F1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F3 . . . . . . . . . . . . .	Text   	 , 
??01F4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F6 . . . . . . . . . . . . .	Number	 0000h	 
??01F7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F9 . . . . . . . . . . . . .	Text   	 , 
??01FA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FC . . . . . . . . . . . . .	Number	 0000h	 
??01FD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FF . . . . . . . . . . . . .	Text   	 , 
??0200 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0202 . . . . . . . . . . . . .	Number	 0000h	 
??0203 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0205 . . . . . . . . . . . . .	Text   	 , 
??0206 . . . . . . . . . . . . .	Text   	 <ax>
??0208 . . . . . . . . . . . . .	Number	 0000h	 
??0209 . . . . . . . . . . . . .	Text   	 <ax>
??020B . . . . . . . . . . . . .	Text   	 , 
??020C . . . . . . . . . . . . .	Text   	 <ax>
??020E . . . . . . . . . . . . .	Number	 0000h	 
??020F . . . . . . . . . . . . .	Text   	 <ax>
??0211 . . . . . . . . . . . . .	Text   	 , 
??0212 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0214 . . . . . . . . . . . . .	Number	 0000h	 
??0215 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0217 . . . . . . . . . . . . .	Text   	 , 
??0218 . . . . . . . . . . . . .	Text   	 <dx, ax>
??021A . . . . . . . . . . . . .	Number	 0000h	 
??021B . . . . . . . . . . . . .	Text   	 <dx, ax>
??021D . . . . . . . . . . . . .	Text   	 , 
??021E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0220 . . . . . . . . . . . . .	Number	 0000h	 
??0221 . . . . . . . . . . . . .	Text   	 <dx, ax>
@@nao_foi_possivel_abrir_ou_criar_o_arquivo  Byte     035E     _DATA	
@@parametros_nao_reconhecidos_ao_final_do_comando  Byte	    0388     _DATA	
@@parametro  . . . . . . . . . .	Byte	 032E	  _DATA	
@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@Comando . . . . . . . . . . . .	Byte	 0310	  _DATA	
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0003h	 
@MainLoopEnd . . . . . . . . . .	L Near	 007B	  _TEXT	
@Model . . . . . . . . . . . . .	Number	 0002h	 
@SkipPrint . . . . . . . . . . .	L Near	 001D	  _TEXT	
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@ValidCommand  . . . . . . . . .	L Near	 004A	  _TEXT	
@Validate  . . . . . . . . . . .	L Near	 0020	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@como  . . . . . . . . . . . . .	Byte	 031F	  _DATA	
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@desconhecido  . . . . . . . . .	Byte	 0338	  _DATA	
@deve_estar_entre_1_e_N  . . . .	Byte	 0347	  _DATA	
@espera  . . . . . . . . . . . .	Byte	 0318	  _DATA	
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@parametro . . . . . . . . . . .	Byte	 0324	  _DATA	
@space . . . . . . . . . . . . .	Byte	 0345	  _DATA	
@stack . . . . . . . . . . . . .	Text   	 DGROUP
@whiletrue . . . . . . . . . . .	L Near	 001A	  _TEXT	
BuffSize . . . . . . . . . . . .	Number	 0064h	 
CLOSE_DELIMITER  . . . . . . . .	Text   	 >
CMD_ADD  . . . . . . . . . . . .	Number	 0003h	 
CMD_DIV  . . . . . . . . . . . .	Number	 0002h	 
CMD_MUL  . . . . . . . . . . . .	Number	 0001h	 
CMD_NONE . . . . . . . . . . . .	Number	 0000h	 
CMD_SUB  . . . . . . . . . . . .	Number	 0004h	 
CMD_UNDO . . . . . . . . . . . .	Number	 0005h	 
CMD_WRITE  . . . . . . . . . . .	Number	 0006h	 
COLON_SPACE  . . . . . . . . . .	Byte	 03B8	  _DATA	
COLUMN_SEP . . . . . . . . . . .	Byte	 0000	  _DATA	
COL_SEPARATOR  . . . . . . . . .	Text   	 SEMI
CRLF . . . . . . . . . . . . . .	Byte	 0002	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
Col  . . . . . . . . . . . . . .	Byte	 03C4	  _DATA	
CommandBufferLength  . . . . . .	Byte	 010C	  _DATA	
CommandBufferString  . . . . . .	Byte	 010D	  _DATA	
CommandBuffer  . . . . . . . . .	Byte	 010B	  _DATA	
ErrorColumnCount . . . . . . . .	L Near	 0D03	  _TEXT	
ErrorInvalidCommand  . . . . . .	L Near	 11A4	  _TEXT	
ErrorInvalidN  . . . . . . . . .	L Near	 10AA	  _TEXT	
ErrorOpen  . . . . . . . . . . .	L Near	 0C15	  _TEXT	
ErrorRead  . . . . . . . . . . .	L Near	 0C8E	  _TEXT	
ErrorRowCount  . . . . . . . . .	L Near	 0E3C	  _TEXT	
ErrorUnexpectedChar  . . . . . .	L Near	 0FF1	  _TEXT	
ExplanationSeparator . . . . . .	Text   	 COLON_SPACE
FileBuffer . . . . . . . . . . .	Byte	 000D	  _DATA	
FileCol  . . . . . . . . . . . .	Word	 03BF	  _DATA	
FileHandle . . . . . . . . . . .	Word	 0071	  _DATA	
FileIsOpen . . . . . . . . . . .	Byte	 0073	  _DATA	
FileLine . . . . . . . . . . . .	Word	 03C1	  _DATA	
FileNameBuffer . . . . . . . . .	Byte	 0074	  _DATA	
FileName . . . . . . . . . . . .	Byte	 0005	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LastCommand@a  . . . . . . . . .	Word	 020C	  _DATA	
LastCommand@b  . . . . . . . . .	Word	 020E	  _DATA	
LastCommand@exists . . . . . . .	Byte	 0210	  _DATA	
LastCommand  . . . . . . . . . .	Byte	 020B	  _DATA	
Matrix . . . . . . . . . . . . .	Word	 03C9	  _DATA	
NPlusOne . . . . . . . . . . . .	Byte	 03C8	  _DATA	
NonTerminalErrorBuffer . . . . .	Byte	 0211	  _DATA	
N  . . . . . . . . . . . . . . .	Byte	 03C7	  _DATA	
OPEN_DELIMITER . . . . . . . . .	Text   	 <
PeekBuffer . . . . . . . . . . .	Byte	 03BB	  _DATA	
QUOT . . . . . . . . . . . . . .	Number	 0022h	 
REG_SET_DELIMITER  . . . . . . .	Text   	 |
RegsInvokeUses . . . . . . . . .	Text   	 ax bx cx dx bp
RegsReturningOnAX  . . . . . . .	Text   	 bx cx dx bp
RegsReturningOnBX  . . . . . . .	Text   	 ax cx dx bp
Row  . . . . . . . . . . . . . .	Byte	 03C3	  _DATA	
SEMI . . . . . . . . . . . . . .	Number	 003Bh	 
SPACE  . . . . . . . . . . . . .	Number	 0020h	 
TheUnexpectedChar  . . . . . . .	Byte	 03BC	  _DATA	
TotalCol . . . . . . . . . . . .	Byte	 03C6	  _DATA	
TotalRow . . . . . . . . . . . .	Byte	 03C5	  _DATA	
caractere  . . . . . . . . . . .	Byte	 010A	  _DATA	
regStack . . . . . . . . . . . .	Text   	 
size_s . . . . . . . . . . . . .	Number	 0000h	 

	   0 Warnings
	   0 Errors
