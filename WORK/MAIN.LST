Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:29:17
							     First Pass 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					WRITEMatrix proto near, NOME:ptr byte
					PrintMatrix proto near
				;====================================================================
				; Memory
						.stack
 0000						.data
					
					CMD_NONE  EQU 0
					CMD_MUL   EQU 1
					CMD_DIV   EQU 2
					CMD_ADD   EQU 3
					CMD_SUB   EQU 4
					CMD_UNDO  EQU 5
					CMD_WRITE EQU 6
					CR            equ 0dh
					LF            equ 0ah
					QUOT          equ 22h
					SEMI          equ 3Bh
					COL_SEPARATOR equ SEMI
					SPACE         equ 20h
					COLUMN_SEP db ";",0
					CRLF       db CR, LF, 0
					BuffSize       equ 100              ; tam. m√°ximo dos dados lidos no buffer
					FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
					FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
					FileHandle     dw  0                ; Handler do arquivo
					FileIsOpen     db  0                ; closed at the start
					FileNameBuffer db  150 dup (?)
					caractere      db  0
					CommandBuffer       db 254
					CommandBufferLength db 0          ; max length, actual length
					CommandBufferString db 254 dup(0)
					LastCommand   db 0
					LastCommand@a dw 0
					LastCommand@b sword 0
					LastCommand@exists db 0
					NonTerminalErrorBuffer db 255 dup(0)
					@Comando      db "Comando",0
					@espera       db "espera",0
					@como         db "como",0
					@parametro    db "parametro",0
					@@parametro   db "Parametro",0
					@desconhecido db "desconhecido",0
					@space        db " ",0
					@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
					@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
					@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
					
					COLON_SPACE db ": ",0
					ExplanationSeparator textequ <COLON_SPACE>
					; Used on PeekChar
					PeekBuffer        db ?
					; Used when reporting the error
					TheUnexpectedChar db 0,QUOT,0
					; used in main
					FileCol           dw 1
					FileLine          dw 1
					Row      byte 0
					Col      byte 0
					TotalRow byte 0
					TotalCol byte 0
					N        byte 0
					NPlusOne byte 0
					; should be at most 7x7
					Matrix   sword (7 * 7) dup (?)
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
					OPEN_DELIMITER    textequ <!<>
					CLOSE_DELIMITER   textequ <!>>
					REG_SET_DELIMITER textequ <|>
					regStack textequ <> ; starts empty
					__popRegs macro
						regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else
							regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif
						exitm regs
					endm
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else
							regStack catstr regs, REG_SET_DELIMITER, regStack
						endif
					endm
					SaveRegs macro regs:vararg
						comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
					RestoreRegs macro
					%	for reg, __popRegs(regStack) 
							pop reg
						endm
					endm
					RegsInvokeUses textequ <ax bx cx dx bp>
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
						SaveRegs ax, dx
						mov      ah, 02h
						mov      dl, c
						int      21h
						RestoreRegs
					endm
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h
						forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0
					endm
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif
						ifdifi <dst>, <di>
							lea di, dst
						endif
						.repeat
							mov al,   [si]
							mov [di], al
							inc si
							inc di
						.until (al == 0)
						dec    si
						dec    di
						RestoreRegs
					endm
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> 
						ELSE
							EXITM <0> 
						ENDIF
					ENDM
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif
						for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				;--------------------------------------------------------------------
				; Miscellaneous
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
					endm
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
					endm
					CloseFileHandle macro
						mov ah, 3eh
						mov bx, FileHandle
						int 21h
						
						mov FileIsOpen, 0 ; 0 means it is now closed
					endm
					CurrentIndexToBx macro
						; returns in bx
						SaveRegs ax
						mov      al, TotalCol
						inc      al           ; TotalCol starts at 0
						mov bl, Row
						mov bh, Col
						mul bl
						add al, bh
						; got index, find position in array
						shl ax, 1
						add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				;====================================================================
				; Program
 0000					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
			     1			SaveRegs ax, dx
			     2			??0001     textequ <>
			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0002 catstr <ax>, ??0001, ??0002
			     3				??0001 catstr <, >
			     3				push  dx
			     3				??0002 catstr <dx>, ??0001, ??0002
			     3				??0001 catstr <, >
			     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
			     3				??0005     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)      
			     3				regStack substr regStack, (??0004 + 1)     
			     3			endif
			     3			exitm ??0005
			     2		for ??0003, <dx, ax> 
			     2				pop ??0003
			     2			endm
			     3				pop dx
			     3				pop ax
							putc   LF
			     1			SaveRegs ax, dx
			     2			??0007     textequ <>
			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0008 catstr <ax>, ??0007, ??0008
			     3				??0007 catstr <, >
			     3				push  dx
			     3				??0008 catstr <dx>, ??0007, ??0008
			     3				??0007 catstr <, >
			     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
			     3				??000B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)      
			     3				regStack substr regStack, (??000A + 1)     
			     3			endif
			     3			exitm ??000B
			     2		for ??0009, <dx, ax> 
			     2				pop ??0009
			     2			endm
			     3				pop dx
			     3				pop ax
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
						.if (ax == CMD_ADD)
							call Main@ADD
						.elseif  (ax == CMD_MUL)
							call Main@MUL
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							jmp  @SkipPrint
						.endif
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
			     1			SaveRegs ax, dx
			     2			??000D     textequ <>
			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
			     3				push  ax
			     3				??000E catstr <ax>, ??000D, ??000E
			     3				??000D catstr <, >
			     3				push  dx
			     3				??000E catstr <dx>, ??000D, ??000E
			     3				??000D catstr <, >
			     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
			     3				??0011     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)      
			     3				regStack substr regStack, (??0010 + 1)     
			     3			endif
			     3			exitm ??0011
			     2		for ??000F, <dx, ax> 
			     2				pop ??000F
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??0013     textequ <>
			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0014 catstr <ax>, ??0013, ??0014
			     3				??0013 catstr <, >
			     3				push  dx
			     3				??0014 catstr <dx>, ??0013, ??0014
			     3				??0013 catstr <, >
			     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
			     3				??0017     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)      
			     3				regStack substr regStack, (??0016 + 1)     
			     3			endif
			     3			exitm ??0017
			     2		for ??0015, <dx, ax> 
			     2				pop ??0015
			     2			endm
			     3				pop dx
			     3				pop ax
					jmp @whiletrue
 0135					Main@ADD proc near
						mov LastCommand,        CMD_ADD
						mov bh,                 0
						mov LastCommand@a,      bx
						mov ch,                 0
						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
						invoke ADDMatrix, bl, cl
						ret
 015C					Main@ADD endp
 015C					Main@MUL proc near
						mov LastCommand,        CMD_MUL
						mov bh,                 0
						mov LastCommand@a,      bx
						mov LastCommand@b,      sword ptr cx
						mov LastCommand@exists, 1
						invoke MULMatrix, bl, cx
						ret
 017F					Main@MUL endp
 017F					Main@UNDO proc near
						mov al, LastCommand@exists
						.if !al
							jmp @MainLoopEnd
						.endif
						mov al,           LastCommand
						mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
						.if (al == CMD_ADD)
							invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
						.elseif (al == CMD_MUL)
							invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
							mov LastCommand, CMD_ADD
						.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
							mov LastCommand, CMD_MUL
						.endif
						ret
 026D					Main@UNDO  endp
 026D					Main@WRITE proc near
						invoke WRITEMatrix, dx
						ret
 0279					Main@WRITE endp
				;====================================================================
				; MUL
 0279					MULMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						MULMatrix@Loop:
							mov  ax,             sword ptr [bx]
							imul CONSTANTE
							mov  sword ptr [bx], ax
							add  bx, 2
							loop MULMatrix@Loop
						ret
 02B0					MULMatrix endp
 02B0					DIVMatrix proc near uses ax bx cx dx bp, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						mov bx, offset Matrix
						add bx, ax
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
							mov ax, sword ptr [bx]
							cwd                    ; extend sign to dx
							
							idiv CONSTANTE
							
							mov sword ptr [bx], ax
							add  bx, 2
							loop DIVMatrix@Loop
						ret
 02E8					DIVMatrix endp
				;====================================================================
				; ADD
 02E8					ADDMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						ADDMatrix@Loop:
							mov ax,   [di]
							add ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop ADDMatrix@Loop
						ret
 033B					ADDMatrix endp
 033B					SUBMatrix proc near uses ax bx cx dx bp di si, LINHA_DST:byte, LINHA_ORG: byte
						mov al, LINHA_DST
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						
						lea di, Matrix
						add di, ax
						mov al, LINHA_ORG
						dec al
						mov bl, TotalCol
						inc bl
						mul bl
						shl ax, 1
						lea si, Matrix
						add si, ax
						mov ch, 0
						mov cl, NPlusOne
						SUBMatrix@Loop:
							mov ax,   [di]
							sub ax,   [si]
							mov [di], ax
							add  di, 2
							add  si, 2
							loop SUBMatrix@Loop
						ret
 038E					SUBMatrix endp
				;====================================================================
				; WRITE
					WriteToFile macro handle:req, offset_buf:req, len:req
						SaveRegs bx, cx, dx
						mov cx, len
						mov bx, handle
						lea dx, offset_buf
						mov ah, 40h
						int 21h
						RestoreRegs
					endm
 038E					WRITEMatrix proc near uses ax bx cx dx bp di si, NOME:ptr byte
						local buf[7]:byte, handle:word
						mov   ah,          3Dh         ; open
						mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
						jc    create_file              ; if not exists
						mov bx, ax      ; BX = file handle
						jmp file_opened
						create_file:
						mov ah, 3Ch  ; create
						mov cx, 0
						mov dx, NOME
						int 21h
						mov bx, ax
						file_opened:
						mov ah, 42h
						mov al, 02h ; SEEK_END
						xor cx, cx
						xor dx, dx
						int 21h
						.if (carry?)
							ErrorCantOpenNorCreate
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     4			SaveRegs ax
			     5			??0019     textequ <>
			     5			??001A textequ <>
			     5			for       ??0018, <ax>
			     5				push  ??0018
			     5				??001A catstr <??0018>, ??0019, ??001A
			     5				??0019 catstr <, >
			     5			endm
			     6				push  ax
			     6				??001A catstr <ax>, ??0019, ??001A
			     6				??0019 catstr <, >
			     5			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
			     5			__pushRegs ??001A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??001A
			     6			else
			     6				regStack catstr ??001A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>_po
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??001C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??001C eq 0
			     6				??001D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??001D substr regStack, 1, (??001C - 1)R, reg
			     6				regStack substr regStack, (??001C + 1)R, re
			     6			endif
			     6			exitm ??001D
			     5		for ??001B, <ax> 
			     5				pop ??001B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??001F     textequ <>
			     5			??0020 textequ <>
			     5			for       ??001E, <ax>
			     5				push  ??001E
			     5				??0020 catstr <??001E>, ??001F, ??0020
			     5				??001F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0020 catstr <ax>, ??001F, ??0020
			     6				??001F catstr <, >
			     5			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
			     5			__pushRegs ??0020
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0020
			     6			else
			     6				regStack catstr ??0020, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0022 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0022 eq 0
			     6				??0023     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0023 substr regStack, 1, (??0022 - 1)      
			     6				regStack substr regStack, (??0022 + 1)     
			     6			endif
			     6			exitm ??0023
			     5		for ??0021, <ax> 
			     5				pop ??0021
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, diu_cria
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0026 catstr <ax>, ??0025, ??0026
			     6				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
			     5			__pushRegs ??0026
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0028 eq 0
			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)      
			     6				regStack substr regStack, (??0028 + 1)     
			     6			endif
			     6			exitm ??0029
			     5		for ??0027, <ax> 
			     5				pop ??0027
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, diu_cri
			     3				endif
							stc
							ret
						.endif
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
								jge WRITEMatrix@EndForCol
								.if (bl) ; no longer firstCol?
									WriteToFile handle, COLUMN_SEP, 1
			     1			SaveRegs bx, cx, dx
			     2			??002B     textequ <>
			     2			??002C textequ <>
			     2			for       ??002A, <bx,cx,dx>
			     2				push  ??002A
			     2				??002C catstr <??002A>, ??002B, ??002C
			     2				??002B catstr <, >
			     2			endm
			     3				push  bx
			     3				??002C catstr <bx>, ??002B, ??002C
			     3				??002B catstr <, >
			     3				push  cx
			     3				??002C catstr <cx>, ??002B, ??002C
			     3				??002B catstr <, >
			     3				push  dx
			     3				??002C catstr <dx>, ??002B, ??002C
			     3				??002B catstr <, >
			     2			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
			     2			__pushRegs ??002C
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??002C
			     3			else
			     3				regStack catstr ??002C, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 1
			     1			mov bx, handle
			     1			lea dx, COLUMN_SEP
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??002E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??002E eq 0
			     3				??002F     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??002F substr regStack, 1, (??002E - 1)      
			     3				regStack substr regStack, (??002E + 1)     
			     3			endif
			     3			exitm ??002F
			     2		for ??002D, <dx, cx, bx> 
			     2				pop ??002D
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								.endif
								mov ax, sword ptr [di]
								invoke string_from_sword, addr buf, ax ; ax now has length
								WriteToFile handle, buf, ax
			     1			SaveRegs bx, cx, dx
			     2			??0031     textequ <>
			     2			??0032 textequ <>
			     2			for       ??0030, <bx,cx,dx>
			     2				push  ??0030
			     2				??0032 catstr <??0030>, ??0031, ??0032
			     2				??0031 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0032 catstr <bx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     3				push  cx
			     3				??0032 catstr <cx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     3				push  dx
			     3				??0032 catstr <dx>, ??0031, ??0032
			     3				??0031 catstr <, >
			     2			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
			     2			__pushRegs ??0032
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0032
			     3			else
			     3				regStack catstr ??0032, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, ax
			     1			mov bx, handle
			     1			lea dx, buf
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??0034 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0034 eq 0
			     3				??0035     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0035 substr regStack, 1, (??0034 - 1)      
			     3				regStack substr regStack, (??0034 + 1)     
			     3			endif
			     3			exitm ??0035
			     2		for ??0033, <dx, cx, bx> 
			     2				pop ??0033
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
								add di, 2 ; size in bytes of a sword
								mov bl, 1 ; no longer first col
								inc cl    ; col ++
								
								jmp WRITEMatrix@ForCol
							WRITEMatrix@EndForCol:
							WriteToFile handle, CRLF, 2
			     1			SaveRegs bx, cx, dx
			     2			??0037     textequ <>
			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
			     3				push  bx
			     3				??0038 catstr <bx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  cx
			     3				??0038 catstr <cx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     3				push  dx
			     3				??0038 catstr <dx>, ??0037, ??0038
			     3				??0037 catstr <, >
			     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack      
			     3			endif
			     1	
			     1			mov cx, 2
			     1			mov bx, handle
			     1			lea dx, CRLF
			     1			mov ah, 40h
			     1			int 21h
			     1			RestoreRegs
			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
			     3				??003B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)      
			     3				regStack substr regStack, (??003A + 1)     
			     3			endif
			     3			exitm ??003B
			     2		for ??0039, <dx, cx, bx> 
			     2				pop ??0039
			     2			endm
			     3				pop dx
			     3				pop cx
			     3				pop bx
							inc ch ; row++
							
							jmp WRITEMatrix@ForRow
						WRITEMatrix@EndForRow:
						clc
						ret
 04FD					WRITEMatrix endp
				;====================================================================
				; Exiting
 04FD					ExitSuccess proc near
						mov al, 0
						jmp ExitAndClose
						ret
 050A					ExitSuccess endp
 050A					ExitFailure proc near
						mov al, 1
						jmp ExitAndClose
						ret
 0517					ExitFailure endp
 0517					ExitAndClose proc near
						.if (FileIsOpen)
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						.endif
						.exit
						ret
 053F					ExitAndClose endp
				;====================================================================
				; Reading input
 053F					ReadCommand proc near uses si
						mov dx, offset CommandBuffer
						mov ah, 0Ah
						int 21h
						mov si, offset CommandBufferString
						mov bh, 0
						mov bl, CommandBufferLength
						
						mov byte ptr [CommandBufferString+bx], 0
						putc CR
			     1			SaveRegs ax, dx
			     2			??003D     textequ <>
			     2			??003E textequ <>
			     2			for       ??003C, <ax,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
			     3				push  ax
			     3				??003E catstr <ax>, ??003D, ??003E
			     3				??003D catstr <, >
			     3				push  dx
			     3				??003E catstr <dx>, ??003D, ??003E
			     3				??003D catstr <, >
			     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
			     3				??0041     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)      
			     3				regStack substr regStack, (??0040 + 1)     
			     3			endif
			     3			exitm ??0041
			     2		for ??003F, <dx, ax> 
			     2				pop ??003F
			     2			endm
			     3				pop dx
			     3				pop ax
						putc LF
			     1			SaveRegs ax, dx
			     2			??0043     textequ <>
			     2			??0044 textequ <>
			     2			for       ??0042, <ax,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0044 catstr <ax>, ??0043, ??0044
			     3				??0043 catstr <, >
			     3				push  dx
			     3				??0044 catstr <dx>, ??0043, ??0044
			     3				??0043 catstr <, >
			     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
			     3				??0047     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)      
			     3				regStack substr regStack, (??0046 + 1)     
			     3			endif
			     3			exitm ??0047
			     2		for ??0045, <dx, ax> 
			     2				pop ??0045
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke ParseCommand
						ret
 0575					ReadCommand endp
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
						SaveRegs ax, bx
						i = 0
						
						mov bx, memString
						
						forc char, <constStr>
							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
							cmp al, '&char'
							jne @@ne
							i = i + 1
						endm 
						mov ax, 1
						jmp @@done
						@@ne:
							mov ax, 0
						@@done:
							cmp ax, 0
							RestoreRegs
					endm
					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw
					endm
					; Return the value read in result, and the end of the string read in si
 0575					ReadNumFromString proc near uses ax bx cx dx bp, string:ptr byte, result:ptr sword
						mov ax, 0
						mov bx, 0
						mov si, string
						mov cx, 0
						.if byte ptr [si] == '-'
							inc si
							mov cx, 1
						.endif
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
							mov dx, 10
							mul dx
							mov bl, [si]
							sub bl, '0'
							add ax, bx
							inc si
						.endw
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
						.if (cx)
							neg ax
						.endif
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
 0633					ReadNumFromString endp
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)
							stc
						.else
							mov resultReg, numberInMemory
							clc
						.endif
					endm
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
						
						.if (!zero?)
							add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif
					endm
					;   AX = command ID (CMD_*)
					;   BX = param1 (if any)
					;   CX = param2 (if any)
					;   DX = offset of string (WRITE)
 0633					ParseCommand proc near uses si di bp
						local a:sword
						mov si, offset CommandBufferString
						
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
			     1			StartsWith <MUL> si
			     2			SaveRegs ax, bx
			     3			??004D     textequ <>
			     3			??004E textequ <>
			     3			for       ??004C, <ax,bx>
			     3				push  ??004C
			     3				??004E catstr <??004C>, ??004D, ??004E
			     3				??004D catstr <, >
			     3			endm
			     4				push  ax
			     4				??004E catstr <ax>, ??004D, ??004E
			     4				??004D catstr <, >
			     4				push  bx
			     4				??004E catstr <bx>, ??004D, ??004E
			     4				??004D catstr <, >
			     3			??004E catstr OPEN_DELIMITER, ??004E, CLOSE_DELIMITER
			     3			__pushRegs ??004E
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??004E
			     4			else
			     4				regStack catstr ??004E, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0048 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0048]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??004A
			     2				??0048 = ??0048 + 1
			     2			endm 
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'M'
			     3				jne ??004A
			     3	
 = 0001			     3				??0048 = ??0048 + 1
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??004A
			     3	
 = 0002			     3				??0048 = ??0048 + 1
			     3				mov al, [bx+??0048]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'L'
			     3				jne ??004A
			     3	
 = 0003			     3				??0048 = ??0048 + 1
			     2			mov ax, 1
			     2			jmp ??004B
			     2			??004A:
			     2				mov ax, 0
			     2			??004B:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0050 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0050 eq 0
			     4				??0051     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0051 substr regStack, 1, (??0050 - 1)      
			     4				regStack substr regStack, (??0050 + 1)     
			     4			endif
			     4			exitm ??0051
			     3		for ??004F, <bx, ax> 
			     3				pop ??004F
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@MUL
			     1			.endif
						jumpIfSIComparesTo <ADD> ParseCommand@ADD
			     1			StartsWith <ADD> si
			     2			SaveRegs ax, bx
			     3			??0057     textequ <>
			     3			??0058 textequ <>
			     3			for       ??0056, <ax,bx>
			     3				push  ??0056
			     3				??0058 catstr <??0056>, ??0057, ??0058
			     3				??0057 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0058 catstr <ax>, ??0057, ??0058
			     4				??0057 catstr <, >
			     4				push  bx
			     4				??0058 catstr <bx>, ??0057, ??0058
			     4				??0057 catstr <, >
			     3			??0058 catstr OPEN_DELIMITER, ??0058, CLOSE_DELIMITER
			     3			__pushRegs ??0058
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0058
			     4			else
			     4				regStack catstr ??0058, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0052 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??0052]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0054
			     2				??0052 = ??0052 + 1
			     2			endm 
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'A'
			     3				jne ??0054
			     3	
 = 0001			     3				??0052 = ??0052 + 1
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0054
			     3	
 = 0002			     3				??0052 = ??0052 + 1
			     3				mov al, [bx+??0052]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??0054
			     3	
 = 0003			     3				??0052 = ??0052 + 1
			     2			mov ax, 1
			     2			jmp ??0055
			     2			??0054:
			     2				mov ax, 0
			     2			??0055:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??005A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005A eq 0
			     4				??005B     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??005B substr regStack, 1, (??005A - 1)      
			     4				regStack substr regStack, (??005A + 1)     
			     4			endif
			     4			exitm ??005B
			     3		for ??0059, <bx, ax> 
			     3				pop ??0059
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 03
			     1				jmp ParseCommand@ADD
			     1			.endif
						jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
			     1			StartsWith <UNDO> si
			     2			SaveRegs ax, bx
			     3			??0061     textequ <>
			     3			??0062 textequ <>
			     3			for       ??0060, <ax,bx>
			     3				push  ??0060
			     3				??0062 catstr <??0060>, ??0061, ??0062
			     3				??0061 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0062 catstr <ax>, ??0061, ??0062
			     4				??0061 catstr <, >
			     4				push  bx
			     4				??0062 catstr <bx>, ??0061, ??0062
			     4				??0061 catstr <, >
			     3			??0062 catstr OPEN_DELIMITER, ??0062, CLOSE_DELIMITER
			     3			__pushRegs ??0062
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0062
			     4			else
			     4				regStack catstr ??0062, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??005C = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??005C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??005E
			     2				??005C = ??005C + 1
			     2			endm 
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??005E
			     3	
 = 0001			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'N'
			     3				jne ??005E
			     3	
 = 0002			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'D'
			     3				jne ??005E
			     3	
 = 0003			     3				??005C = ??005C + 1
			     3				mov al, [bx+??005C]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'O'
			     3				jne ??005E
			     3	
 = 0004			     3				??005C = ??005C + 1
			     2			mov ax, 1
			     2			jmp ??005F
			     2			??005E:
			     2				mov ax, 0
			     2			??005F:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0064 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0064 eq 0
			     4				??0065     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0065 substr regStack, 1, (??0064 - 1)      
			     4				regStack substr regStack, (??0064 + 1)     
			     4			endif
			     4			exitm ??0065
			     3		for ??0063, <bx, ax> 
			     3				pop ??0063
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@UNDO
			     1			.endif
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
			     1			StartsWith <WRITE> si
			     2			SaveRegs ax, bx
			     3			??006B     textequ <>
			     3			??006C textequ <>
			     3			for       ??006A, <ax,bx>
			     3				push  ??006A
			     3				??006C catstr <??006A>, ??006B, ??006C
			     3				??006B catstr <, >
			     3			endm
			     4				push  ax
			     4				??006C catstr <ax>, ??006B, ??006C
			     4				??006B catstr <, >
			     4				push  bx
			     4				??006C catstr <bx>, ??006B, ??006C
			     4				??006B catstr <, >
			     3			??006C catstr OPEN_DELIMITER, ??006C, CLOSE_DELIMITER
			     3			__pushRegs ??006C
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??006C
			     4			else
			     4				regStack catstr ??006C, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0066 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0066]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0068
			     2				??0066 = ??0066 + 1
			     2			endm 
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'W'
			     3				jne ??0068
			     3	
 = 0001			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'R'
			     3				jne ??0068
			     3	
 = 0002			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0068
			     3	
 = 0003			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0068
			     3	
 = 0004			     3				??0066 = ??0066 + 1
			     3				mov al, [bx+??0066]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??0068
			     3	
 = 0005			     3				??0066 = ??0066 + 1
			     2			mov ax, 1
			     2			jmp ??0069
			     2			??0068:
			     2				mov ax, 0
			     2			??0069:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??006E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??006E eq 0
			     4				??006F     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??006F substr regStack, 1, (??006E - 1)      
			     4				regStack substr regStack, (??006E + 1)     
			     4			endif
			     4			exitm ??006F
			     3		for ??006D, <bx, ax> 
			     3				pop ??006D
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 05
			     1				jmp ParseCommand@WRITE
			     1			.endif
						jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
			     1			StartsWith <EXIT> si
			     2			SaveRegs ax, bx
			     3			??0075     textequ <>
			     3			??0076 textequ <>
			     3			for       ??0074, <ax,bx>
			     3				push  ??0074
			     3				??0076 catstr <??0074>, ??0075, ??0076
			     3				??0075 catstr <, >
			     3			endm
			     4				push  ax
			     4				??0076 catstr <ax>, ??0075, ??0076
			     4				??0075 catstr <, >
			     4				push  bx
			     4				??0076 catstr <bx>, ??0075, ??0076
			     4				??0075 catstr <, >
			     3			??0076 catstr OPEN_DELIMITER, ??0076, CLOSE_DELIMITER
			     3			__pushRegs ??0076
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0076
			     4			else
			     4				regStack catstr ??0076, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??0070 = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??0070]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0072
			     2				??0070 = ??0070 + 1
			     2			endm 
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'E'
			     3				jne ??0072
			     3	
 = 0001			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'X'
			     3				jne ??0072
			     3	
 = 0002			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??0072
			     3	
 = 0003			     3				??0070 = ??0070 + 1
			     3				mov al, [bx+??0070]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??0072
			     3	
 = 0004			     3				??0070 = ??0070 + 1
			     2			mov ax, 1
			     2			jmp ??0073
			     2			??0072:
			     2				mov ax, 0
			     2			??0073:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0078 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0078 eq 0
			     4				??0079     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0079 substr regStack, 1, (??0078 - 1)      
			     4				regStack substr regStack, (??0078 + 1)     
			     4			endif
			     4			exitm ??0079
			     3		for ??0077, <bx, ax> 
			     3				pop ??0077
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
						jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
			     1			StartsWith <QUIT> si
			     2			SaveRegs ax, bx
			     3			??007F     textequ <>
			     3			??0080 textequ <>
			     3			for       ??007E, <ax,bx>
			     3				push  ??007E
			     3				??0080 catstr <??007E>, ??007F, ??0080
			     3				??007F catstr <, >
			     3			endm
			     4				push  ax
			     4				??0080 catstr <ax>, ??007F, ??0080
			     4				??007F catstr <, >
			     4				push  bx
			     4				??0080 catstr <bx>, ??007F, ??0080
			     4				??007F catstr <, >
			     3			??0080 catstr OPEN_DELIMITER, ??0080, CLOSE_DELIMITER
			     3			__pushRegs ??0080
			     4			size_s sizestr regStack
			     4			if     size_s eq 0
			     4				regStack catstr ??0080
			     4			else
			     4				regStack catstr ??0080, REG_SET_DELIMITER, regStack      
			     4			endif
			     2	
 = 0000			     2			??007A = 0
			     2			
			     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??007A]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007C
			     2				??007A = ??007A + 1
			     2			endm 
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'Q'
			     3				jne ??007C
			     3	
 = 0001			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'U'
			     3				jne ??007C
			     3	
 = 0002			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'I'
			     3				jne ??007C
			     3	
 = 0003			     3				??007A = ??007A + 1
			     3				mov al, [bx+??007A]
			     3				and al, 11011111b ; toUpperCase
			     3				cmp al, 'T'
			     3				jne ??007C
			     3	
 = 0004			     3				??007A = ??007A + 1
			     2			mov ax, 1
			     2			jmp ??007D
			     2			??007C:
			     2				mov ax, 0
			     2			??007D:
			     2				cmp ax, 0
			     2				RestoreRegs
			     4			??0082 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0082 eq 0
			     4				??0083     substr regStack, 1
			     4				regStack textequ <>
			     4			else
			     4				??0083 substr regStack, 1, (??0082 - 1)      
			     4				regStack substr regStack, (??0082 + 1)     
			     4			endif
			     4			exitm ??0083
			     3		for ??0081, <bx, ax> 
			     3				pop ??0081
			     3			endm
			     4				pop bx
			     4				pop ax
			     1			
			     1			.if (!zero?)
			     1				add si, 04
			     1				jmp ParseCommand@EXIT
			     1			.endif
					
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			??0085     textequ <>
			     4			??0086 textequ <>
			     4			for       ??0084, <ax>
			     4				push  ??0084
			     4				??0086 catstr <??0084>, ??0085, ??0086
			     4				??0085 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0086 catstr <ax>, ??0085, ??0086
			     5				??0085 catstr <, >
			     4			??0086 catstr OPEN_DELIMITER, ??0086, CLOSE_DELIMITER
			     4			__pushRegs ??0086
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0086
			     5			else
			     5				regStack catstr ??0086, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@Comando>, <si>
			     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>>, 
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??0088 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0088 eq 0
			     5				??0089     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??0089 substr regStack, 1, (??0088 - 1)      
			     5				regStack substr regStack, (??0088 + 1)     
			     5			endif
			     5			exitm ??0089
			     4		for ??0087, <ax> 
			     4				pop ??0087
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di  ax
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			??008B     textequ <>
			     4			??008C textequ <>
			     4			for       ??008A, <ax>
			     4				push  ??008A
			     4				??008C catstr <??008A>, ??008B, ??008C
			     4				??008B catstr <, >
			     4			endm
			     5				push  ax
			     5				??008C catstr <ax>, ??008B, ??008C
			     5				??008B catstr <, >
			     4			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     4			__pushRegs ??008C
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??008C
			     5			else
			     5				regStack catstr ??008C, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@space>, <si>
			     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii> <s
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??008E instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??008E eq 0
			     5				??008F     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??008F substr regStack, 1, (??008E - 1)      
			     5				regStack substr regStack, (??008E + 1)     
			     5			endif
			     5			exitm ??008F
			     4		for ??008D, <ax> 
			     4				pop ??008D
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@space>, dii  
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			??0091     textequ <>
			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0092 catstr <ax>, ??0091, ??0092
			     5				??0091 catstr <, >
			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
			     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>cid
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
			     5				??0095     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)      
			     5				regStack substr regStack, (??0094 + 1)     
			     5			endif
			     5			exitm ??0095
			     4		for ??0093, <ax> 
			     4				pop ??0093
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, dix, bx
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??0097     textequ <>
			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
			     5				push  ax
			     5				??0098 catstr <ax>, ??0097, ??0098
			     5				??0097 catstr <, >
			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
			     5				??009B     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)      
			     5				regStack substr regStack, (??009A + 1)     
			     5			endif
			     5			exitm ??009B
			     4		for ??0099, <ax> 
			     4				pop ??0099
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, dii    
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??009D     textequ <>
			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
			     5				push  ax
			     5				??009E catstr <ax>, ??009D, ??009E
			     5				??009D catstr <, >
			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
			     5				??00A1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)      
			     5				regStack substr regStack, (??00A0 + 1)     
			     5			endif
			     5			exitm ??00A1
			     4		for ??009F, <ax> 
			     4				pop ??009F
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, dii   
			     2				endif
					ParseCommand@error:
						stc
						ret
					ParseCommand@MUL:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_INVALIDA
							jmp ParseCommand@error
						.endif
						
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
						mov ax, CMD_MUL
						jmp ParseCommand@success
					ParseCommand@ADD:
						skipAndRead si, a, bx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov bx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
						skipAndRead si, a, cx
			     1			SkipSpacesInSI si
			     2			.while (BYTE PTR [si] == ' ' )
			     2				inc si
			     2			.endw
			     1			invoke ReadNumFromString, si, addr a
			     1			.if            (carry?)
			     1				stc
			     1			.else
			     1				mov cx, a
			     1				clc
			     1			.endif
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
						mov ax, CMD_ADD
						
						jmp ParseCommand@success
					ParseCommand@UNDO:
						mov ax, CMD_UNDO
						jmp ParseCommand@success
					ParseCommand@WRITE:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
							inc si
						.endw
						jmp ParseCommand@success
					ParseCommand@EXIT:
						jmp ParseCommand@success
					ParseCommand@success:
						SkipSpacesInSI si
			     1			.while (BYTE PTR [si] == ' ' )
			     1				inc si
			     1			.endw
						
						.if (byte ptr [si] != 0)
						
							strcpy_all                                          NonTerminalErrorBuffer, \
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
			     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			??00A3     textequ <>
			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00A4 catstr <ax>, ??00A3, ??00A4
			     5				??00A3 catstr <, >
			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack?00A3,
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
			     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ros
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
			     5				??00A7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)      
			     5				regStack substr regStack, (??00A6 + 1)     
			     5			endif
			     5			exitm ??00A7
			     4		for ??00A5, <ax> 
			     4				pop ??00A5
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di      
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			??00A9     textequ <>
			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??00AA catstr <ax>, ??00A9, ??00AA
			     5				??00A9 catstr <, >
			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
			     3				lea si, COLON_SPACE
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>onS
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
			     5				??00AD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)DELIMI
			     5				regStack substr regStack, (??00AC + 1)DELIM
			     5			endif
			     5			exitm ??00AD
			     4		for ??00AB, <ax> 
			     4				pop ??00AB
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, didos_ao
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if -1
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			??00AF     textequ <>
			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
			     5				push  ax
			     5				??00B0 catstr <ax>, ??00AF, ??00B0
			     5				??00AF catstr <, >
			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
			     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, dii>ffe
			     3			endif
			     3			.repeat
			     3				mov al,   [si]
			     3				mov [di], al
			     3				inc si
			     3				inc di
			     3			.until (al == 0)
			     3			dec    si
			     3			dec    di
			     3			RestoreRegs
			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
			     5				??00B3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)      
			     5				regStack substr regStack, (??00B2 + 1)     
			     5			endif
			     5			exitm ??00B3
			     4		for ??00B1, <ax> 
			     4				pop ??00B1
			     4			endm
			     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, didos_a
			     2				endif
							
							jmp ParseCommand@error
						.endif
						clc
						ret
 0D24					ParseCommand endp
 0D24					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00B5     textequ <>
			     5			??00B6 textequ <>
			     5			for       ??00B4, <ax>
			     5				push  ??00B4
			     5				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     5				??00B5 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00B6 catstr <ax>, ??00B5, ??00B6
			     6				??00B5 catstr <, >
			     5			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
			     5			__pushRegs ??00B6
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00B6
			     6			else
			     6				regStack catstr ??00B6, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00B8 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00B8 eq 0
			     6				??00B9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00B9 substr regStack, 1, (??00B8 - 1)      
			     6				regStack substr regStack, (??00B8 + 1)     
			     6			endif
			     6			exitm ??00B9
			     5		for ??00B7, <ax> 
			     5				pop ??00B7
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di 
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00BB     textequ <>
			     5			??00BC textequ <>
			     5			for       ??00BA, <ax>
			     5				push  ??00BA
			     5				??00BC catstr <??00BA>, ??00BB, ??00BC
			     5				??00BB catstr <, >
			     5			endm
			     6				push  ax
			     6				??00BC catstr <ax>, ??00BB, ??00BC
			     6				??00BB catstr <, >
			     5			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
			     5			__pushRegs ??00BC
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00BC
			     6			else
			     6				regStack catstr ??00BC, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00BE instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00BE eq 0
			     6				??00BF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00BF substr regStack, 1, (??00BE - 1)      
			     6				regStack substr regStack, (??00BE + 1)     
			     6			endif
			     6			exitm ??00BF
			     5		for ??00BD, <ax> 
			     5				pop ??00BD
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , di di 
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C2 catstr <ax>, ??00C1, ??00C2
			     6				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
			     5			__pushRegs ??00C2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00C4 eq 0
			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)      
			     6				regStack substr regStack, (??00C4 + 1)     
			     6			endif
			     6			exitm ??00C5
			     5		for ??00C3, <ax> 
			     5				pop ??00C3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, dii   
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , di    
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>r ?
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00C8 catstr <ax>, ??00C7, ??00C8
			     6				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
			     5			__pushRegs ??00C8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00CA eq 0
			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)0C1 ca
			     6				regStack substr regStack, (??00CA + 1)0C1 c
			     6			endif
			     6			exitm ??00CB
			     5		for ??00C9, <ax> 
			     5				pop ??00C9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00CE catstr <ax>, ??00CD, ??00CE
			     6				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
			     5			__pushRegs ??00CE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D0 eq 0
			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)      
			     6				regStack substr regStack, (??00D0 + 1)     
			     6			endif
			     6			exitm ??00D1
			     5		for ??00CF, <ax> 
			     5				pop ??00CF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00D4 catstr <ax>, ??00D3, ??00D4
			     6				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
			     5			__pushRegs ??00D4
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00D6 eq 0
			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)      
			     6				regStack substr regStack, (??00D6 + 1)     
			     6			endif
			     6			exitm ??00D7
			     5		for ??00D5, <ax> 
			     5				pop ??00D5
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0E70					ParseCommand@LINHA_AUSENTE endp
 0E70					ParseCommand@CONSTANTE_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00DA catstr <ax>, ??00D9, ??00DA
			     6				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
			     5			__pushRegs ??00DA
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00DC eq 0
			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)      
			     6				regStack substr regStack, (??00DC + 1)     
			     6			endif
			     6			exitm ??00DD
			     5		for ??00DB, <ax> 
			     5				pop ??00DB
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "MUL" , di, di 
			     3				else
			     3					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E0 catstr <ax>, ??00DF, ??00E0
			     6				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
			     5			__pushRegs ??00E0
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E2 eq 0
			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)      
			     6				regStack substr regStack, (??00E2 + 1)     
			     6			endif
			     6			exitm ??00E3
			     5		for ??00E1, <ax> 
			     5				pop ??00E1
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  CONSTANTE , di     
			     3				else
			     3					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'C'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00E6 catstr <ax>, ??00E5, ??00E6
			     6				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
			     5			__pushRegs ??00E6
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00E8 eq 0
			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)      
			     6				regStack substr regStack, (??00E8 + 1)     
			     6			endif
			     6			exitm ??00E9
			     5		for ??00E7, <ax> 
			     5				pop ??00E7
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi   
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>r r
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
			     5			endm
			     6				push  ax
			     6				??00EC catstr <ax>, ??00EB, ??00EC
			     6				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
			     5			__pushRegs ??00EC
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00EE eq 0
			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)      
			     6				regStack substr regStack, (??00EE + 1)     
			     6			endif
			     6			exitm ??00EF
			     5		for ??00ED, <ax> 
			     5				pop ??00ED
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F2 catstr <ax>, ??00F1, ??00F2
			     6				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
			     5			__pushRegs ??00F2
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00F4 eq 0
			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)      
			     6				regStack substr regStack, (??00F4 + 1)     
			     6			endif
			     6			exitm ??00F5
			     5		for ??00F3, <ax> 
			     5				pop ??00F3
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
			     5			endm
			     6				push  ax
			     6				??00F8 catstr <ax>, ??00F7, ??00F8
			     6				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
			     5			__pushRegs ??00F8
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??00FA eq 0
			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)      
			     6				regStack substr regStack, (??00FA + 1)     
			     6			endif
			     6			exitm ??00FB
			     5		for ??00F9, <ax> 
			     5				pop ??00F9
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 0FC8					ParseCommand@CONSTANTE_AUSENTE endp
					
 0FC8					ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
			     5			endm
			     6				push  ax
			     6				??00FE catstr <ax>, ??00FD, ??00FE
			     6				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
			     5			__pushRegs ??00FE
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0100 eq 0
			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)      
			     6				regStack substr regStack, (??0100 + 1)     
			     6			endif
			     6			exitm ??0101
			     5		for ??00FF, <ax> 
			     5				pop ??00FF
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, di 
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0104 catstr <ax>, ??0103, ??0104
			     6				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
			     5			__pushRegs ??0104
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0106 eq 0
			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)      
			     6				regStack substr regStack, (??0106 + 1)     
			     6			endif
			     6			exitm ??0107
			     5		for ??0105, <ax> 
			     5				pop ??0105
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , di     
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
			     5			endm
			     6				push  ax
			     6				??010A catstr <ax>, ??0109, ??010A
			     6				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
			     5			__pushRegs ??010A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??010C eq 0
			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)      
			     6				regStack substr regStack, (??010C + 1)     
			     6			endif
			     6			exitm ??010D
			     5		for ??010B, <ax> 
			     5				pop ??010B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  PRIMEIRO , dii    
			     3				else
			     3					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>di]
			     4			endif
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'P'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'M'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0110 catstr <ax>, ??010F, ??0110
			     6				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
			     5			__pushRegs ??0110
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0112 eq 0
			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)      
			     6				regStack substr regStack, (??0112 + 1)     
			     6			endif
			     6			exitm ??0113
			     5		for ??0111, <ax> 
			     5				pop ??0111
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0116 catstr <ax>, ??0115, ??0116
			     6				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
			     5			__pushRegs ??0116
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0118 eq 0
			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)      
			     6				regStack substr regStack, (??0118 + 1)     
			     6			endif
			     6			exitm ??0119
			     5		for ??0117, <ax> 
			     5				pop ??0117
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
			     5			endm
			     6				push  ax
			     6				??011C catstr <ax>, ??011B, ??011C
			     6				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
			     5			__pushRegs ??011C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??011E eq 0
			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)      
			     6				regStack substr regStack, (??011E + 1)     
			     6			endif
			     6			exitm ??011F
			     5		for ??011D, <ax> 
			     5				pop ??011D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 1124					ParseCommand@LINHA_DST_AUSENTE endp
 1124					ParseCommand@LINHA_ORG_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @Comando
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @Comando, di
			     4			SaveRegs ax
			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0122 catstr <ax>, ??0121, ??0122
			     6				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
			     5			__pushRegs ??0122
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>>, 
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0124 eq 0
			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1)üK  
			     6				regStack substr regStack, (??0124 + 1)üK 
			     6			endif
			     6			exitm ??0125
			     5		for ??0123, <ax> 
			     5				pop ??0123
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di      
			     3				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  "ADD" , di, di 
			     3				else
			     3					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], '"'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @espera
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @espera, di
			     4			SaveRegs ax
			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0128 catstr <ax>, ??0127, ??0128
			     6				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
			     5			__pushRegs ??0128
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>, <
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??012A eq 0
			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1) axca
			     6				regStack substr regStack, (??012A + 1) axc
			     6			endif
			     6			exitm ??012B
			     5		for ??0129, <ax> 
			     5				pop ??0129
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@espera>, di     
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di     
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @como
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @como, di
			     4			SaveRegs ax
			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
			     5			endm
			     6				push  ax
			     6				??012E catstr <ax>, ??012D, ??012E
			     6				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
			     5			__pushRegs ??012E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii><si
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0130 eq 0
			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)      
			     6				regStack substr regStack, (??0130 + 1)     
			     6			endif
			     6			exitm ??0131
			     5		for ??012F, <ax> 
			     5				pop ??012F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@como>, didi   
			     3				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  SEGUNDO , didi   
			     3				else
			     3					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'E'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], 'U'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @parametro, di
			     4			SaveRegs ax
			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0134 catstr <ax>, ??0133, ??0134
			     6				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
			     5			__pushRegs ??0134
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>o>
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0136 eq 0
			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1)      
			     6				regStack substr regStack, (??0136 + 1)     
			     6			endif
			     6			exitm ??0137
			     5		for ??0135, <ax> 
			     5				pop ??0135
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
			     5			endm
			     6				push  ax
			     6				??013A catstr <ax>, ??0139, ??013A
			     6				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
			     5			__pushRegs ??013A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??013C eq 0
			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)      
			     6				regStack substr regStack, (??013C + 1)     
			     6			endif
			     6			exitm ??013D
			     5		for ??013B, <ax> 
			     5				pop ??013B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di      
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0140 catstr <ax>, ??013F, ??0140
			     6				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
			     5			__pushRegs ??0140
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0142 eq 0
			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)      
			     6				regStack substr regStack, (??0142 + 1)     
			     6			endif
			     6			exitm ??0143
			     5		for ??0141, <ax> 
			     5				pop ??0141
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di     
			     3				endif
						ret
 127C					ParseCommand@LINHA_ORG_AUSENTE endp
 127C					ParseCommand@LINHA_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0146 catstr <ax>, ??0145, ??0146
			     6				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
			     5			__pushRegs ??0146
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0148 eq 0
			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)\ Ä 
			     6				regStack substr regStack, (??0148 + 1)\ Ä
			     6			endif
			     6			exitm ??0149
			     5		for ??0147, <ax> 
			     5				pop ??0147
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA , diro>, d
			     3				else
			     3					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
			     5			endm
			     6				push  ax
			     6				??014C catstr <ax>, ??014B, ??014C
			     6				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
			     5			__pushRegs ??014C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??014E eq 0
			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)10F ca
			     6				regStack substr regStack, (??014E + 1)10F c
			     6			endif
			     6			exitm ??014F
			     5		for ??014D, <ax> 
			     5				pop ??014D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0152 catstr <ax>, ??0151, ??0152
			     6				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
			     5			__pushRegs ??0152
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0154 eq 0
			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)R, reg
			     6				regStack substr regStack, (??0154 + 1)R, re
			     6			endif
			     6			exitm ??0155
			     5		for ??0153, <ax> 
			     5				pop ??0153
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0158 catstr <ax>, ??0157, ??0158
			     6				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
			     5			__pushRegs ??0158
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??015A eq 0
			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)      
			     6				regStack substr regStack, (??015A + 1)     
			     6			endif
			     6			exitm ??015B
			     5		for ??0159, <ax> 
			     5				pop ??0159
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 1334					ParseCommand@LINHA_INVALIDA endp
 1334					ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
			     5			endm
			     6				push  ax
			     6				??015E catstr <ax>, ??015D, ??015E
			     6				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
			     5			__pushRegs ??015E
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0160 eq 0
			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)      
			     6				regStack substr regStack, (??0160 + 1)     
			     6			endif
			     6			exitm ??0161
			     5		for ??015F, <ax> 
			     5				pop ??015F
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di, (??0
			     3				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_DST , di di, 
			     3				else
			     3					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'D'
			     5				inc di
			     5				mov byte ptr [di], 'S'
			     5				inc di
			     5				mov byte ptr [di], 'T'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0164 catstr <ax>, ??0163, ??0164
			     6				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
			     5			__pushRegs ??0164
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0166 eq 0
			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)      
			     6				regStack substr regStack, (??0166 + 1)     
			     6			endif
			     6			exitm ??0167
			     5		for ??0165, <ax> 
			     5				pop ??0165
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di1)  
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
			     5			endm
			     6				push  ax
			     6				??016A catstr <ax>, ??0169, ??016A
			     6				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
			     5			__pushRegs ??016A
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack, > ?
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??016C eq 0
			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)      
			     6				regStack substr regStack, (??016C + 1)     
			     6			endif
			     6			exitm ??016D
			     5		for ??016B, <ax> 
			     5				pop ??016B
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi1)
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
			     5			endm
			     6				push  ax
			     6				??0170 catstr <ax>, ??016F, ??0170
			     6				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
			     5			__pushRegs ??0170
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0172 eq 0
			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)      
			     6				regStack substr regStack, (??0172 + 1)     
			     6			endif
			     6			exitm ??0173
			     5		for ??0171, <ax> 
			     5				pop ??0171
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi1)
			     3				endif
						ret
 13FC					ParseCommand@LINHA_DST_INVALIDA endp
 13FC					ParseCommand@LINHA_ORG_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_ORG>
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     2			endm
			     4			IFDEF @@parametro
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @@parametro, di
			     4			SaveRegs ax
			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0176 catstr <ax>, ??0175, ??0176
			     6				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
			     5			__pushRegs ??0176
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ro
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0178 eq 0
			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)      
			     6				regStack substr regStack, (??0178 + 1)     
			     6			endif
			     6			exitm ??0179
			     5		for ??0177, <ax> 
			     5				pop ??0177
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di      
			     3				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     4				EXITM <0> 
			     3				if 0
			     3					strcpy  LINHA_ORG , di di  
			     3				else
			     3					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, dii>   
			     4			endif
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
			     4			endm
			     5				mov byte ptr [di], ' '
			     5				inc di
			     5				mov byte ptr [di], 'L'
			     5				inc di
			     5				mov byte ptr [di], 'I'
			     5				inc di
			     5				mov byte ptr [di], 'N'
			     5				inc di
			     5				mov byte ptr [di], 'H'
			     5				inc di
			     5				mov byte ptr [di], 'A'
			     5				inc di
			     5				mov byte ptr [di], '_'
			     5				inc di
			     5				mov byte ptr [di], 'O'
			     5				inc di
			     5				mov byte ptr [di], 'R'
			     5				inc di
			     5				mov byte ptr [di], 'G'
			     5				inc di
			     5				mov byte ptr [di], ' '
			     5				inc di
			     4			mov byte ptr [di], 0
			     3				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy @deve_estar_entre_1_e_N, di
			     4			SaveRegs ax
			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
			     5			endm
			     6				push  ax
			     6				??017C catstr <ax>, ??017B, ??017C
			     6				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
			     5			__pushRegs ??017C
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ar_
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??017E eq 0
			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)rametr
			     6				regStack substr regStack, (??017E + 1)ramet
			     6			endif
			     6			exitm ??017F
			     5		for ??017D, <ax> 
			     5				pop ??017D
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di      
			     3				endif
			     4			IFDEF ExplanationSeparator
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy ExplanationSeparator, di
			     4			SaveRegs ax
			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0182 catstr <ax>, ??0181, ??0182
			     6				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
			     5			__pushRegs ??0182
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, COLON_SPACE
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>onS
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??0184 eq 0
			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)      
			     6				regStack substr regStack, (??0184 + 1)     
			     6			endif
			     6			exitm ??0185
			     5		for ??0183, <ax> 
			     5				pop ??0183
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, didi   
			     3				endif
			     4			IFDEF CommandBufferString
			     4				EXITM <-1> 
			     3				if -1
			     3					strcpy CommandBufferString, di
			     4			SaveRegs ax
			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
			     5			endm
			     6				push  ax
			     6				??0188 catstr <ax>, ??0187, ??0188
			     6				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
			     5			__pushRegs ??0188
			     6			size_s sizestr regStack
			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStack      
			     6			endif
			     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, dii>ffe
			     4			endif
			     4			.repeat
			     4				mov al,   [si]
			     4				mov [di], al
			     4				inc si
			     4				inc di
			     4			.until (al == 0)
			     4			dec    si
			     4			dec    di
			     4			RestoreRegs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
			     6			if    ??018A eq 0
			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)      
			     6				regStack substr regStack, (??018A + 1)     
			     6			endif
			     6			exitm ??018B
			     5		for ??0189, <ax> 
			     5				pop ??0189
			     5			endm
			     6				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, didi  
			     3				endif
						ret
 14C4					ParseCommand@LINHA_ORG_INVALIDA endp
				;====================================================================
				; Reading error reporting
					ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??018D     textequ <>
			     2			??018E textequ <>
			     2			for       ??018C, <ax,dx>
			     2				push  ??018C
			     2				??018E catstr <??018C>, ??018D, ??018E
			     2				??018D catstr <, >
			     2			endm
			     3				push  ax
			     3				??018E catstr <ax>, ??018D, ??018E
			     3				??018D catstr <, >
			     3				push  dx
			     3				??018E catstr <dx>, ??018D, ??018E
			     3				??018D catstr <, >
			     2			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
			     2			__pushRegs ??018E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??018E
			     3			else
			     3				regStack catstr ??018E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??0190 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0190 eq 0
			     3				??0191     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0191 substr regStack, 1, (??0190 - 1)      
			     3				regStack substr regStack, (??0190 + 1)     
			     3			endif
			     3			exitm ??0191
			     2		for ??018F, <dx, ax> 
			     2				pop ??018F
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRead:
						printf_c <Erro na leitura do arquivo.>
			     1			SaveRegs ax,   dx
			     2			??0193     textequ <>
			     2			??0194 textequ <>
			     2			for       ??0192, <ax,dx>
			     2				push  ??0192
			     2				??0194 catstr <??0192>, ??0193, ??0194
			     2				??0193 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0194 catstr <ax>, ??0193, ??0194
			     3				??0193 catstr <, >
			     3				push  dx
			     3				??0194 catstr <dx>, ??0193, ??0194
			     3				??0193 catstr <, >
			     2			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
			     2			__pushRegs ??0194
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0194
			     3			else
			     3				regStack catstr ??0194, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??0196 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0196 eq 0
			     3				??0197     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0197 substr regStack, 1, (??0196 - 1) Ç 	
			     3				regStack substr regStack, (??0196 + 1) Ç 
			     3			endif
			     3			exitm ??0197
			     2		for ??0195, <dx, ax> 
			     2				pop ??0195
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorColumnCount:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??0199     textequ <>
			     4			??019A textequ <>
			     4			for       ??0198, <ax,dx>
			     4				push  ??0198
			     4				??019A catstr <??0198>, ??0199, ??019A
			     4				??0199 catstr <, >
			     4			endm
			     5				push  ax
			     5				??019A catstr <ax>, ??0199, ??019A
			     5				??0199 catstr <, >
			     5				push  dx
			     5				??019A catstr <dx>, ??0199, ??019A
			     5				??0199 catstr <, >
			     4			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     4			__pushRegs ??019A
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??019A
			     5			else
			     5				regStack catstr ??019A, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??019C instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??019C eq 0
			     5				??019D     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??019D substr regStack, 1, (??019C - 1)DELIMI
			     5				regStack substr regStack, (??019C + 1)DELIM
			     5			endif
			     5			exitm ??019D
			     4		for ??019B, <dx, ax> 
			     4				pop ??019B
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??019F     textequ <>
			     4			??01A0 textequ <>
			     4			for       ??019E, <ax,dx>
			     4				push  ??019E
			     4				??01A0 catstr <??019E>, ??019F, ??01A0
			     4				??019F catstr <, >
			     4			endm
			     5				push  ax
			     5				??01A0 catstr <ax>, ??019F, ??01A0
			     5				??019F catstr <, >
			     5				push  dx
			     5				??01A0 catstr <dx>, ??019F, ??01A0
			     5				??019F catstr <, >
			     4			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     4			__pushRegs ??01A0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01A0
			     5			else
			     5				regStack catstr ??01A0, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A2 eq 0
			     5				??01A3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01A3 substr regStack, 1, (??01A2 - 1)??019F
			     5				regStack substr regStack, (??01A2 + 1)??019
			     5			endif
			     5			exitm ??01A3
			     4		for ??01A1, <dx, ax> 
			     4				pop ??01A1
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01A5     textequ <>
			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01A6 catstr <ax>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     5				push  dx
			     5				??01A6 catstr <dx>, ??01A5, ??01A6
			     5				??01A5 catstr <, >
			     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
			     5				??01A9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)      
			     5				regStack substr regStack, (??01A8 + 1)     
			     5			endif
			     5			exitm ??01A9
			     4		for ??01A7, <dx, ax> 
			     4				pop ??01A7
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1			SaveRegs ax,   dx
			     2			??01AB     textequ <>
			     2			??01AC textequ <>
			     2			for       ??01AA, <ax,dx>
			     2				push  ??01AA
			     2				??01AC catstr <??01AA>, ??01AB, ??01AC
			     2				??01AB catstr <, >
			     2			endm
			     3				push  ax
			     3				??01AC catstr <ax>, ??01AB, ??01AC
			     3				??01AB catstr <, >
			     3				push  dx
			     3				??01AC catstr <dx>, ??01AB, ??01AC
			     3				??01AB catstr <, >
			     2			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     2			__pushRegs ??01AC
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01AC
			     3			else
			     3				regStack catstr ??01AC, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'g'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     1			RestoreRegs
			     3			??01AE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01AE eq 0
			     3				??01AF     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01AF substr regStack, 1, (??01AE - 1)      
			     3				regStack substr regStack, (??01AE + 1)     
			     3			endif
			     3			exitm ??01AF
			     2		for ??01AD, <dx, ax> 
			     2				pop ??01AD
			     2			endm
			     3				pop dx
			     3				pop ax
						jmp      ExitFailure
					ErrorRowCount:
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1			SaveRegs ax,   dx
			     2			??01B1     textequ <>
			     2			??01B2 textequ <>
			     2			for       ??01B0, <ax,dx>
			     2				push  ??01B0
			     2				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     2				??01B1 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01B2 catstr <ax>, ??01B1, ??01B2
			     3				??01B1 catstr <, >
			     3				push  dx
			     3				??01B2 catstr <dx>, ??01B1, ??01B2
			     3				??01B1 catstr <, >
			     2			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     2			__pushRegs ??01B2
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01B2
			     3			else
			     3				regStack catstr ??01B2, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'h'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '1'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'q'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'u'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'O'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'f'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01B4 eq 0
			     3				??01B5     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01B5 substr regStack, 1, (??01B4 - 1)      
			     3				regStack substr regStack, (??01B4 + 1)     
			     3			endif
			     3			exitm ??01B5
			     2		for ??01B3, <dx, ax> 
			     2				pop ??01B3
			     2			endm
			     3				pop dx
			     3				pop ax
						print_TotalRowCol
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01B7     textequ <>
			     4			??01B8 textequ <>
			     4			for       ??01B6, <ax,dx>
			     4				push  ??01B6
			     4				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     4				??01B7 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01B8 catstr <ax>, ??01B7, ??01B8
			     5				??01B7 catstr <, >
			     5				push  dx
			     5				??01B8 catstr <dx>, ??01B7, ??01B8
			     5				??01B7 catstr <, >
			     4			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     4			__pushRegs ??01B8
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01B8
			     5			else
			     5				regStack catstr ??01B8, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01BA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01BA eq 0
			     5				??01BB     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01BB substr regStack, 1, (??01BA - 1)      
			     5				regStack substr regStack, (??01BA + 1)     
			     5			endif
			     5			exitm ??01BB
			     4		for ??01B9, <dx, ax> 
			     4				pop ??01B9
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01BD     textequ <>
			     4			??01BE textequ <>
			     4			for       ??01BC, <ax,dx>
			     4				push  ??01BC
			     4				??01BE catstr <??01BC>, ??01BD, ??01BE
			     4				??01BD catstr <, >
			     4			endm
			     5				push  ax
			     5				??01BE catstr <ax>, ??01BD, ??01BE
			     5				??01BD catstr <, >
			     5				push  dx
			     5				??01BE catstr <dx>, ??01BD, ??01BE
			     5				??01BD catstr <, >
			     4			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     4			__pushRegs ??01BE
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01BE
			     5			else
			     5				regStack catstr ??01BE, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C0 eq 0
			     5				??01C1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01C1 substr regStack, 1, (??01C0 - 1) ax  
			     5				regStack substr regStack, (??01C0 + 1) ax 
			     5			endif
			     5			exitm ??01C1
			     4		for ??01BF, <dx, ax> 
			     4				pop ??01BF
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01C3     textequ <>
			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01C4 catstr <ax>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     5				push  dx
			     5				??01C4 catstr <dx>, ??01C3, ??01C4
			     5				??01C3 catstr <, >
			     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
			     5				??01C7     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)      
			     5				regStack substr regStack, (??01C6 + 1)     
			     5			endif
			     5			exitm ??01C7
			     4		for ??01C5, <dx, ax> 
			     4				pop ??01C5
			     4			endm
			     5				pop dx
			     5				pop ax
						jmp      ExitFailure
					ErrorUnexpectedChar:
						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01C9     textequ <>
			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01CA catstr <ax>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     5				push  dx
			     5				??01CA catstr <dx>, ??01C9, ??01CA
			     5				??01C9 catstr <, >
			     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
			     5				??01CD     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)      
			     5				regStack substr regStack, (??01CC + 1)     
			     5			endif
			     5			exitm ??01CD
			     4		for ??01CB, <dx, ax> 
			     4				pop ??01CB
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01CF     textequ <>
			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D0 catstr <ax>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     5				push  dx
			     5				??01D0 catstr <dx>, ??01CF, ??01D0
			     5				??01CF catstr <, >
			     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStack, > ?
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
			     5				??01D3     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)      
			     5				regStack substr regStack, (??01D2 + 1)     
			     5			endif
			     5			exitm ??01D3
			     4		for ??01D1, <dx, ax> 
			     4				pop ??01D1
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01D5     textequ <>
			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01D6 catstr <ax>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     5				push  dx
			     5				??01D6 catstr <dx>, ??01D5, ??01D6
			     5				??01D5 catstr <, >
			     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack, > ?
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
			     5				??01D9     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)      
			     5				regStack substr regStack, (??01D8 + 1)     
			     5			endif
			     5			exitm ??01D9
			     4		for ??01D7, <dx, ax> 
			     4				pop ??01D7
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: caracter inexperado: ">
			     1			SaveRegs ax,   dx
			     2			??01DB     textequ <>
			     2			??01DC textequ <>
			     2			for       ??01DA, <ax,dx>
			     2				push  ??01DA
			     2				??01DC catstr <??01DA>, ??01DB, ??01DC
			     2				??01DB catstr <, >
			     2			endm
			     3				push  ax
			     3				??01DC catstr <ax>, ??01DB, ??01DC
			     3				??01DB catstr <, >
			     3				push  dx
			     3				??01DC catstr <dx>, ??01DB, ??01DC
			     3				??01DB catstr <, >
			     2			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     2			__pushRegs ??01DC
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01DC
			     3			else
			     3				regStack catstr ??01DC, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'i'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'x'
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '"'
			     2				int 21h
			     1			RestoreRegs
			     3			??01DE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01DE eq 0
			     3				??01DF     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01DF substr regStack, 1, (??01DE - 1)      
			     3				regStack substr regStack, (??01DE + 1)     
			     3			endif
			     3			exitm ??01DF
			     2		for ??01DD, <dx, ax> 
			     2				pop ??01DD
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr TheUnexpectedChar
						jmp ExitFailure
					ErrorInvalidN:
						print_FilePosition
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			??01E1     textequ <>
			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01E2 catstr <ax>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     5				push  dx
			     5				??01E2 catstr <dx>, ??01E1, ??01E2
			     5				??01E1 catstr <, >
			     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStack21hˇ
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, '('
			     4				int 21h
			     3			RestoreRegs
			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
			     5				??01E5     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)      
			     5				regStack substr regStack, (??01E4 + 1)     
			     5			endif
			     5			exitm ??01E5
			     4		for ??01E3, <dx, ax> 
			     4				pop ??01E3
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			??01E7     textequ <>
			     4			??01E8 textequ <>
			     4			for       ??01E6, <ax,dx>
			     4				push  ??01E6
			     4				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     4				??01E7 catstr <, >
			     4			endm
			     5				push  ax
			     5				??01E8 catstr <ax>, ??01E7, ??01E8
			     5				??01E7 catstr <, >
			     5				push  dx
			     5				??01E8 catstr <dx>, ??01E7, ??01E8
			     5				??01E7 catstr <, >
			     4			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     4			__pushRegs ??01E8
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01E8
			     5			else
			     5				regStack catstr ??01E8, REG_SET_DELIMITER, regStack, > ?
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ':'
			     4				int 21h
			     3			RestoreRegs
			     5			??01EA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01EA eq 0
			     5				??01EB     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01EB substr regStack, 1, (??01EA - 1)R, reg
			     5				regStack substr regStack, (??01EA + 1)R, re
			     5			endif
			     5			exitm ??01EB
			     4		for ??01E9, <dx, ax> 
			     4				pop ??01E9
			     4			endm
			     5				pop dx
			     5				pop ax
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			??01ED     textequ <>
			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
			     5				push  ax
			     5				??01EE catstr <ax>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     5				push  dx
			     5				??01EE catstr <dx>, ??01ED, ??01EE
			     5				??01ED catstr <, >
			     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
			     5			size_s sizestr regStack
			     5			if     size_s eq 0
			     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack      
			     5			endif
			     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
			     4				mov dl, ')'
			     4				int 21h
			     3			RestoreRegs
			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
			     5				??01F1     substr regStack, 1
			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)      
			     5				regStack substr regStack, (??01F0 + 1)     
			     5			endif
			     5			exitm ??01F1
			     4		for ??01EF, <dx, ax> 
			     4				pop ??01EF
			     4			endm
			     5				pop dx
			     5				pop ax
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1			SaveRegs ax,   dx
			     2			??01F3     textequ <>
			     2			??01F4 textequ <>
			     2			for       ??01F2, <ax,dx>
			     2				push  ??01F2
			     2				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     2				??01F3 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01F4 catstr <ax>, ??01F3, ??01F4
			     3				??01F3 catstr <, >
			     3				push  dx
			     3				??01F4 catstr <dx>, ??01F3, ??01F4
			     3				??01F3 catstr <, >
			     2			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     2			__pushRegs ??01F4
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01F4
			     3			else
			     3				regStack catstr ??01F4, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'E'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'v'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '2'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, '7'
			     2				int 21h
			     2				mov dl, '.'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'N'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01F6 eq 0
			     3				??01F7     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01F7 substr regStack, 1, (??01F6 - 1)      
			     3				regStack substr regStack, (??01F6 + 1)     
			     3			endif
			     3			exitm ??01F7
			     2		for ??01F5, <dx, ax> 
			     2				pop ??01F5
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_u, N
						jmp      ExitFailure
					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
			     1			SaveRegs ax,   dx
			     2			??01F9     textequ <>
			     2			??01FA textequ <>
			     2			for       ??01F8, <ax,dx>
			     2				push  ??01F8
			     2				??01FA catstr <??01F8>, ??01F9, ??01FA
			     2				??01F9 catstr <, >
			     2			endm
			     3				push  ax
			     3				??01FA catstr <ax>, ??01F9, ??01FA
			     3				??01F9 catstr <, >
			     3				push  dx
			     3				??01FA catstr <dx>, ??01F9, ??01FA
			     3				??01F9 catstr <, >
			     2			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     2			__pushRegs ??01FA
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??01FA
			     3			else
			     3				regStack catstr ??01FA, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
			     2				mov dl, 'U'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'b'
			     2				int 21h
			     2				mov dl, 'l'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 't'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'p'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'r'
			     2				int 21h
			     2				mov dl, 's'
			     2				int 21h
			     2				mov dl, 'e'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     2				mov dl, 'c'
			     2				int 21h
			     2				mov dl, 'o'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'm'
			     2				int 21h
			     2				mov dl, 'a'
			     2				int 21h
			     2				mov dl, 'n'
			     2				int 21h
			     2				mov dl, 'd'
			     2				int 21h
			     2				mov dl, ':'
			     2				int 21h
			     2				mov dl, ' '
			     2				int 21h
			     1			RestoreRegs
			     3			??01FC instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01FC eq 0
			     3				??01FD     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??01FD substr regStack, 1, (??01FC - 1)      
			     3				regStack substr regStack, (??01FC + 1)     
			     3			endif
			     3			exitm ??01FD
			     2		for ??01FB, <dx, ax> 
			     2				pop ??01FB
			     2			endm
			     3				pop dx
			     3				pop ax
						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
				;====================================================================
				; Reading Functions
					HandleCR macro
						invoke PeekChar
						mov    bh, PeekBuffer
						.if    bh != LF
							jmp ErrorUnexpectedChar
						.endif
					endm
					
 1B15					ReadEmptyLines proc near uses ax bx cx dx bp
						invoke ReadChar
						.while ax != 0
							mov bl, FileBuffer
							.if bl == LF
								inc FileLine
								mov FileCol, 1
							.elseif bl == CR
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.else
								jmp ErrorUnexpectedChar
							.endif
							invoke ReadChar
						.endw
						ret
 1BCD					ReadEmptyLines endp
 1BCD					OpenFile proc near
						SaveRegs ax,         dx
			     1			??01FF     textequ <>
			     1			??0200 textequ <>
			     1			for       ??01FE, <ax,dx>
			     1				push  ??01FE
			     1				??0200 catstr <??01FE>, ??01FF, ??0200
			     1				??01FF catstr <, >
			     1			endm
			     2				push  ax
			     2				??0200 catstr <ax>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     2				push  dx
			     2				??0200 catstr <dx>, ??01FF, ??0200
			     2				??01FF catstr <, >
			     1			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     1			__pushRegs ??0200
			     2			size_s sizestr regStack
			     2			if     size_s eq 0
			     2				regStack catstr ??0200
			     2			else
			     2				regStack catstr ??0200, REG_SET_DELIMITER, regStack      
			     2			endif
						mov      al,         0
						lea      dx,         FileName
						mov      ah,         3dh
						int      21h
						.if (carry?)
							call ErrorOpen
						.endif
						mov      FileHandle, ax
						mov      FileIsOpen, 1
						RestoreRegs
			     2			??0202 instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??0202 eq 0
			     2				??0203     substr regStack, 1
			     2				regStack textequ <>
			     2			else
			     2				??0203 substr regStack, 1, (??0202 - 1)      
			     2				regStack substr regStack, (??0202 + 1)     
			     2			endif
			     2			exitm ??0203
			     1		for ??0201, <dx, ax> 
			     1				pop ??0201
			     1			endm
			     2				pop dx
			     2				pop ax
						ret
 1BEF					OpenFile endp
 1BEF					ReadChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
						ret
 1C0B					ReadChar endp
 1C0B					ReadCharTo proc near uses bx cx dx bp, Buffer:ptr byte
						mov dx, Buffer
						mov bx, FileHandle
						mov ah, 3Fh
						mov cx, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						; EOF
						.if ax == 0
							mov bx,           dx
							mov byte ptr[bx], 0
						.endif
						ret
 1C4F					ReadCharTo endp
 1C4F					MoveBack proc near uses ax bx cx dx bp
						; Move back by one byte
						mov bx, FileHandle
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
						mov al, 1
						int 21h
						.if (carry?)
							call ErrorRead
						.endif
						ret
 1C75					MoveBack endp
 1C75					PeekChar proc near uses bx cx dx bp
						invoke ReadCharTo, addr PeekBuffer
						invoke MoveBack
						ret
 1C89					PeekChar endp
 1C89					ReadNum proc near uses ax bx cx dx bp, result:ptr word
						invoke ReadChar
						mov    ax, 0
						mov    bx, 0
						mov    cx, 10
						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
							mul cx
							sub bl, '0'
							add ax, bx
							push   ax
							invoke ReadChar
							pop    ax
							mov    bl, FileBuffer
						.endw
						invoke MoveBack
						mov bx,           result
						mov word ptr[bx], ax
						ret
 1CF8					ReadNum endp
 1CF8					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
						ReadMatrixLoop:
							invoke ReadChar
							.if    ax == 0  ; EOF
								mov al,       TotalCol
								inc al                 ; TotalCol starts at 0
								mov NPlusOne, al
								dec al                 ; ax = N
								mov N,        al       ; TotalCol starts at 0
								dec al
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
									jmp ErrorInvalidN
								.endif
								jmp EndReading
							.endif
							mov bl, FileBuffer
							.if bl == 3Bh
								inc Col
							.elseif bl == LF
								inc FileLine
								mov FileCol, 1
								;====================================================================
								; On a new line, the number of columns should always be the same
								mov al,      Col
								.if Row == 0
									mov TotalCol, al
								.elseif TotalCol != al
									jmp ErrorColumnCount
								.endif
								;====================================================================
								; If next line is empty, all next lines should be empty
								invoke PeekChar
								mov    bh, PeekBuffer
								.if    bh == LF || bh == CR
									invoke ReadEmptyLines
								;====================================================================
								; Otherwise, next line must have data
								.else
									inc Row
									inc TotalRow
									mov Col, 0
								.endif
							.elseif bl == CR
							; accept CR only before LF
								HandleCR
			     1			invoke PeekChar
			     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
			     1				jmp ErrorUnexpectedChar
			     1			.endif
							.elseif (bl == '-')
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??0205     textequ <>
			     2			??0206 textequ <>
			     2			for       ??0204, <ax>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0206 catstr <ax>, ??0205, ??0206
			     3				??0205 catstr <, >
			     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
			     3				??0209     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)      
			     3				regStack substr regStack, (??0208 + 1)     
			     3			endif
			     3			exitm ??0209
			     2		for ??0207, <ax> 
			     2				pop ??0207
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
								neg    sword ptr [bx]
							.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
								CurrentIndexToBx
			     1			; returns in bx
			     1			SaveRegs ax
			     2			??020B     textequ <>
			     2			??020C textequ <>
			     2			for       ??020A, <ax>
			     2				push  ??020A
			     2				??020C catstr <??020A>, ??020B, ??020C
			     2				??020B catstr <, >
			     2			endm
			     3				push  ax
			     3				??020C catstr <ax>, ??020B, ??020C
			     3				??020B catstr <, >
			     2			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     2			__pushRegs ??020C
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??020C
			     3			else
			     3				regStack catstr ??020C, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      al, TotalCol
			     1			inc      al           ; TotalCol starts at 0
			     1			mov bl, Row
			     1			mov bh, Col
			     1			mul bl
			     1			add al, bh
			     1			; got index, find position in array
			     1			shl ax, 1
			     1			add ax, offset Matrix
			     1			mov bx, ax
			     1			RestoreRegs
			     3			??020E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??020E eq 0
			     3				??020F     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??020F substr regStack, 1, (??020E - 1)      
			     3				regStack substr regStack, (??020E + 1)     
			     3			endif
			     3			exitm ??020F
			     2		for ??020D, <ax> 
			     2				pop ??020D
			     2			endm
			     3				pop ax
								invoke ReadNum, bx
							.else
								jmp ErrorUnexpectedChar
							.endif
							jmp ReadMatrixLoop
						EndReading:
							CloseFileHandle
			     1			mov ah, 3eh
			     1			mov bx, FileHandle
			     1			int 21h
			     1			
			     1			mov FileIsOpen, 0 ; 0 means it is now closed
						ret
 1F53					ReadMatrix endp
				;====================================================================
				; Printf
 1F53					PrintMatrix proc near uses ax bx cx dx bp
						mov      bx, offset Matrix
						mov      dx, 8
						mov      cx, 0             ; High has row, Low has column
						.ForRow:                   ; for (row = 0; row < N; row++)
							cmp ch, N      ; row < N
							jge .EndForRow
							mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
								mov ax, sword ptr [bx]
								invoke printf_d_padded, ax, dx
								add bx, 2 ; size in bytes of a sword
								inc cl      ; col ++
								jmp .ForCol
							.EndForCol:
							putc CR
			     1			SaveRegs ax, dx
			     2			??0211     textequ <>
			     2			??0212 textequ <>
			     2			for       ??0210, <ax,dx>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0212 catstr <ax>, ??0211, ??0212
			     3				??0211 catstr <, >
			     3				push  dx
			     3				??0212 catstr <dx>, ??0211, ??0212
			     3				??0211 catstr <, >
			     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, CR
			     1			int      21h
			     1			RestoreRegs
			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
			     3				??0215     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)      
			     3				regStack substr regStack, (??0214 + 1)     
			     3			endif
			     3			exitm ??0215
			     2		for ??0213, <dx, ax> 
			     2				pop ??0213
			     2			endm
			     3				pop dx
			     3				pop ax
							putc LF
			     1			SaveRegs ax, dx
			     2			??0217     textequ <>
			     2			??0218 textequ <>
			     2			for       ??0216, <ax,dx>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
			     3				push  ax
			     3				??0218 catstr <ax>, ??0217, ??0218
			     3				??0217 catstr <, >
			     3				push  dx
			     3				??0218 catstr <dx>, ??0217, ??0218
			     3				??0217 catstr <, >
			     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack?0205,
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, LF
			     1			int      21h
			     1			RestoreRegs
			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
			     3				??021B     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)R, reg
			     3				regStack substr regStack, (??021A + 1)R, re
			     3			endif
			     3			exitm ??021B
			     2		for ??0219, <dx, ax> 
			     2				pop ??0219
			     2			endm
			     3				pop dx
			     3				pop ax
							inc ch      ; row++
							jmp .ForRow
						.EndForRow:
						ret
 1FAE					PrintMatrix endp
 1FAE					printf_s proc near uses ax bx cx dx bp, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
							mov ah, 2
							mov dl, [bx]
							int 21H
							inc bx
						.endw
						ret
 1FE9					printf_s endp
 1FE9					printf_u proc near uses ax bx cx dx bp, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
						invoke printf_s, addr buf
						ret
 2017					printf_u endp
 2017					printf_d proc near uses ax bx cx dx bp, number:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						invoke printf_s, addr buf
						ret
 2045					printf_d endp
					
 2045					printf_d_padded proc near uses ax bx cx dx bp, number:sword, padTo:sword
						local  buf[7]:byte
						invoke string_from_sword, addr buf, number
						; string_from_sword gives length on AX
						mov    cx, padTo
						sub    cx, ax
						.WHILE (sword ptr cx > 0)
							putc SPACE
			     1			SaveRegs ax, dx
			     2			??021D     textequ <>
			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
			     3				push  ax
			     3				??021E catstr <ax>, ??021D, ??021E
			     3				??021D catstr <, >
			     3				push  dx
			     3				??021E catstr <dx>, ??021D, ??021E
			     3				??021D catstr <, >
			     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
			     3			size_s sizestr regStack
			     3			if     size_s eq 0
			     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack      
			     3			endif
			     1			mov      ah, 02h
			     1			mov      dl, SPACE
			     1			int      21h
			     1			RestoreRegs
			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
			     3				??0221     substr regStack, 1
			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)      
			     3				regStack substr regStack, (??0220 + 1)     
			     3			endif
			     3			exitm ??0221
			     2		for ??021F, <dx, ax> 
			     2				pop ??021F
			     2			endm
			     3				pop dx
			     3				pop ax
							dec  cx
						.ENDW
						invoke printf_s, addr buf
						ret
 20A3					printf_d_padded endp
					; length of string goes to ax (including sign)
 20A3					string_from_sword proc near uses bx cx dx bp, string:ptr byte, number:sword
						mov dx, number
						mov bx, string
						mov cx, 0
						.if (sword ptr dx < 0)
							mov byte ptr[bx], '-'
							inc bx
							inc cx
							neg dx
						.endif
						invoke string_from_word, bx, dx
						add ax, cx
						ret
 20E6					string_from_sword endp
					; length of string goes to ax
 20E6					string_from_word proc near uses bx cx dx bp si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
						mov divisor, 10000
						mov first,   1     ; anything not 0 is true
						mov ax,    number
						mov value, ax
						mov bx, string
						mov cx, 5
						.repeat
							mov dx,    0
							mov ax,    value
							div divisor
							mov value, dx
							.if (ax != 0) || (!first) ; no zeroes on the left
								add al,            '0'
								mov byte ptr [bx], al
								inc bx
								mov first,         0
							.endif
							mov dx,      0
							mov ax,      divisor
							mov si,      10
							div si
							mov divisor, ax
						.untilcxz
						.if (first)
							mov byte ptr [bx], '0'
							inc bx
						.endif
						mov cx, string
						mov ax, bx
						sub ax, cx     ; ax = bx - string = len
						mov byte ptr [bx], 0
						ret
 2188					string_from_word endp
				;--------------------------------------------------------------------
				end
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:29:17
main.asm						     Page 1 - 1


				.model small, stdcall
				;===================================================================
				; Prototypes
					printf_s proto near, string:ptr byte
					printf_u proto near, number:word
					printf_d proto near, number:sword
					printf_d_padded proto near, number:sword, padTo:sword
				
					string_from_word proto near, string:ptr byte, number:word
					string_from_sword proto near, string:ptr byte, number:sword
				
					OpenFile       proto near
					MoveBack       proto near
					ReadCharTo     proto near, Buffer:ptr byte
					ReadChar       proto near
					PeekChar       proto near
					ReadNum        proto near, result:ptr word
					ReadEmptyLines proto near
					ReadMatrix     proto near
				
				
					ParseCommand proto near
					ReadCommand  proto near
					
					MULMatrix proto near, LINHA:byte, CONSTANTE: sword
					DIVMatrix proto near, LINHA:byte, CONSTANTE: sword
				
					ADDMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
					SUBMatrix proto near, LINHA_DST:byte, LINHA_ORG: byte
				
					WRITEMatrix proto near, NOME:ptr byte
				
					PrintMatrix proto near
				
				;====================================================================
				; Memory
						.stack
 0000						.data
					
				
 = 0000					CMD_NONE  EQU 0
 = 0001					CMD_MUL   EQU 1
 = 0002					CMD_DIV   EQU 2
 = 0003					CMD_ADD   EQU 3
 = 0004					CMD_SUB   EQU 4
 = 0005					CMD_UNDO  EQU 5
 = 0006					CMD_WRITE EQU 6
				
 = 000D					CR            equ 0dh
 = 000A					LF            equ 0ah
 = 0022					QUOT          equ 22h
 = 003B					SEMI          equ 3Bh
 = SEMI					COL_SEPARATOR equ SEMI
 = 0020					SPACE         equ 20h
				
 0000 3B 00				COLUMN_SEP db ";",0
 0002 0D 0A 00				CRLF       db CR, LF, 0
				
 = 0064					BuffSize       equ 100              ; tam. m√°ximo dos dados lidos no buffer
 0005 4D 41 54 2E 74 78			FileName       db  "MAT.txt",0      ; Nome do arquivo a ser lido
       74 00
 000D  0064 [				FileBuffer     db  BuffSize dup (?) ; Buffer de leitura do arquivo
        00
       ]
 0071 0000				FileHandle     dw  0                ; Handler do arquivo
 0073 00				FileIsOpen     db  0                ; closed at the start
 0074  0096 [				FileNameBuffer db  150 dup (?)
        00
       ]
 010A 00				caractere      db  0
				
 010B FE				CommandBuffer       db 254
 010C 00				CommandBufferLength db 0          ; max length, actual length
 010D  00FE [				CommandBufferString db 254 dup(0)
        00
       ]
				
 020B 00				LastCommand   db 0
 020C 0000				LastCommand@a dw 0
 020E 0000				LastCommand@b sword 0
 0210 00				LastCommand@exists db 0
				
				
 0211  00FF [				NonTerminalErrorBuffer db 255 dup(0)
        00
       ]
				
 0310 43 6F 6D 61 6E 64			@Comando      db "Comando",0
       6F 00
 0318 65 73 70 65 72 61			@espera       db "espera",0
       00
 031F 63 6F 6D 6F 00			@como         db "como",0
 0324 70 61 72 61 6D 65			@parametro    db "parametro",0
       74 72 6F 00
 032E 50 61 72 61 6D 65			@@parametro   db "Parametro",0
       74 72 6F 00
 0338 64 65 73 63 6F 6E			@desconhecido db "desconhecido",0
       68 65 63 69 64 6F
       00
 0345 20 00				@space        db " ",0
				
 0347 64 65 76 65 20 65			@deve_estar_entre_1_e_N                           db "deve estar entre 1 e N",0
       73 74 61 72 20 65
       6E 74 72 65 20 31
       20 65 20 4E 00
 035E 4E 61 6F 20 66 6F			@@nao_foi_possivel_abrir_ou_criar_o_arquivo       db "Nao foi possivel abrir ou criar o arquivo",0
       69 20 70 6F 73 73
       69 76 65 6C 20 61
       62 72 69 72 20 6F
       75 20 63 72 69 61
       72 20 6F 20 61 72
       71 75 69 76 6F 00
 0388 50 61 72 61 6D 65			@@parametros_nao_reconhecidos_ao_final_do_comando db "Parametros nao reconhecidos ao final do comando",0
       74 72 6F 73 20 6E
       61 6F 20 72 65 63
       6F 6E 68 65 63 69
       64 6F 73 20 61 6F
       20 66 69 6E 61 6C
       20 64 6F 20 63 6F
       6D 61 6E 64 6F 00
					
 03B8 3A 20 00				COLON_SPACE db ": ",0
				
 = COLON_SPACE				ExplanationSeparator textequ <COLON_SPACE>
				
				
					; Used on PeekChar
 03BB 00				PeekBuffer        db ?
					; Used when reporting the error
 03BC 00 22 00				TheUnexpectedChar db 0,QUOT,0
					; used in main
 03BF 0001				FileCol           dw 1
 03C1 0001				FileLine          dw 1
				
 03C3 00				Row      byte 0
 03C4 00				Col      byte 0
 03C5 00				TotalRow byte 0
 03C6 00				TotalCol byte 0
				
 03C7 00				N        byte 0
 03C8 00				NPlusOne byte 0
					; should be at most 7x7
 03C9  0031 [				Matrix   sword (7 * 7) dup (?)
        0000
       ]
				
				;====================================================================
				; Macros
				;--------------------------------------------------------------------
				; Save and restore registers
 = <					OPEN_DELIMITER    textequ <!<>
 = >					CLOSE_DELIMITER   textequ <!>>
 = |					REG_SET_DELIMITER textequ <|>
				
 = 					regStack textequ <> ; starts empty
				
					__popRegs macro
						local regs_end, regs		regs_end instr 1, regStack, REG_SET_DELIMITER
						if    regs_end eq 0
							regs     substr regStack, 1
							regStack textequ <>
						else			regs substr regStack, 1, (regs_end - 1)
							regStack substr regStack, (regs_end + 1)
						endif		exitm regs
					endm
				
					__pushRegs macro regs:req
						size_s sizestr regStack
						if     size_s eq 0
							regStack catstr regs
						else			regStack catstr regs, REG_SET_DELIMITER, regStack
						endif	endm
				
					SaveRegs macro regs:vararg
						local reg, comma, regpushed		comma     textequ <>
						regpushed textequ <>
						for       reg, <regs>
							push  reg
							regpushed catstr <reg>, comma, regpushed
							comma catstr <, >
						endm
						regpushed catstr OPEN_DELIMITER, regpushed, CLOSE_DELIMITER
						__pushRegs regpushed
					endm
				
					RestoreRegs macro
						local reg	%	for reg, __popRegs(regStack) ;; Pop each register
							pop reg
						endm
					endm
				
					RegsInvokeUses textequ <ax bx cx dx bp>
				
					RegsReturningOnAX textequ <bx cx dx bp>
					RegsReturningOnBX textequ <ax cx dx bp>
				;--------------------------------------------------------------------
				; Prints
					putc macro c:req
 = ax bx cx dx bp				SaveRegs ax, dx
						mov      ah, 02h		mov      dl, c
 = bx cx dx bp					int      21h		RestoreRegs
 = ax cx dx bp				endm
				
					printf_c macro string:req
						SaveRegs ax,   dx
						mov      ah,   02h		forc     char, <string>
							mov dl, '&char'
							int 21h
						endm
						RestoreRegs
					endm
				
					strcpy_c macro src:req, dst:req
						ifdifi <dst>, <di>
							lea di, dst
						endif
						forc char, <src>
							mov byte ptr [di], '&char'
							inc di
						endm
						mov byte ptr [di], 0	endm
				
					strcpy macro src:req, dst:req
						SaveRegs ax
						ifdifi   <src>, <si>
							lea si, src
						endif		ifdifi <dst>, <di>
							lea di, dst
						endif		.repeat			mov al,   [si]			mov [di], al			inc si			inc di		.until (al == 0)		dec    si		dec    di		RestoreRegs
					endm
				
					DEFINED MACRO symbol:REQ
						IFDEF symbol
							EXITM <-1> ; True
						ELSE			EXITM <0> ; False
						ENDIF	ENDM
				
					strcpy_all macro dst:req, strings:vararg
						ifdifi <dst>, <di>
							lea di, dst
						endif		for string, <strings>
							if DEFINED(string)
								strcpy string, di
							else
								strcpy_c <string>, di
							endif
						endm
					endm
				
					print_Pair macro line:req, col:req
						printf_c <(>
						invoke   printf_u, line
						printf_c <:>
						invoke   printf_u, col
						printf_c <)>
					endm
				
					print_FilePosition macro
						print_Pair FileLine, FileCol
					endm
				
					print_TotalRowCol macro
						print_Pair TotalRow, TotalCol
					endm
				
				;--------------------------------------------------------------------
				; Miscellaneous
				
					ErrorCommandExpectsNumber macro command:req, paramName:req, positionName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@Comando, !< &command !>, @espera, !< &paramName !>, @como, !< &positionName !>, @parametro, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorNumberOutOfBounds macro paramName:req
						strcpy_all NonTerminalErrorBuffer, \
						<@@parametro, !< &paramName !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
					endm
				
					ErrorCantOpenNorCreate macro
						strcpy_all                                    NonTerminalErrorBuffer, \
						<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
					endm
				
					CloseFileHandle macro
						mov ah, 3eh		mov bx, FileHandle		int 21h				mov FileIsOpen, 0 ; 0 means it is now closed	endm
				
					CurrentIndexToBx macro
						; returns in bx		SaveRegs ax
						mov      al, TotalCol		inc      al           ; TotalCol starts at 0
						mov bl, Row		mov bh, Col
						mul bl		add al, bh
						; got index, find position in array
						shl ax, 1		add ax, offset Matrix
						mov bx, ax
						RestoreRegs
					endm
				
				;====================================================================
				; Program
					.code
					.startup
					invoke ReadMatrix
					@whiletrue:
						invoke PrintMatrix
						@SkipPrint:
						invoke ReadCommand
						@Validate:
							jnc    @ValidCommand
							invoke printf_s,      addr NonTerminalErrorBuffer
							lea    bx,            NonTerminalErrorBuffer
							mov    byte ptr [bx], 0
							putc   CR
							putc   LF
							invoke ReadCommand
							jmp    @Validate
						@ValidCommand:
				
						.if (ax == CMD_ADD)
							call Main@ADD
						.elseif  (ax == CMD_MUL)
							call Main@MUL
						.elseif (ax == CMD_UNDO)
							call Main@UNDO
						.elseif (ax == CMD_WRITE)
							call Main@WRITE
							jmp  @SkipPrint
						.endif
				
						jmp ExitSuccess
						
						@MainLoopEnd:
						putc CR
						putc LF
					jmp @whiletrue
				
					Main@ADD proc near
						mov LastCommand,        CMD_ADD
						mov bh,                 0
						mov LastCommand@a,      bx
						mov ch,                 0
 0000						mov LastCommand@b,      cx
						mov LastCommand@exists, 1
 0000			   *@Startup:
 0000  BA ---- R	   *	    mov    dx, DGROUP
 0003  8E DA		   *	    mov    ds, dx
 0005  8C D3		   *	    mov    bx, ss
 0007  2B DA		   *	    sub    bx, dx
 0009  D1 E3		   *	    shl    bx, 001h
 000B  D1 E3		   *	    shl    bx, 001h
 000D  D1 E3		   *	    shl    bx, 001h
 000F  D1 E3		   *	    shl    bx, 001h
 0011  FA		   *	    cli    
 0012  8E D2		   *	    mov    ss, dx
 0014  03 E3		   *	    add    sp, bx
 0016  FB		   *	    sti    
				
 0017  E8 1308		   *	    call   ReadMatrix
 001A						invoke ADDMatrix, bl, cl
				
 001A  E8 141B		   *	    call   PrintMatrix
 001D						ret
					Main@ADD endp
 001D  E8 033E		   *	    call   ReadCommand
 0020					Main@MUL proc near
 0020  73 28					mov LastCommand,        CMD_MUL
						mov bh,                 0
 0022  8D 06 0211 R	   *	    lea    ax, NonTerminalErrorBuffer
 0026  50		   *	    push   ax
 0027  E8 1456		   *	    call   printf_s
 002A  8D 1E 0211 R				mov LastCommand@a,      bx
 002E  C6 07 00					mov LastCommand@b,      sword ptr cx
						mov LastCommand@exists, 1
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0001     textequ <>
 = 			     2			??0002 textequ <>
			     2			for       ??0000, <ax,dx>
			     2				push  ??0000
			     2				??0002 catstr <??0000>, ??0001, ??0002
			     2				??0001 catstr <, >
			     2			endm
 0031  50		     3				push  ax
 = ax			     3				??0002 catstr <ax>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 0032  52		     3				push  dx
 = dx, ax		     3				??0002 catstr <dx>, ??0001, ??0002
 = , 			     3				??0001 catstr <, >
 = <dx, ax>		     2			??0002 catstr OPEN_DELIMITER, ??0002, CLOSE_DELIMITER
			     2			__pushRegs ??0002
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0002
			     3			else
			     3				regStack catstr ??0002, REG_SET_DELIMITER, regStack
			     3			endif
 0033  B4 02		     1			mov      ah, 02h
 0035  B2 0D		     1			mov      dl, CR
 0037  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0004 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0004 eq 0
 = <dx, ax>		     3				??0005     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0005 substr regStack, 1, (??0004 - 1)
			     3				regStack substr regStack, (??0004 + 1)
			     3			endif
			     3			exitm ??0005
			     2		%	for ??0003, __popRegs(regStack) 
			     2				pop ??0003
			     2			endm
 0039  5A		     3				pop dx
 003A  58		     3				pop ax
				
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0007     textequ <>
 = 			     2			??0008 textequ <>
			     2			for       ??0006, <ax,dx>
			     2				push  ??0006
			     2				??0008 catstr <??0006>, ??0007, ??0008
			     2				??0007 catstr <, >
			     2			endm
 003B  50		     3				push  ax
 = ax			     3				??0008 catstr <ax>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 003C  52		     3				push  dx
 = dx, ax		     3				??0008 catstr <dx>, ??0007, ??0008
 = , 			     3				??0007 catstr <, >
 = <dx, ax>		     2			??0008 catstr OPEN_DELIMITER, ??0008, CLOSE_DELIMITER
			     2			__pushRegs ??0008
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0008
			     3			else
			     3				regStack catstr ??0008, REG_SET_DELIMITER, regStack
			     3			endif
 003D  B4 02		     1			mov      ah, 02h
 003F  B2 0A		     1			mov      dl, LF
 0041  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??000A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??000A eq 0
 = <dx, ax>		     3				??000B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??000B substr regStack, 1, (??000A - 1)
			     3				regStack substr regStack, (??000A + 1)
			     3			endif
			     3			exitm ??000B
			     2		%	for ??0009, __popRegs(regStack) 
			     2				pop ??0009
			     2			endm
 0043  5A		     3				pop dx
 0044  58		     3				pop ax
						invoke MULMatrix, bl, cx
 0045  E8 0316		   *	    call   ReadCommand
 0048  EB D6					ret
 004A					Main@MUL endp
					Main@UNDO proc near
						mov al, LastCommand@exists
 004A  83 F8 03		   *	    cmp    ax, CMD_ADD
 004D  75 05		   *	    jne    @C0001
 004F  E8 0039					.if !al
							jmp @MainLoopEnd
 0052  EB 1E		   *	    jmp    @C0003
 0054			   *@C0001:
 0054  83 F8 01		   *	    cmp    ax, CMD_MUL
 0057  75 05		   *	    jne    @C0004
 0059  E8 004F					.endif
						mov al,           LastCommand
 005C  EB 14		   *	    jmp    @C0006
 005E			   *@C0004:
 005E  83 F8 05		   *	    cmp    ax, CMD_UNDO
 0061  75 05		   *	    jne    @C0007
 0063  E8 0061					mov bx,           LastCommand@a
						mov sword ptr cx, LastCommand@b
 0066  EB 0A		   *	    jmp    @C0009
 0068			   *@C0007:
 0068  83 F8 06		   *	    cmp    ax, CMD_WRITE
 006B  75 05		   *	    jne    @C000A
 006D  E8 00B6					.if (al == CMD_ADD)
 0070  EB AB						invoke SUBMatrix, bl, cl
							mov LastCommand, CMD_SUB
 0072			   *@C000A:
 0072			   *@C0009:
 0072			   *@C0006:
 0072			   *@C0003:
						.elseif (al == CMD_MUL)
 0072  E9 02C6						invoke DIVMatrix, bl, cx
							mov LastCommand, CMD_DIV
 0075						.elseif (al == CMD_SUB)
							invoke ADDMatrix, bl, cl
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??000D     textequ <>
 = 			     2			??000E textequ <>
			     2			for       ??000C, <ax,dx>
			     2				push  ??000C
			     2				??000E catstr <??000C>, ??000D, ??000E
			     2				??000D catstr <, >
			     2			endm
 0075  50		     3				push  ax
 = ax			     3				??000E catstr <ax>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 0076  52		     3				push  dx
 = dx, ax		     3				??000E catstr <dx>, ??000D, ??000E
 = , 			     3				??000D catstr <, >
 = <dx, ax>		     2			??000E catstr OPEN_DELIMITER, ??000E, CLOSE_DELIMITER
			     2			__pushRegs ??000E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??000E
			     3			else
			     3				regStack catstr ??000E, REG_SET_DELIMITER, regStack
			     3			endif
 0077  B4 02		     1			mov      ah, 02h
 0079  B2 0D		     1			mov      dl, CR
 007B  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0010 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0010 eq 0
 = <dx, ax>		     3				??0011     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0011 substr regStack, 1, (??0010 - 1)
			     3				regStack substr regStack, (??0010 + 1)
			     3			endif
			     3			exitm ??0011
			     2		%	for ??000F, __popRegs(regStack) 
			     2				pop ??000F
			     2			endm
 007D  5A		     3				pop dx
 007E  58		     3				pop ax
							mov LastCommand, CMD_ADD
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0013     textequ <>
 = 			     2			??0014 textequ <>
			     2			for       ??0012, <ax,dx>
			     2				push  ??0012
			     2				??0014 catstr <??0012>, ??0013, ??0014
			     2				??0013 catstr <, >
			     2			endm
 007F  50		     3				push  ax
 = ax			     3				??0014 catstr <ax>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 0080  52		     3				push  dx
 = dx, ax		     3				??0014 catstr <dx>, ??0013, ??0014
 = , 			     3				??0013 catstr <, >
 = <dx, ax>		     2			??0014 catstr OPEN_DELIMITER, ??0014, CLOSE_DELIMITER
			     2			__pushRegs ??0014
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0014
			     3			else
			     3				regStack catstr ??0014, REG_SET_DELIMITER, regStack
			     3			endif
 0081  B4 02		     1			mov      ah, 02h
 0083  B2 0A		     1			mov      dl, LF
 0085  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0016 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0016 eq 0
 = <dx, ax>		     3				??0017     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0017 substr regStack, 1, (??0016 - 1)
			     3				regStack substr regStack, (??0016 + 1)
			     3			endif
			     3			exitm ??0017
			     2		%	for ??0015, __popRegs(regStack) 
			     2				pop ??0015
			     2			endm
 0087  5A		     3				pop dx
 0088  58		     3				pop ax
 0089  EB 8F					.elseif (al == CMD_DIV)
							invoke MULMatrix, bl, cx
 008B							mov LastCommand, CMD_MUL
 008B  C6 06 020B R 03				.endif
 0090  B7 00					ret
 0092  89 1E 020C R			Main@UNDO  endp
 0096  B5 00				Main@WRITE proc near
 0098  89 0E 020E R				invoke WRITEMatrix, dx
 009C  C6 06 0210 R 01				ret
					Main@WRITE endp
				
 00A1  8A C1		   *	    mov    al, cl
 00A3  50		   *	    push   ax
 00A4  8A C3		   *	    mov    al, bl
 00A6  50		   *	    push   ax
 00A7  E8 00F0		   *	    call   ADDMatrix
				
 00AA  C3			;====================================================================
 00AB				; MUL
 00AB					MULMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
 00AB  C6 06 020B R 01				mov al, LINHA
 00B0  B7 00					dec al
 00B2  89 1E 020C R				mov bl, TotalCol
 00B6  89 0E 020E R				inc bl
 00BA  C6 06 0210 R 01				mul bl
				
						shl ax, 1
 00BF  51		   *	    push   cx
 00C0  8A C3		   *	    mov    al, bl
 00C2  50		   *	    push   ax
 00C3  E8 0065		   *	    call   MULMatrix
 00C6  C3			
 00C7						mov bx, offset Matrix
 00C7						add bx, ax
 00C7  A0 0210 R		
						mov ch, 0
 00CA  0A C0		   *	    or	al, al
 00CC  75 02		   *	    jne    @C000C
 00CE  EB A5					mov cl, NPlusOne
				
 00D0			   *@C000C:
 00D0  A0 020B R				MULMatrix@Loop:
 00D3  8B 1E 020C R					mov  ax,             sword ptr [bx]
 00D7  8B 0E 020E R					imul CONSTANTE
							mov  sword ptr [bx], ax
 00DB  3C 03		   *	    cmp    al, CMD_ADD
 00DD  75 10		   *	    jne    @C000E
				
 00DF  8A C1		   *	    mov    al, cl
 00E1  50		   *	    push   ax
 00E2  8A C3		   *	    mov    al, bl
 00E4  50		   *	    push   ax
 00E5  E8 0105		   *	    call   SUBMatrix
 00E8  C6 06 020B R 04					add  bx, 2
							loop MULMatrix@Loop
 00ED  EB 36		   *	    jmp    @C0010
 00EF			   *@C000E:
 00EF  3C 01		   *	    cmp    al, CMD_MUL
 00F1  75 0E		   *	    jne    @C0011
				
 00F3  51		   *	    push   cx
 00F4  8A C3		   *	    mov    al, bl
 00F6  50		   *	    push   ax
 00F7  E8 0068		   *	    call   DIVMatrix
 00FA  C6 06 020B R 02				ret
					MULMatrix endp
 00FF  EB 24		   *	    jmp    @C0013
 0101			   *@C0011:
 0101  3C 04		   *	    cmp    al, CMD_SUB
 0103  75 10		   *	    jne    @C0014
				
 0105  8A C1		   *	    mov    al, cl
 0107  50		   *	    push   ax
 0108  8A C3		   *	    mov    al, bl
 010A  50		   *	    push   ax
 010B  E8 008C		   *	    call   ADDMatrix
 010E  C6 06 020B R 03			DIVMatrix proc near uses RegsInvokeUses, LINHA:byte, CONSTANTE: sword
						mov al, LINHA
 0113  EB 10		   *	    jmp    @C0016
 0115			   *@C0014:
 0115  3C 02		   *	    cmp    al, CMD_DIV
 0117  75 0C		   *	    jne    @C0017
						dec al
 0119  51		   *	    push   cx
 011A  8A C3		   *	    mov    al, bl
 011C  50		   *	    push   ax
 011D  E8 000B		   *	    call   MULMatrix
 0120  C6 06 020B R 01				mov bl, TotalCol
						inc bl
 0125			   *@C0017:
 0125			   *@C0016:
 0125			   *@C0013:
 0125			   *@C0010:
 0125  C3					mul bl
 0126				
 0126						shl ax, 1
				
 0126  52		   *	    push   dx
 0127  E8 0116		   *	    call   WRITEMatrix
 012A  C3					mov bx, offset Matrix
 012B						add bx, ax
				
						mov ch, 0
						mov cl, NPlusOne
						DIVMatrix@Loop:
 012B							mov ax, sword ptr [bx]
 012B  55		   *	    push   bp
 012C  8B EC		   *	    mov    bp, sp
 012E  50		   *	    push   ax
 012F  53		   *	    push   bx
 0130  51		   *	    push   cx
 0131  52		   *	    push   dx
 0132  55		   *	    push   bp
 0133  8A 46 04						cwd                    ; extend sign to dx
 0136  FE C8						
 0138  8A 1E 03C6 R					idiv CONSTANTE
 013C  FE C3						
 013E  F6 E3						mov sword ptr [bx], ax
				
 0140  D1 E0						add  bx, 2
							loop DIVMatrix@Loop
 0142  BB 03C9 R		
 0145  03 D8					ret
					DIVMatrix endp
 0147  B5 00			
 0149  8A 0E 03C8 R		;====================================================================
				; ADD
 014D					ADDMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
 014D  8B 07			
 014F  F7 6E 06					mov al, LINHA_DST
 0152  89 07					dec al
						mov bl, TotalCol
 0154  83 C3 02					inc bl
 0157  E2 F4					mul bl
						shl ax, 1
						
 0159  5D		   *	    pop    bp
 015A  5A		   *	    pop    dx
 015B  59		   *	    pop    cx
 015C  5B		   *	    pop    bx
 015D  58		   *	    pop    ax
 015E  5D		   *	    pop    bp
 015F  C2 0004		   *	    ret    00004h
 0162						lea di, Matrix
						add di, ax
 0162				
 0162  55		   *	    push   bp
 0163  8B EC		   *	    mov    bp, sp
 0165  50		   *	    push   ax
 0166  53		   *	    push   bx
 0167  51		   *	    push   cx
 0168  52		   *	    push   dx
 0169  55		   *	    push   bp
 016A  8A 46 04			
 016D  FE C8					mov al, LINHA_ORG
 016F  8A 1E 03C6 R				dec al
 0173  FE C3					mov bl, TotalCol
 0175  F6 E3					inc bl
						mul bl
 0177  D1 E0					shl ax, 1
				
 0179  BB 03C9 R				lea si, Matrix
 017C  03 D8					add si, ax
				
 017E  B5 00					mov ch, 0
 0180  8A 0E 03C8 R				mov cl, NPlusOne
 0184						ADDMatrix@Loop:
 0184  8B 07						mov ax,   [di]
 0186  99						add ax,   [si]
							mov [di], ax
 0187  F7 7E 06			
							add  di, 2
 018A  89 07						add  si, 2
							loop ADDMatrix@Loop
 018C  83 C3 02			
 018F  E2 F3					ret
					ADDMatrix endp
				
 0191  5D		   *	    pop    bp
 0192  5A		   *	    pop    dx
 0193  59		   *	    pop    cx
 0194  5B		   *	    pop    bx
 0195  58		   *	    pop    ax
 0196  5D		   *	    pop    bp
 0197  C2 0004		   *	    ret    00004h
 019A					SUBMatrix proc near uses RegsInvokeUses di si, LINHA_DST:byte, LINHA_ORG: byte
				
						mov al, LINHA_DST
						dec al
 019A						mov bl, TotalCol
						inc bl
 019A  55		   *	    push   bp
 019B  8B EC		   *	    mov    bp, sp
 019D  50		   *	    push   ax
 019E  53		   *	    push   bx
 019F  51		   *	    push   cx
 01A0  52		   *	    push   dx
 01A1  55		   *	    push   bp
 01A2  57		   *	    push   di
 01A3  56		   *	    push   si
 01A4  8A 46 04					mul bl
 01A7  FE C8					shl ax, 1
 01A9  8A 1E 03C6 R				
 01AD  FE C3					lea di, Matrix
 01AF  F6 E3					add di, ax
 01B1  D1 E0			
				
 01B3  8D 3E 03C9 R				mov al, LINHA_ORG
 01B7  03 F8					dec al
						mov bl, TotalCol
						inc bl
 01B9  8A 46 06					mul bl
 01BC  FE C8					shl ax, 1
 01BE  8A 1E 03C6 R		
 01C2  FE C3					lea si, Matrix
 01C4  F6 E3					add si, ax
 01C6  D1 E0			
						mov ch, 0
 01C8  8D 36 03C9 R				mov cl, NPlusOne
 01CC  03 F0					SUBMatrix@Loop:
							mov ax,   [di]
 01CE  B5 00						sub ax,   [si]
 01D0  8A 0E 03C8 R					mov [di], ax
 01D4				
 01D4  8B 05						add  di, 2
 01D6  03 04						add  si, 2
 01D8  89 05						loop SUBMatrix@Loop
				
 01DA  83 C7 02					ret
 01DD  83 C6 02				SUBMatrix endp
 01E0  E2 F2			
				;====================================================================
				; WRITE
 01E2  5E		   *	    pop    si
 01E3  5F		   *	    pop    di
 01E4  5D		   *	    pop    bp
 01E5  5A		   *	    pop    dx
 01E6  59		   *	    pop    cx
 01E7  5B		   *	    pop    bx
 01E8  58		   *	    pop    ax
 01E9  5D		   *	    pop    bp
 01EA  C2 0004		   *	    ret    00004h
 01ED				
					WriteToFile macro handle:req, offset_buf:req, len:req
 01ED						SaveRegs bx, cx, dx
						mov cx, len
 01ED  55		   *	    push   bp
 01EE  8B EC		   *	    mov    bp, sp
 01F0  50		   *	    push   ax
 01F1  53		   *	    push   bx
 01F2  51		   *	    push   cx
 01F3  52		   *	    push   dx
 01F4  55		   *	    push   bp
 01F5  57		   *	    push   di
 01F6  56		   *	    push   si
 01F7  8A 46 04					mov bx, handle
 01FA  FE C8					lea dx, offset_buf
 01FC  8A 1E 03C6 R				mov ah, 40h		int 21h
 0200  FE C3					RestoreRegs
 0202  F6 E3				endm
 0204  D1 E0				WRITEMatrix proc near uses RegsInvokeUses di si, NOME:ptr byte
						local buf[7]:byte, handle:word
 0206  8D 3E 03C9 R				mov   ah,          3Dh         ; open
 020A  03 F8					mov   al,          02h         ; read/write
						mov   dx,          NOME
						int   21h
 020C  8A 46 06					jc    create_file              ; if not exists
 020F  FE C8			
 0211  8A 1E 03C6 R				mov bx, ax      ; BX = file handle
 0215  FE C3					jmp file_opened
 0217  F6 E3			
 0219  D1 E0					create_file:
						mov ah, 3Ch  ; create
 021B  8D 36 03C9 R				mov cx, 0
 021F  03 F0					mov dx, NOME
						int 21h
 0221  B5 00					mov bx, ax
 0223  8A 0E 03C8 R		
 0227						file_opened:
 0227  8B 05					mov ah, 42h
 0229  2B 04					mov al, 02h ; SEEK_END
 022B  89 05					xor cx, cx
						xor dx, dx
 022D  83 C7 02					int 21h
 0230  83 C6 02			
 0233  E2 F2					.if (carry?)
							ErrorCantOpenNorCreate
							stc
 0235  5E		   *	    pop    si
 0236  5F		   *	    pop    di
 0237  5D		   *	    pop    bp
 0238  5A		   *	    pop    dx
 0239  59		   *	    pop    cx
 023A  5B		   *	    pop    bx
 023B  58		   *	    pop    ax
 023C  5D		   *	    pop    bp
 023D  C2 0004		   *	    ret    00004h
 0240							ret
						.endif
				
						mov handle, bx
						mov bx,     0  ; Low tells if its not first column
				
						mov di, offset Matrix
						mov cx, 0             ; High has row, Low has column
						
						WRITEMatrix@ForRow: ; for (row = 0; row < N; row++)
							cmp ch, N                 ; row < N
							jge WRITEMatrix@EndForRow
				
							mov bl, 0 ; new first column
							mov cl, 0 ; col = 0
							
 0240							WRITEMatrix@ForCol: ; for (col = 0; col < NPlusOne; col++)
								cmp cl, NPlusOne          ; col < NPlusOne
 0240  55		   *	    push   bp
 0241  8B EC		   *	    mov    bp, sp
 0243  83 C4 F6		   *	    add    sp, 0FFF6h
 0246  50		   *	    push   ax
 0247  53		   *	    push   bx
 0248  51		   *	    push   cx
 0249  52		   *	    push   dx
 024A  55		   *	    push   bp
 024B  57		   *	    push   di
 024C  56		   *	    push   si
 024D  B4 3D							jge WRITEMatrix@EndForCol
 024F  B0 02			
 0251  8B 56 04							.if (bl) ; no longer firstCol?
 0254  CD 21								WriteToFile handle, COLUMN_SEP, 1
 0256  72 04							.endif
				
 0258  8B D8							mov ax, sword ptr [di]
 025A  EB 0C			
								invoke string_from_sword, addr buf, ax ; ax now has length
 025C				
 025C  B4 3C							WriteToFile handle, buf, ax
 025E  B9 0000			
 0261  8B 56 04							add di, 2 ; size in bytes of a sword
 0264  CD 21			
 0266  8B D8							mov bl, 1 ; no longer first col
								inc cl    ; col ++
 0268								
 0268  B4 42							jmp WRITEMatrix@ForCol
 026A  B0 02						WRITEMatrix@EndForCol:
 026C  33 C9			
 026E  33 D2						WriteToFile handle, CRLF, 2
 0270  CD 21			
							inc ch ; row++
							
 0272  73 48		   *	    jae    @C0019
							jmp WRITEMatrix@ForRow
			     1			strcpy_all                                    NonTerminalErrorBuffer, \
			     2			<@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
 0274  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@nao_foi_possivel_abrir_ou_criar_o_arquivo, ExplanationSeparator,   CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     3				EXITM <-1> 
			     3				if DEFINED(@@nao_foi_possivel_abrir_ou_criar_o_arquivo)
			     4					strcpy @@nao_foi_possivel_abrir_ou_criar_o_arquivo, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0019     textequ <>
			     5			??001A textequ <>
			     5			for       ??0018, <ax>
			     5				push  ??0018
			     5				??001A catstr <??0018>, ??0019, ??001A
			     5				??0019 catstr <, >
 0278  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??001A catstr <ax>, ??0019, ??001A
 = <ax>			     5				??0019 catstr <, >
			     5			??001A catstr OPEN_DELIMITER, ??001A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??001A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??001A
			     6			else
			     6				regStack catstr ??001A, REG_SET_DELIMITER, regStack
			     4			endif
 0279  8D 36 035E R	     4			ifdifi   <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, <si>
			     4				lea si, @@nao_foi_possivel_abrir_ou_criar_o_arquivo
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 027D			   *@C001B:
			     4			endif
 027D  8A 04		     4			.repeat
 027F  88 05		     4				mov al,   [si]
 0281  46		     4				mov [di], al
 0282  47		     4				inc si
 0283  0A C0		   *	    or	al, al
 0285  75 F6		   *	    jne    @C001B
			     4				inc di
 0287  4E		     4			.until (al == 0)
 0288  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??001C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??001C eq 0
 = 			     6				??001D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??001D substr regStack, 1, (??001C - 1)
			     6				regStack substr regStack, (??001C + 1)
			     6			endif
			     5			exitm ??001D
			     5		%	for ??001B, __popRegs(regStack) 
			     5				pop ??001B
 0289  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@nao_foi_possivel_abrir_ou_criar_o_arquivo>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??001F     textequ <>
			     5			??0020 textequ <>
			     5			for       ??001E, <ax>
			     5				push  ??001E
			     5				??0020 catstr <??001E>, ??001F, ??0020
			     5				??001F catstr <, >
 028A  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0020 catstr <ax>, ??001F, ??0020
 = <ax>			     5				??001F catstr <, >
			     5			??0020 catstr OPEN_DELIMITER, ??0020, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0020
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0020
			     6			else
			     6				regStack catstr ??0020, REG_SET_DELIMITER, regStack
			     4			endif
 028B  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 028F			   *@C001D:
			     4			endif
 028F  8A 04		     4			.repeat
 0291  88 05		     4				mov al,   [si]
 0293  46		     4				mov [di], al
 0294  47		     4				inc si
 0295  0A C0		   *	    or	al, al
 0297  75 F6		   *	    jne    @C001D
			     4				inc di
 0299  4E		     4			.until (al == 0)
 029A  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0022 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0022 eq 0
 = 			     6				??0023     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0023 substr regStack, 1, (??0022 - 1)
			     6				regStack substr regStack, (??0022 + 1)
			     6			endif
			     5			exitm ??0023
			     5		%	for ??0021, __popRegs(regStack) 
			     5				pop ??0021
 029B  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0025     textequ <>
			     5			??0026 textequ <>
			     5			for       ??0024, <ax>
			     5				push  ??0024
			     5				??0026 catstr <??0024>, ??0025, ??0026
			     5				??0025 catstr <, >
 029C  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0026 catstr <ax>, ??0025, ??0026
 = <ax>			     5				??0025 catstr <, >
			     5			??0026 catstr OPEN_DELIMITER, ??0026, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0026
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0026
			     6			else
			     6				regStack catstr ??0026, REG_SET_DELIMITER, regStack
			     4			endif
 029D  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 02A1			   *@C001F:
			     4			endif
 02A1  8A 04		     4			.repeat
 02A3  88 05		     4				mov al,   [si]
 02A5  46		     4				mov [di], al
 02A6  47		     4				inc si
 02A7  0A C0		   *	    or	al, al
 02A9  75 F6		   *	    jne    @C001F
			     4				inc di
 02AB  4E		     4			.until (al == 0)
 02AC  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0028 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0028 eq 0
 = 			     6				??0029     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0029 substr regStack, 1, (??0028 - 1)
			     6				regStack substr regStack, (??0028 + 1)
			     6			endif
			     5			exitm ??0029
			     5		%	for ??0027, __popRegs(regStack) 
			     5				pop ??0027
 02AD  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 02AE  F9					WRITEMatrix@EndForRow:
				
 02AF  5E		   *	    pop    si
 02B0  5F		   *	    pop    di
 02B1  5D		   *	    pop    bp
 02B2  5A		   *	    pop    dx
 02B3  59		   *	    pop    cx
 02B4  5B		   *	    pop    bx
 02B5  58		   *	    pop    ax
 02B6  8B E5		   *	    mov    sp, bp
 02B8  5D		   *	    pop    bp
 02B9  C2 0002		   *	    ret    00002h
						clc
 02BC			   *@C0019:
						ret
 02BC  89 5E F6				WRITEMatrix endp
 02BF  BB 0000			;====================================================================
				; Exiting
 02C2  BF 03C9 R		
 02C5  B9 0000				ExitSuccess proc near
						mov al, 0
 02C8						jmp ExitAndClose
 02C8  3A 2E 03C7 R				ret
 02CC  7D 5F				ExitSuccess endp
				
 02CE  B3 00				ExitFailure proc near
 02D0  B1 00					mov al, 1
						jmp ExitAndClose
 02D2						ret
 02D2  3A 0E 03C8 R			ExitFailure endp
 02D6  7D 3D			
					ExitAndClose proc near
						.if (FileIsOpen)
 02D8  0A DB		   *	    or	bl, bl
 02DA  74 14		   *	    je     @C0021
							CloseFileHandle
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??002B     textequ <>
 = 			     2			??002C textequ <>
			     2			for       ??002A, <bx,cx,dx>
			     2				push  ??002A
			     2				??002C catstr <??002A>, ??002B, ??002C
			     2				??002B catstr <, >
			     2			endm
 02DC  53		     3				push  bx
 = bx			     3				??002C catstr <bx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 02DD  51		     3				push  cx
 = cx, bx		     3				??002C catstr <cx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 02DE  52		     3				push  dx
 = dx, cx, bx		     3				??002C catstr <dx>, ??002B, ??002C
 = , 			     3				??002B catstr <, >
 = <dx, cx, bx>		     2			??002C catstr OPEN_DELIMITER, ??002C, CLOSE_DELIMITER
			     2			__pushRegs ??002C
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??002C
			     3			else
			     3				regStack catstr ??002C, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 02DF  B9 0001		     1			mov cx, 1
 02E2  8B 5E F6		     1			mov bx, handle
 02E5  8D 16 0000 R	     1			lea dx, COLUMN_SEP
 02E9  B4 40		     1			mov ah, 40h
 02EB  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??002E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??002E eq 0
 = <dx, cx, bx>		     3				??002F     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??002F substr regStack, 1, (??002E - 1)
			     3				regStack substr regStack, (??002E + 1)
			     3			endif
			     3			exitm ??002F
			     2		%	for ??002D, __popRegs(regStack) 
			     2				pop ??002D
			     2			endm
 02ED  5A		     3				pop dx
 02EE  59		     3				pop cx
 02EF  5B		     3				pop bx
						.endif
 02F0			   *@C0021:
						.exit
 02F0  8B 05					ret
					ExitAndClose endp
				
 02F2  50		   *	    push   ax
 02F3  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 02F6  50		   *	    push   ax
 02F7  E8 1234		   *	    call   string_from_sword
				;====================================================================
				; Reading input
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0031     textequ <>
 = 			     2			??0032 textequ <>
			     2			for       ??0030, <bx,cx,dx>
			     2				push  ??0030
			     2				??0032 catstr <??0030>, ??0031, ??0032
			     2				??0031 catstr <, >
			     2			endm
 02FA  53		     3				push  bx
 = bx			     3				??0032 catstr <bx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 02FB  51		     3				push  cx
 = cx, bx		     3				??0032 catstr <cx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 02FC  52		     3				push  dx
 = dx, cx, bx		     3				??0032 catstr <dx>, ??0031, ??0032
 = , 			     3				??0031 catstr <, >
 = <dx, cx, bx>		     2			??0032 catstr OPEN_DELIMITER, ??0032, CLOSE_DELIMITER
			     2			__pushRegs ??0032
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0032
			     3			else
			     3				regStack catstr ??0032, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 02FD  8B C8		     1			mov cx, ax
 02FF  8B 5E F6		     1			mov bx, handle
 0302  8D 56 F9		     1			lea dx, buf
 0305  B4 40		     1			mov ah, 40h
 0307  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0034 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0034 eq 0
 = <dx, cx, bx>		     3				??0035     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0035 substr regStack, 1, (??0034 - 1)
			     3				regStack substr regStack, (??0034 + 1)
			     3			endif
			     3			exitm ??0035
			     2		%	for ??0033, __popRegs(regStack) 
			     2				pop ??0033
			     2			endm
 0309  5A		     3				pop dx
 030A  59		     3				pop cx
 030B  5B		     3				pop bx
				
 030C  83 C7 02				ReadCommand proc near uses si
						mov dx, offset CommandBuffer
 030F  B3 01					mov ah, 0Ah
 0311  FE C1					int 21h
				
 0313  EB BD					mov si, offset CommandBufferString
 0315						mov bh, 0
						mov bl, CommandBufferLength
						
			     1			SaveRegs bx, cx, dx
			     2			local reg, comma, regpushed
 = 			     2			??0037     textequ <>
 = 			     2			??0038 textequ <>
			     2			for       ??0036, <bx,cx,dx>
			     2				push  ??0036
			     2				??0038 catstr <??0036>, ??0037, ??0038
			     2				??0037 catstr <, >
			     2			endm
 0315  53		     3				push  bx
 = bx			     3				??0038 catstr <bx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 0316  51		     3				push  cx
 = cx, bx		     3				??0038 catstr <cx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 0317  52		     3				push  dx
 = dx, cx, bx		     3				??0038 catstr <dx>, ??0037, ??0038
 = , 			     3				??0037 catstr <, >
 = <dx, cx, bx>		     2			??0038 catstr OPEN_DELIMITER, ??0038, CLOSE_DELIMITER
			     2			__pushRegs ??0038
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, cx, bx>		     3				regStack catstr ??0038
			     3			else
			     3				regStack catstr ??0038, REG_SET_DELIMITER, regStack
			     3			endif
			     1	
 0318  B9 0002		     1			mov cx, 2
 031B  8B 5E F6		     1			mov bx, handle
 031E  8D 16 0002 R	     1			lea dx, CRLF
 0322  B4 40		     1			mov ah, 40h
 0324  CD 21		     1			int 21h
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??003A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??003A eq 0
 = <dx, cx, bx>		     3				??003B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??003B substr regStack, 1, (??003A - 1)
			     3				regStack substr regStack, (??003A + 1)
			     3			endif
			     3			exitm ??003B
			     2		%	for ??0039, __popRegs(regStack) 
			     2				pop ??0039
			     2			endm
 0326  5A		     3				pop dx
 0327  59		     3				pop cx
 0328  5B		     3				pop bx
						mov byte ptr [CommandBufferString+bx], 0
 0329  FE C5			
				
 032B  EB 9B					putc CR
 032D						putc LF
				
 032D  F8					invoke ParseCommand
						ret
 032E  5E		   *	    pop    si
 032F  5F		   *	    pop    di
 0330  5D		   *	    pop    bp
 0331  5A		   *	    pop    dx
 0332  59		   *	    pop    cx
 0333  5B		   *	    pop    bx
 0334  58		   *	    pop    ax
 0335  8B E5		   *	    mov    sp, bp
 0337  5D		   *	    pop    bp
 0338  C2 0002		   *	    ret    00002h
 033B					ReadCommand endp
				
					; constStr must be uppercase, doesn't work with symbols
					StartsWith macro constStr, memString
 033B						LOCAL i, @@eq, @@ne, @@done		SaveRegs ax, bx
 033B  B0 00					i = 0
 033D  EB 06							mov bx, memString
 033F  C3							forc char, <constStr>
 0340							mov al, [bx+i]
							and al, 11011111b ; toUpperCase
 0340							cmp al, '&char'
 0340  B0 01						jne @@ne
 0342  EB 01						i = i + 1
 0344  C3					endm 
 0345						mov ax, 1
						jmp @@done
 0345						@@ne:
							mov ax, 0
 0345  80 3E 0073 R 00	   *	    cmp    FileIsOpen, 000h
 034A  74 0D		   *	    je     @C0023
						@@done:
 034C  B4 3E		     1			mov ah, 3eh
 034E  8B 1E 0071 R	     1			mov bx, FileHandle
 0352  CD 21		     1			int 21h
			     1			
 0354  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
							cmp ax, 0			RestoreRegs
 0359			   *@C0023:
					endm
 0359  B4 4C		   *	    mov    ah, 04Ch
 035B  CD 21		   *	    int    021h
 035D  C3			
 035E					SkipSpacesInSI macro string:req
						.while (BYTE PTR [string] == ' ' )
							inc string
						.endw	endm
				
 035E					; Return the value read in result, and the end of the string read in si
 035E  56		   *	    push   si
 035F  BA 010B R			ReadNumFromString proc near uses RegsInvokeUses, string:ptr byte, result:ptr sword
 0362  B4 0A					mov ax, 0
 0364  CD 21					mov bx, 0
						mov si, string
 0366  BE 010D R				mov cx, 0
 0369  B7 00			
 036B  8A 1E 010C R				.if byte ptr [si] == '-'
							inc si
 036F  C6 87 010D R 00					mov cx, 1
						.endif
				
						.while (byte ptr [si] >= '0') && (byte ptr [si] <= '9')
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??003D     textequ <>
 = 			     2			??003E textequ <>
			     2			for       ??003C, <ax,dx>
			     2				push  ??003C
			     2				??003E catstr <??003C>, ??003D, ??003E
			     2				??003D catstr <, >
			     2			endm
 0374  50		     3				push  ax
 = ax			     3				??003E catstr <ax>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 0375  52		     3				push  dx
 = dx, ax		     3				??003E catstr <dx>, ??003D, ??003E
 = , 			     3				??003D catstr <, >
 = <dx, ax>		     2			??003E catstr OPEN_DELIMITER, ??003E, CLOSE_DELIMITER
			     2			__pushRegs ??003E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??003E
			     3			else
			     3				regStack catstr ??003E, REG_SET_DELIMITER, regStack
			     3			endif
 0376  B4 02		     1			mov      ah, 02h
 0378  B2 0D		     1			mov      dl, CR
 037A  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0040 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0040 eq 0
 = <dx, ax>		     3				??0041     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0041 substr regStack, 1, (??0040 - 1)
			     3				regStack substr regStack, (??0040 + 1)
			     3			endif
			     3			exitm ??0041
			     2		%	for ??003F, __popRegs(regStack) 
			     2				pop ??003F
			     2			endm
 037C  5A		     3				pop dx
 037D  58		     3				pop ax
							mov dx, 10
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0043     textequ <>
 = 			     2			??0044 textequ <>
			     2			for       ??0042, <ax,dx>
			     2				push  ??0042
			     2				??0044 catstr <??0042>, ??0043, ??0044
			     2				??0043 catstr <, >
			     2			endm
 037E  50		     3				push  ax
 = ax			     3				??0044 catstr <ax>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 037F  52		     3				push  dx
 = dx, ax		     3				??0044 catstr <dx>, ??0043, ??0044
 = , 			     3				??0043 catstr <, >
 = <dx, ax>		     2			??0044 catstr OPEN_DELIMITER, ??0044, CLOSE_DELIMITER
			     2			__pushRegs ??0044
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0044
			     3			else
			     3				regStack catstr ??0044, REG_SET_DELIMITER, regStack
			     3			endif
 0380  B4 02		     1			mov      ah, 02h
 0382  B2 0A		     1			mov      dl, LF
 0384  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0046 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0046 eq 0
 = <dx, ax>		     3				??0047     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0047 substr regStack, 1, (??0046 - 1)
			     3				regStack substr regStack, (??0046 + 1)
			     3			endif
			     3			exitm ??0047
			     2		%	for ??0045, __popRegs(regStack) 
			     2				pop ??0045
			     2			endm
 0386  5A		     3				pop dx
 0387  58		     3				pop ax
							mul dx
				
 0388  E8 0060		   *	    call   ParseCommand
							mov bl, [si]
 038B  5E		   *	    pop    si
 038C  C3		   *	    ret    00000h
 038D							sub bl, '0'
							add ax, bx
				
							inc si
						.endw
				
						mov bx, string
						add bx, cx
						.if (si == bx)
							stc
							ret
						.endif
				
						.if (cx)
							neg ax
						.endif
				
						mov bx,           result
						mov word ptr[bx], ax
						clc
						ret
					ReadNumFromString endp
				
					skipAndRead macro string:req, numberInMemory:req, resultReg:req
						SkipSpacesInSI string
						invoke ReadNumFromString, string, addr numberInMemory
						.if            (carry?)			stc		.else			mov resultReg, numberInMemory
							clc		.endif	endm
				
					; string in memory mus be in si
					jumpIfSIComparesTo macro constStr:req, jumpTarget:req
						StartsWith <constStr> si
								.if (!zero?)			add si, @SizeStr(constStr)
							jmp jumpTarget
						.endif	endm
				
				
 038D					;   AX = command ID (CMD_*)
 038D  55		   *	    push   bp
 038E  8B EC		   *	    mov    bp, sp
 0390  50		   *	    push   ax
 0391  53		   *	    push   bx
 0392  51		   *	    push   cx
 0393  52		   *	    push   dx
 0394  55		   *	    push   bp
 0395  B8 0000				;   BX = param1 (if any)
 0398  BB 0000				;   CX = param2 (if any)
 039B  8B 76 04				;   DX = offset of string (WRITE)
 039E  B9 0000				ParseCommand proc near uses si di bp
						local a:sword
				
 03A1  80 3C 2D		   *	    cmp    byte ptr [si], '-'
 03A4  75 04		   *	    jne    @C0025
 03A6  46					mov si, offset CommandBufferString
 03A7  B9 0001					
						SkipSpacesInSI si
 03AA			   *@C0025:
				
						jumpIfSIComparesTo <MUL> ParseCommand@MUL
 03AA  EB 0D		   *	    jmp    @C0027
 03AC			   *@C0028:
 03AC  BA 000A					jumpIfSIComparesTo <ADD> ParseCommand@ADD
 03AF  F7 E2					jumpIfSIComparesTo <UNDO> ParseCommand@UNDO
						jumpIfSIComparesTo <WRITE> ParseCommand@WRITE
 03B1  8A 1C					jumpIfSIComparesTo <EXIT> ParseCommand@EXIT
 03B3  80 EB 30					jumpIfSIComparesTo <QUIT> ParseCommand@EXIT
 03B6  03 C3				
						strcpy_all NonTerminalErrorBuffer, @Comando, @space, @desconhecido, ExplanationSeparator, CommandBufferString
 03B8  46				ParseCommand@error:
						stc
 03B9			   *@C0027:
 03B9  80 3C 30		   *	    cmp    byte ptr [si], '0'
 03BC  72 05		   *	    jb     @C0029
 03BE  80 3C 39		   *	    cmp    byte ptr [si], '9'
 03C1  76 E9		   *	    jbe    @C0028
 03C3			   *@C0029:
						ret
 03C3  8B 5E 04				ParseCommand@MUL:
 03C6  03 D9			
						skipAndRead si, a, bx
 03C8  3B F3		   *	    cmp    si, bx
 03CA  75 0A		   *	    jne    @C002B
 03CC  F9					.if (carry?)
							call ParseCommand@LINHA_AUSENTE
 03CD  5D		   *	    pop    bp
 03CE  5A		   *	    pop    dx
 03CF  59		   *	    pop    cx
 03D0  5B		   *	    pop    bx
 03D1  58		   *	    pop    ax
 03D2  5D		   *	    pop    bp
 03D3  C2 0004		   *	    ret    00004h
							jmp ParseCommand@error
 03D6			   *@C002B:
						.elseif (bl > N)
							call ParseCommand@LINHA_INVALIDA
 03D6  0B C9		   *	    or	cx, cx
 03D8  74 02		   *	    je     @C002D
 03DA  F7 D8						jmp ParseCommand@error
						.elseif (bl < 1)
 03DC			   *@C002D:
							call ParseCommand@LINHA_INVALIDA
 03DC  8B 5E 06						jmp ParseCommand@error
 03DF  89 07					.endif
 03E1  F8					
						skipAndRead si, a, cx
 03E2  5D		   *	    pop    bp
 03E3  5A		   *	    pop    dx
 03E4  59		   *	    pop    cx
 03E5  5B		   *	    pop    bx
 03E6  58		   *	    pop    ax
 03E7  5D		   *	    pop    bp
 03E8  C2 0004		   *	    ret    00004h
 03EB						.if (carry?)
							call ParseCommand@CONSTANTE_AUSENTE
							jmp ParseCommand@error
						.endif
				
						mov ax, CMD_MUL
				
						jmp ParseCommand@success
				
					ParseCommand@ADD:
				
						skipAndRead si, a, bx
						.if (carry?)
							call ParseCommand@LINHA_DST_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
							call ParseCommand@LINHA_DST_INVALIDA
							jmp ParseCommand@error
						.endif
				
						skipAndRead si, a, cx
						.if (carry?)
							call ParseCommand@LINHA_ORG_AUSENTE
							jmp ParseCommand@error
						.elseif (bl > N)
 03EB							call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.elseif (bl < 1)
 03EB  55		   *	    push   bp
 03EC  8B EC		   *	    mov    bp, sp
 03EE  83 C4 FE		   *	    add    sp, 0FFFEh
 03F1  56		   *	    push   si
 03F2  57		   *	    push   di
 03F3  55		   *	    push   bp
 03F4  BE 010D R					call ParseCommand@LINHA_ORG_INVALIDA
							jmp ParseCommand@error
						.endif
 03F7  EB 01		   *	    jmp    @C002F
 03F9			   *@C0030:
			     1			.while (BYTE PTR [si] == ' ' )
 03F9  46		     1				inc si
 03FA			   *@C002F:
 03FA  80 3C 20		   *	    cmp    byte ptr [si], ' '
 03FD  74 FA		   *	    je     @C0030
			     1			.endw
				
						mov ax, CMD_ADD
			     1			StartsWith <MUL> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??004D     textequ <>
 = 			     3			??004E textequ <>
			     3			for       ??004C, <ax,bx>
			     3				push  ??004C
			     3				??004E catstr <??004C>, ??004D, ??004E
			     3				??004D catstr <, >
			     3			endm
 03FF  50		     4				push  ax
 = ax			     4				??004E catstr <ax>, ??004D, ??004E
 = , 			     4				??004D catstr <, >
 0400  53		     4				push  bx
 = bx, ax		     4				??004E catstr <bx>, ??004D, ??004E
 = , 			     4				??004D catstr <, >
 = <bx, ax>		     3			??004E catstr OPEN_DELIMITER, ??004E, CLOSE_DELIMITER
			     3			__pushRegs ??004E
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??004E
			     4			else
			     4				regStack catstr ??004E, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0048 = 0
			     2			
 0401  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <MUL>
			     2				mov al, [bx+??0048]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??004A
			     2	
			     2				??0048 = ??0048 + 1
			     2			endm 
 0403  8A 07		     3				mov al, [bx+??0048]
 0405  24 DF		     3				and al, 11011111b ; toUpperCase
 0407  3C 4D		     3				cmp al, 'M'
 0409  75 17		     3				jne ??004A
			     3	
 = 0001			     3				??0048 = ??0048 + 1
 040B  8A 47 01		     3				mov al, [bx+??0048]
 040E  24 DF		     3				and al, 11011111b ; toUpperCase
 0410  3C 55		     3				cmp al, 'U'
 0412  75 0E		     3				jne ??004A
			     3	
 = 0002			     3				??0048 = ??0048 + 1
 0414  8A 47 02		     3				mov al, [bx+??0048]
 0417  24 DF		     3				and al, 11011111b ; toUpperCase
 0419  3C 4C		     3				cmp al, 'L'
 041B  75 05		     3				jne ??004A
			     3	
 = 0003			     3				??0048 = ??0048 + 1
 041D  B8 0001		     2			mov ax, 1
			     2	
 0420  EB 03		     2			jmp ??004B
 0422			     2			??004A:
 0422  B8 0000		     2				mov ax, 0
			     2	
 0425			     2			??004B:
 0425  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0050 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0050 eq 0
 = <bx, ax>		     4				??0051     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0051 substr regStack, 1, (??0050 - 1)
			     4				regStack substr regStack, (??0050 + 1)
			     4			endif
			     4			exitm ??0051
			     3		%	for ??004F, __popRegs(regStack) 
			     3				pop ??004F
			     3			endm
 0428  5B		     4				pop bx
 0429  58		     4				pop ax
			     1			
 042A  74 06		   *	    je     @C0032
			     1			.if (!zero?)
 042C  83 C6 03		     1				add si, @SizeStr(MUL)
 042F  E9 0192		     1				jmp ParseCommand@MUL
 0432			   *@C0032:
			     1			.endif
						
			     1			StartsWith <ADD> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0057     textequ <>
 = 			     3			??0058 textequ <>
			     3			for       ??0056, <ax,bx>
			     3				push  ??0056
			     3				??0058 catstr <??0056>, ??0057, ??0058
			     3				??0057 catstr <, >
			     3			endm
 0432  50		     4				push  ax
 = ax			     4				??0058 catstr <ax>, ??0057, ??0058
 = , 			     4				??0057 catstr <, >
 0433  53		     4				push  bx
 = bx, ax		     4				??0058 catstr <bx>, ??0057, ??0058
 = , 			     4				??0057 catstr <, >
 = <bx, ax>		     3			??0058 catstr OPEN_DELIMITER, ??0058, CLOSE_DELIMITER
			     3			__pushRegs ??0058
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0058
			     4			else
			     4				regStack catstr ??0058, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0052 = 0
			     2			
 0434  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <ADD>
			     2				mov al, [bx+??0052]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0054
			     2	
			     2				??0052 = ??0052 + 1
			     2			endm 
 0436  8A 07		     3				mov al, [bx+??0052]
 0438  24 DF		     3				and al, 11011111b ; toUpperCase
 043A  3C 41		     3				cmp al, 'A'
 043C  75 17		     3				jne ??0054
			     3	
 = 0001			     3				??0052 = ??0052 + 1
 043E  8A 47 01		     3				mov al, [bx+??0052]
 0441  24 DF		     3				and al, 11011111b ; toUpperCase
 0443  3C 44		     3				cmp al, 'D'
 0445  75 0E		     3				jne ??0054
			     3	
 = 0002			     3				??0052 = ??0052 + 1
 0447  8A 47 02		     3				mov al, [bx+??0052]
 044A  24 DF		     3				and al, 11011111b ; toUpperCase
 044C  3C 44		     3				cmp al, 'D'
 044E  75 05		     3				jne ??0054
			     3	
 = 0003			     3				??0052 = ??0052 + 1
 0450  B8 0001		     2			mov ax, 1
			     2	
 0453  EB 03		     2			jmp ??0055
 0455			     2			??0054:
 0455  B8 0000		     2				mov ax, 0
			     2	
 0458			     2			??0055:
 0458  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??005A instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??005A eq 0
 = <bx, ax>		     4				??005B     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??005B substr regStack, 1, (??005A - 1)
			     4				regStack substr regStack, (??005A + 1)
			     4			endif
			     4			exitm ??005B
			     3		%	for ??0059, __popRegs(regStack) 
			     3				pop ??0059
			     3			endm
 045B  5B		     4				pop bx
 045C  58		     4				pop ax
			     1			
 045D  74 06		   *	    je     @C0034
			     1			.if (!zero?)
 045F  83 C6 03		     1				add si, @SizeStr(ADD)
 0462  E9 01BE		     1				jmp ParseCommand@ADD
 0465			   *@C0034:
			     1			.endif
						jmp ParseCommand@success
			     1			StartsWith <UNDO> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0061     textequ <>
 = 			     3			??0062 textequ <>
			     3			for       ??0060, <ax,bx>
			     3				push  ??0060
			     3				??0062 catstr <??0060>, ??0061, ??0062
			     3				??0061 catstr <, >
			     3			endm
 0465  50		     4				push  ax
 = ax			     4				??0062 catstr <ax>, ??0061, ??0062
 = , 			     4				??0061 catstr <, >
 0466  53		     4				push  bx
 = bx, ax		     4				??0062 catstr <bx>, ??0061, ??0062
 = , 			     4				??0061 catstr <, >
 = <bx, ax>		     3			??0062 catstr OPEN_DELIMITER, ??0062, CLOSE_DELIMITER
			     3			__pushRegs ??0062
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0062
			     4			else
			     4				regStack catstr ??0062, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??005C = 0
			     2			
 0467  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <UNDO>
			     2				mov al, [bx+??005C]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??005E
			     2	
			     2				??005C = ??005C + 1
			     2			endm 
 0469  8A 07		     3				mov al, [bx+??005C]
 046B  24 DF		     3				and al, 11011111b ; toUpperCase
 046D  3C 55		     3				cmp al, 'U'
 046F  75 20		     3				jne ??005E
			     3	
 = 0001			     3				??005C = ??005C + 1
 0471  8A 47 01		     3				mov al, [bx+??005C]
 0474  24 DF		     3				and al, 11011111b ; toUpperCase
 0476  3C 4E		     3				cmp al, 'N'
 0478  75 17		     3				jne ??005E
			     3	
 = 0002			     3				??005C = ??005C + 1
 047A  8A 47 02		     3				mov al, [bx+??005C]
 047D  24 DF		     3				and al, 11011111b ; toUpperCase
 047F  3C 44		     3				cmp al, 'D'
 0481  75 0E		     3				jne ??005E
			     3	
 = 0003			     3				??005C = ??005C + 1
 0483  8A 47 03		     3				mov al, [bx+??005C]
 0486  24 DF		     3				and al, 11011111b ; toUpperCase
 0488  3C 4F		     3				cmp al, 'O'
 048A  75 05		     3				jne ??005E
			     3	
 = 0004			     3				??005C = ??005C + 1
 048C  B8 0001		     2			mov ax, 1
			     2	
 048F  EB 03		     2			jmp ??005F
 0491			     2			??005E:
 0491  B8 0000		     2				mov ax, 0
			     2	
 0494			     2			??005F:
 0494  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0064 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0064 eq 0
 = <bx, ax>		     4				??0065     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0065 substr regStack, 1, (??0064 - 1)
			     4				regStack substr regStack, (??0064 + 1)
			     4			endif
			     4			exitm ??0065
			     3		%	for ??0063, __popRegs(regStack) 
			     3				pop ??0063
			     3			endm
 0497  5B		     4				pop bx
 0498  58		     4				pop ax
			     1			
 0499  74 06		   *	    je     @C0036
			     1			.if (!zero?)
 049B  83 C6 04		     1				add si, @SizeStr(UNDO)
 049E  E9 01FF		     1				jmp ParseCommand@UNDO
 04A1			   *@C0036:
			     1			.endif
				
			     1			StartsWith <WRITE> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??006B     textequ <>
 = 			     3			??006C textequ <>
			     3			for       ??006A, <ax,bx>
			     3				push  ??006A
			     3				??006C catstr <??006A>, ??006B, ??006C
			     3				??006B catstr <, >
			     3			endm
 04A1  50		     4				push  ax
 = ax			     4				??006C catstr <ax>, ??006B, ??006C
 = , 			     4				??006B catstr <, >
 04A2  53		     4				push  bx
 = bx, ax		     4				??006C catstr <bx>, ??006B, ??006C
 = , 			     4				??006B catstr <, >
 = <bx, ax>		     3			??006C catstr OPEN_DELIMITER, ??006C, CLOSE_DELIMITER
			     3			__pushRegs ??006C
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??006C
			     4			else
			     4				regStack catstr ??006C, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0066 = 0
			     2			
 04A3  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <WRITE>
			     2				mov al, [bx+??0066]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0068
			     2	
			     2				??0066 = ??0066 + 1
			     2			endm 
 04A5  8A 07		     3				mov al, [bx+??0066]
 04A7  24 DF		     3				and al, 11011111b ; toUpperCase
 04A9  3C 57		     3				cmp al, 'W'
 04AB  75 29		     3				jne ??0068
			     3	
 = 0001			     3				??0066 = ??0066 + 1
 04AD  8A 47 01		     3				mov al, [bx+??0066]
 04B0  24 DF		     3				and al, 11011111b ; toUpperCase
 04B2  3C 52		     3				cmp al, 'R'
 04B4  75 20		     3				jne ??0068
			     3	
 = 0002			     3				??0066 = ??0066 + 1
 04B6  8A 47 02		     3				mov al, [bx+??0066]
 04B9  24 DF		     3				and al, 11011111b ; toUpperCase
 04BB  3C 49		     3				cmp al, 'I'
 04BD  75 17		     3				jne ??0068
			     3	
 = 0003			     3				??0066 = ??0066 + 1
 04BF  8A 47 03		     3				mov al, [bx+??0066]
 04C2  24 DF		     3				and al, 11011111b ; toUpperCase
 04C4  3C 54		     3				cmp al, 'T'
 04C6  75 0E		     3				jne ??0068
			     3	
 = 0004			     3				??0066 = ??0066 + 1
 04C8  8A 47 04		     3				mov al, [bx+??0066]
 04CB  24 DF		     3				and al, 11011111b ; toUpperCase
 04CD  3C 45		     3				cmp al, 'E'
 04CF  75 05		     3				jne ??0068
			     3	
 = 0005			     3				??0066 = ??0066 + 1
 04D1  B8 0001		     2			mov ax, 1
			     2	
 04D4  EB 03		     2			jmp ??0069
 04D6			     2			??0068:
 04D6  B8 0000		     2				mov ax, 0
			     2	
 04D9			     2			??0069:
 04D9  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??006E instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??006E eq 0
 = <bx, ax>		     4				??006F     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??006F substr regStack, 1, (??006E - 1)
			     4				regStack substr regStack, (??006E + 1)
			     4			endif
			     4			exitm ??006F
			     3		%	for ??006D, __popRegs(regStack) 
			     3				pop ??006D
			     3			endm
 04DC  5B		     4				pop bx
 04DD  58		     4				pop ax
			     1			
 04DE  74 06		   *	    je     @C0038
			     1			.if (!zero?)
 04E0  83 C6 05		     1				add si, @SizeStr(WRITE)
 04E3  E9 01BF		     1				jmp ParseCommand@WRITE
 04E6			   *@C0038:
			     1			.endif
					ParseCommand@UNDO:
			     1			StartsWith <EXIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??0075     textequ <>
 = 			     3			??0076 textequ <>
			     3			for       ??0074, <ax,bx>
			     3				push  ??0074
			     3				??0076 catstr <??0074>, ??0075, ??0076
			     3				??0075 catstr <, >
			     3			endm
 04E6  50		     4				push  ax
 = ax			     4				??0076 catstr <ax>, ??0075, ??0076
 = , 			     4				??0075 catstr <, >
 04E7  53		     4				push  bx
 = bx, ax		     4				??0076 catstr <bx>, ??0075, ??0076
 = , 			     4				??0075 catstr <, >
 = <bx, ax>		     3			??0076 catstr OPEN_DELIMITER, ??0076, CLOSE_DELIMITER
			     3			__pushRegs ??0076
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0076
			     4			else
			     4				regStack catstr ??0076, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??0070 = 0
			     2			
 04E8  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <EXIT>
			     2				mov al, [bx+??0070]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??0072
			     2	
			     2				??0070 = ??0070 + 1
			     2			endm 
 04EA  8A 07		     3				mov al, [bx+??0070]
 04EC  24 DF		     3				and al, 11011111b ; toUpperCase
 04EE  3C 45		     3				cmp al, 'E'
 04F0  75 20		     3				jne ??0072
			     3	
 = 0001			     3				??0070 = ??0070 + 1
 04F2  8A 47 01		     3				mov al, [bx+??0070]
 04F5  24 DF		     3				and al, 11011111b ; toUpperCase
 04F7  3C 58		     3				cmp al, 'X'
 04F9  75 17		     3				jne ??0072
			     3	
 = 0002			     3				??0070 = ??0070 + 1
 04FB  8A 47 02		     3				mov al, [bx+??0070]
 04FE  24 DF		     3				and al, 11011111b ; toUpperCase
 0500  3C 49		     3				cmp al, 'I'
 0502  75 0E		     3				jne ??0072
			     3	
 = 0003			     3				??0070 = ??0070 + 1
 0504  8A 47 03		     3				mov al, [bx+??0070]
 0507  24 DF		     3				and al, 11011111b ; toUpperCase
 0509  3C 54		     3				cmp al, 'T'
 050B  75 05		     3				jne ??0072
			     3	
 = 0004			     3				??0070 = ??0070 + 1
 050D  B8 0001		     2			mov ax, 1
			     2	
 0510  EB 03		     2			jmp ??0073
 0512			     2			??0072:
 0512  B8 0000		     2				mov ax, 0
			     2	
 0515			     2			??0073:
 0515  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0078 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0078 eq 0
 = <bx, ax>		     4				??0079     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0079 substr regStack, 1, (??0078 - 1)
			     4				regStack substr regStack, (??0078 + 1)
			     4			endif
			     4			exitm ??0079
			     3		%	for ??0077, __popRegs(regStack) 
			     3				pop ??0077
			     3			endm
 0518  5B		     4				pop bx
 0519  58		     4				pop ax
			     1			
 051A  74 06		   *	    je     @C003A
			     1			.if (!zero?)
 051C  83 C6 04		     1				add si, @SizeStr(EXIT)
 051F  E9 019A		     1				jmp ParseCommand@EXIT
 0522			   *@C003A:
			     1			.endif
						mov ax, CMD_UNDO
			     1			StartsWith <QUIT> si
			     2			LOCAL i, @@eq, @@ne, @@done
			     2			SaveRegs ax, bx
			     3			local reg, comma, regpushed
 = 			     3			??007F     textequ <>
 = 			     3			??0080 textequ <>
			     3			for       ??007E, <ax,bx>
			     3				push  ??007E
			     3				??0080 catstr <??007E>, ??007F, ??0080
			     3				??007F catstr <, >
			     3			endm
 0522  50		     4				push  ax
 = ax			     4				??0080 catstr <ax>, ??007F, ??0080
 = , 			     4				??007F catstr <, >
 0523  53		     4				push  bx
 = bx, ax		     4				??0080 catstr <bx>, ??007F, ??0080
 = , 			     4				??007F catstr <, >
 = <bx, ax>		     3			??0080 catstr OPEN_DELIMITER, ??0080, CLOSE_DELIMITER
			     3			__pushRegs ??0080
 = 0000			     4			size_s sizestr regStack
			     4			if     size_s eq 0
 = <bx, ax>		     4				regStack catstr ??0080
			     4			else
			     4				regStack catstr ??0080, REG_SET_DELIMITER, regStack
			     4			endif
			     2	
 = 0000			     2			??007A = 0
			     2			
 0524  8B DE		     2			mov bx, si
			     2			
			     2			forc char, <QUIT>
			     2				mov al, [bx+??007A]
			     2				and al, 11011111b ; toUpperCase
			     2				cmp al, '&char'
			     2				jne ??007C
			     2	
			     2				??007A = ??007A + 1
			     2			endm 
 0526  8A 07		     3				mov al, [bx+??007A]
 0528  24 DF		     3				and al, 11011111b ; toUpperCase
 052A  3C 51		     3				cmp al, 'Q'
 052C  75 20		     3				jne ??007C
			     3	
 = 0001			     3				??007A = ??007A + 1
 052E  8A 47 01		     3				mov al, [bx+??007A]
 0531  24 DF		     3				and al, 11011111b ; toUpperCase
 0533  3C 55		     3				cmp al, 'U'
 0535  75 17		     3				jne ??007C
			     3	
 = 0002			     3				??007A = ??007A + 1
 0537  8A 47 02		     3				mov al, [bx+??007A]
 053A  24 DF		     3				and al, 11011111b ; toUpperCase
 053C  3C 49		     3				cmp al, 'I'
 053E  75 0E		     3				jne ??007C
			     3	
 = 0003			     3				??007A = ??007A + 1
 0540  8A 47 03		     3				mov al, [bx+??007A]
 0543  24 DF		     3				and al, 11011111b ; toUpperCase
 0545  3C 54		     3				cmp al, 'T'
 0547  75 05		     3				jne ??007C
			     3	
 = 0004			     3				??007A = ??007A + 1
 0549  B8 0001		     2			mov ax, 1
			     2	
 054C  EB 03		     2			jmp ??007D
 054E			     2			??007C:
 054E  B8 0000		     2				mov ax, 0
			     2	
 0551			     2			??007D:
 0551  83 F8 00		     2				cmp ax, 0
			     2				RestoreRegs
			     3			local reg
			     4			local regs_end, regs
 = 0000			     4			??0082 instr 1, regStack, REG_SET_DELIMITER
			     4			if    ??0082 eq 0
 = <bx, ax>		     4				??0083     substr regStack, 1
 = 			     4				regStack textequ <>
			     4			else
			     4				??0083 substr regStack, 1, (??0082 - 1)
			     4				regStack substr regStack, (??0082 + 1)
			     4			endif
			     4			exitm ??0083
			     3		%	for ??0081, __popRegs(regStack) 
			     3				pop ??0081
			     3			endm
 0554  5B		     4				pop bx
 0555  58		     4				pop ax
			     1			
 0556  74 06		   *	    je     @C003C
			     1			.if (!zero?)
 0558  83 C6 04		     1				add si, @SizeStr(QUIT)
 055B  E9 015E		     1				jmp ParseCommand@EXIT
 055E			   *@C003C:
			     1			.endif
						jmp ParseCommand@success
				
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 055E  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@Comando,@space,@desconhecido,ExplanationSeparator,CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @Comando
			     3				EXITM <-1> 
			     2				if DEFINED(@Comando)
			     2					strcpy @Comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0085     textequ <>
 = 			     4			??0086 textequ <>
			     4			for       ??0084, <ax>
			     4				push  ??0084
			     4				??0086 catstr <??0084>, ??0085, ??0086
			     4				??0085 catstr <, >
			     4			endm
 0562  50		     5				push  ax
 = ax			     5				??0086 catstr <ax>, ??0085, ??0086
 = , 			     5				??0085 catstr <, >
 = <ax>			     4			??0086 catstr OPEN_DELIMITER, ??0086, CLOSE_DELIMITER
			     4			__pushRegs ??0086
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0086
			     5			else
			     5				regStack catstr ??0086, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@Comando>, <si>
 0563  8D 36 0310 R	     3				lea si, @Comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0567			   *@C003E:
			     3			.repeat
 0567  8A 04		     3				mov al,   [si]
 0569  88 05		     3				mov [di], al
 056B  46		     3				inc si
 056C  47		     3				inc di
 056D  0A C0		   *	    or	al, al
 056F  75 F6		   *	    jne    @C003E
			     3			.until (al == 0)
 0571  4E		     3			dec    si
 0572  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??0088 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0088 eq 0
 = <ax>			     5				??0089     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??0089 substr regStack, 1, (??0088 - 1)
			     5				regStack substr regStack, (??0088 + 1)
			     5			endif
			     5			exitm ??0089
			     4		%	for ??0087, __popRegs(regStack) 
			     4				pop ??0087
			     4			endm
 0573  58		     5				pop ax
			     2				else
			     2					strcpy_c <@Comando>, di
			     2				endif
			     3			IFDEF @space
			     3				EXITM <-1> 
			     2				if DEFINED(@space)
			     2					strcpy @space, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??008B     textequ <>
 = 			     4			??008C textequ <>
			     4			for       ??008A, <ax>
			     4				push  ??008A
			     4				??008C catstr <??008A>, ??008B, ??008C
			     4				??008B catstr <, >
			     4			endm
 0574  50		     5				push  ax
 = ax			     5				??008C catstr <ax>, ??008B, ??008C
 = , 			     5				??008B catstr <, >
 = <ax>			     4			??008C catstr OPEN_DELIMITER, ??008C, CLOSE_DELIMITER
			     4			__pushRegs ??008C
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??008C
			     5			else
			     5				regStack catstr ??008C, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@space>, <si>
 0575  8D 36 0345 R	     3				lea si, @space
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 0579			   *@C0040:
			     3			.repeat
 0579  8A 04		     3				mov al,   [si]
 057B  88 05		     3				mov [di], al
 057D  46		     3				inc si
 057E  47		     3				inc di
 057F  0A C0		   *	    or	al, al
 0581  75 F6		   *	    jne    @C0040
			     3			.until (al == 0)
 0583  4E		     3			dec    si
 0584  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??008E instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??008E eq 0
 = <ax>			     5				??008F     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??008F substr regStack, 1, (??008E - 1)
			     5				regStack substr regStack, (??008E + 1)
			     5			endif
			     5			exitm ??008F
			     4		%	for ??008D, __popRegs(regStack) 
			     4				pop ??008D
			     4			endm
 0585  58		     5				pop ax
			     2				else
			     2					strcpy_c <@space>, di
			     2				endif
			     3			IFDEF @desconhecido
			     3				EXITM <-1> 
			     2				if DEFINED(@desconhecido)
			     2					strcpy @desconhecido, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0091     textequ <>
 = 			     4			??0092 textequ <>
			     4			for       ??0090, <ax>
			     4				push  ??0090
			     4				??0092 catstr <??0090>, ??0091, ??0092
			     4				??0091 catstr <, >
			     4			endm
 0586  50		     5				push  ax
 = ax			     5				??0092 catstr <ax>, ??0091, ??0092
 = , 			     5				??0091 catstr <, >
 = <ax>			     4			??0092 catstr OPEN_DELIMITER, ??0092, CLOSE_DELIMITER
			     4			__pushRegs ??0092
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0092
			     5			else
			     5				regStack catstr ??0092, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@desconhecido>, <si>
 0587  8D 36 0338 R	     3				lea si, @desconhecido
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 058B			   *@C0042:
			     3			.repeat
 058B  8A 04		     3				mov al,   [si]
 058D  88 05		     3				mov [di], al
 058F  46		     3				inc si
 0590  47		     3				inc di
 0591  0A C0		   *	    or	al, al
 0593  75 F6		   *	    jne    @C0042
			     3			.until (al == 0)
 0595  4E		     3			dec    si
 0596  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??0094 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??0094 eq 0
 = <ax>			     5				??0095     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??0095 substr regStack, 1, (??0094 - 1)
			     5				regStack substr regStack, (??0094 + 1)
			     5			endif
			     5			exitm ??0095
			     4		%	for ??0093, __popRegs(regStack) 
			     4				pop ??0093
			     4			endm
 0597  58		     5				pop ax
			     2				else
			     2					strcpy_c <@desconhecido>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??0097     textequ <>
 = 			     4			??0098 textequ <>
			     4			for       ??0096, <ax>
			     4				push  ??0096
			     4				??0098 catstr <??0096>, ??0097, ??0098
			     4				??0097 catstr <, >
			     4			endm
 0598  50		     5				push  ax
 = ax			     5				??0098 catstr <ax>, ??0097, ??0098
 = , 			     5				??0097 catstr <, >
 = <ax>			     4			??0098 catstr OPEN_DELIMITER, ??0098, CLOSE_DELIMITER
			     4			__pushRegs ??0098
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??0098
			     5			else
			     5				regStack catstr ??0098, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 0599  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 059D			   *@C0044:
			     3			.repeat
 059D  8A 04		     3				mov al,   [si]
 059F  88 05		     3				mov [di], al
 05A1  46		     3				inc si
 05A2  47		     3				inc di
 05A3  0A C0		   *	    or	al, al
 05A5  75 F6		   *	    jne    @C0044
			     3			.until (al == 0)
 05A7  4E		     3			dec    si
 05A8  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??009A instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??009A eq 0
 = <ax>			     5				??009B     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??009B substr regStack, 1, (??009A - 1)
			     5				regStack substr regStack, (??009A + 1)
			     5			endif
			     5			exitm ??009B
			     4		%	for ??0099, __popRegs(regStack) 
			     4				pop ??0099
			     4			endm
 05A9  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??009D     textequ <>
 = 			     4			??009E textequ <>
			     4			for       ??009C, <ax>
			     4				push  ??009C
			     4				??009E catstr <??009C>, ??009D, ??009E
			     4				??009D catstr <, >
			     4			endm
 05AA  50		     5				push  ax
 = ax			     5				??009E catstr <ax>, ??009D, ??009E
 = , 			     5				??009D catstr <, >
 = <ax>			     4			??009E catstr OPEN_DELIMITER, ??009E, CLOSE_DELIMITER
			     4			__pushRegs ??009E
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??009E
			     5			else
			     5				regStack catstr ??009E, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 05AB  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 05AF			   *@C0046:
			     3			.repeat
 05AF  8A 04		     3				mov al,   [si]
 05B1  88 05		     3				mov [di], al
 05B3  46		     3				inc si
 05B4  47		     3				inc di
 05B5  0A C0		   *	    or	al, al
 05B7  75 F6		   *	    jne    @C0046
			     3			.until (al == 0)
 05B9  4E		     3			dec    si
 05BA  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A0 eq 0
 = <ax>			     5				??00A1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A1 substr regStack, 1, (??00A0 - 1)
			     5				regStack substr regStack, (??00A0 + 1)
			     5			endif
			     5			exitm ??00A1
			     4		%	for ??009F, __popRegs(regStack) 
			     4				pop ??009F
			     4			endm
 05BB  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
 05BC					ParseCommand@WRITE:
 05BC  F9					SkipSpacesInSI si
						
 05BD  5D		   *	    pop    bp
 05BE  5F		   *	    pop    di
 05BF  5E		   *	    pop    si
 05C0  8B E5		   *	    mov    sp, bp
 05C2  5D		   *	    pop    bp
 05C3  C3		   *	    ret    00000h
 05C4						mov    dx, si               ; filename pointer
						mov    ax, CMD_WRITE
						.while (BYTE PTR [si] != 0)
			     1			SkipSpacesInSI si
 05C4  EB 01		   *	    jmp    @C0048
 05C6			   *@C0049:
			     2			.while (BYTE PTR [si] == ' ' )
 05C6  46		     2				inc si
 05C7			   *@C0048:
 05C7  80 3C 20		   *	    cmp    byte ptr [si], ' '
 05CA  74 FA		   *	    je     @C0049
			     2			.endw
 05CC  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 05CF  50		   *	    push   ax
 05D0  56		   *	    push   si
 05D1  E8 FDB9		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 05D4  73 03		   *	    jae    @C004B
			     1			.if            (carry?)
 05D6  F9		     1				stc
 05D7  EB 04		   *	    jmp    @C004D
 05D9			   *@C004B:
			     1			.else
 05D9  8B 5E FE		     1				mov bx, a
 05DC  F8		     1				clc
 05DD			   *@C004D:
			     1			.endif
							inc si
 05DD  73 07		   *	    jae    @C004E
 05DF  E8 012E					.endw
 05E2  EB D8					jmp ParseCommand@success
				
 05E4  EB 17		   *	    jmp    @C0050
 05E6			   *@C004E:
 05E6  3A 1E 03C7 R	   *	    cmp    bl, N
 05EA  76 07		   *	    jbe    @C0051
 05EC  E8 04B1				ParseCommand@EXIT:
 05EF  EB CB					jmp ParseCommand@success
				
 05F1  EB 0A		   *	    jmp    @C0053
 05F3			   *@C0051:
 05F3  80 FB 01		   *	    cmp    bl, 001h
 05F6  73 05		   *	    jae    @C0054
 05F8  E8 04A5				ParseCommand@success:
 05FB  EB BF					SkipSpacesInSI si
						
 05FD			   *@C0054:
 05FD			   *@C0053:
 05FD			   *@C0050:
						.if (byte ptr [si] != 0)
						
			     1			SkipSpacesInSI si
 05FD  EB 01		   *	    jmp    @C0056
 05FF			   *@C0057:
			     2			.while (BYTE PTR [si] == ' ' )
 05FF  46		     2				inc si
 0600			   *@C0056:
 0600  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0603  74 FA		   *	    je     @C0057
			     2			.endw
 0605  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 0608  50		   *	    push   ax
 0609  56		   *	    push   si
 060A  E8 FD80		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 060D  73 03		   *	    jae    @C0059
			     1			.if            (carry?)
 060F  F9		     1				stc
 0610  EB 04		   *	    jmp    @C005B
 0612			   *@C0059:
			     1			.else
 0612  8B 4E FE		     1				mov cx, a
 0615  F8		     1				clc
 0616			   *@C005B:
			     1			.endif
							strcpy_all                                          NonTerminalErrorBuffer, \
 0616  73 05		   *	    jae    @C005C
 0618  E8 01CF						<@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
 061B  EB 9F						
							jmp ParseCommand@error
 061D			   *@C005C:
						.endif
 061D  B8 0001					clc
						ret
 0620  E9 009B				ParseCommand endp
				
 0623				
					ParseCommand@LINHA_AUSENTE proc near
						ErrorCommandExpectsNumber <"MUL">, <LINHA>, <PRIMEIRO>
			     1			SkipSpacesInSI si
 0623  EB 01		   *	    jmp    @C005E
 0625			   *@C005F:
			     2			.while (BYTE PTR [si] == ' ' )
 0625  46		     2				inc si
 0626			   *@C005E:
 0626  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0629  74 FA		   *	    je     @C005F
			     2			.endw
 062B  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 062E  50		   *	    push   ax
 062F  56		   *	    push   si
 0630  E8 FD5A		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 0633  73 03		   *	    jae    @C0061
			     1			.if            (carry?)
 0635  F9		     1				stc
 0636  EB 04		   *	    jmp    @C0063
 0638			   *@C0061:
			     1			.else
 0638  8B 5E FE		     1				mov bx, a
 063B  F8		     1				clc
 063C			   *@C0063:
			     1			.endif
						ret
 063C  73 08		   *	    jae    @C0064
 063E  E8 028F				ParseCommand@LINHA_AUSENTE endp
 0641  E9 FF78			
					ParseCommand@CONSTANTE_AUSENTE proc near
 0644  EB 19		   *	    jmp    @C0066
 0646			   *@C0064:
 0646  3A 1E 03C7 R	   *	    cmp    bl, N
 064A  76 08		   *	    jbe    @C0067
 064C  E8 04BD					ErrorCommandExpectsNumber <"MUL">, <CONSTANTE>, <SEGUNDO>
 064F  E9 FF6A					ret
					ParseCommand@CONSTANTE_AUSENTE endp
 0652  EB 0B		   *	    jmp    @C0069
 0654			   *@C0067:
 0654  80 FB 01		   *	    cmp    bl, 001h
 0657  73 06		   *	    jae    @C006A
 0659  E8 04B0				
 065C  E9 FF5D				ParseCommand@LINHA_DST_AUSENTE proc near
						ErrorCommandExpectsNumber <"ADD">, <LINHA_DST>, <PRIMEIRO>
 065F			   *@C006A:
 065F			   *@C0069:
 065F			   *@C0066:
						ret
					ParseCommand@LINHA_DST_AUSENTE endp
			     1			SkipSpacesInSI si
 065F  EB 01		   *	    jmp    @C006C
 0661			   *@C006D:
			     2			.while (BYTE PTR [si] == ' ' )
 0661  46		     2				inc si
 0662			   *@C006C:
 0662  80 3C 20		   *	    cmp    byte ptr [si], ' '
 0665  74 FA		   *	    je     @C006D
			     2			.endw
 0667  8D 46 FE		   *	    lea    ax, sword  ptr ss:[bp]+0FFFEh
 066A  50		   *	    push   ax
 066B  56		   *	    push   si
 066C  E8 FD1E		   *	    call   ReadNumFromString
			     1			invoke ReadNumFromString, si, addr a
 066F  73 03		   *	    jae    @C006F
			     1			.if            (carry?)
 0671  F9		     1				stc
 0672  EB 04		   *	    jmp    @C0071
 0674			   *@C006F:
			     1			.else
 0674  8B 4E FE		     1				mov cx, a
 0677  F8		     1				clc
 0678			   *@C0071:
			     1			.endif
				
 0678  73 08		   *	    jae    @C0072
 067A  E8 033D				ParseCommand@LINHA_ORG_AUSENTE proc near
 067D  E9 FF3C					ErrorCommandExpectsNumber <"ADD">, <LINHA_ORG>, <SEGUNDO>
						ret
 0680  EB 19		   *	    jmp    @C0074
 0682			   *@C0072:
 0682  3A 1E 03C7 R	   *	    cmp    bl, N
 0686  76 08		   *	    jbe    @C0075
 0688  E8 04FD				ParseCommand@LINHA_ORG_AUSENTE endp
 068B  E9 FF2E			
					ParseCommand@LINHA_INVALIDA proc near
 068E  EB 0B		   *	    jmp    @C0077
 0690			   *@C0075:
 0690  80 FB 01		   *	    cmp    bl, 001h
 0693  73 06		   *	    jae    @C0078
 0695  E8 04F0					ErrorNumberOutOfBounds <LINHA>
 0698  E9 FF21					ret
					ParseCommand@LINHA_INVALIDA endp
 069B			   *@C0078:
 069B			   *@C0077:
 069B			   *@C0074:
				
 069B  B8 0003				ParseCommand@LINHA_DST_INVALIDA proc near
						ErrorNumberOutOfBounds <LINHA_DST>
 069E  EB 1E					ret
					ParseCommand@LINHA_DST_INVALIDA endp
 06A0				
 06A0  B8 0005				ParseCommand@LINHA_ORG_INVALIDA proc near
 06A3  EB 19					ErrorNumberOutOfBounds <LINHA_ORG>
						ret
 06A5					ParseCommand@LINHA_ORG_INVALIDA endp
				
 06A5  EB 01		   *	    jmp    @C007A
 06A7			   *@C007B:
			     1			.while (BYTE PTR [si] == ' ' )
 06A7  46		     1				inc si
 06A8			   *@C007A:
 06A8  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06AB  74 FA		   *	    je     @C007B
			     1			.endw
				
 06AD  8B D6			
 06AF  B8 0006			;====================================================================
				; Reading error reporting
 06B2  EB 01		   *	    jmp    @C007D
 06B4			   *@C007E:
 06B4  46				ErrorOpen:
						printf_c <Erro na abertura do arquivo.>
 06B5			   *@C007D:
 06B5  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06B8  75 FA		   *	    jne    @C007E
 06BA  EB 02					jmp      ExitFailure
				
 06BC					ErrorRead:
 06BC  EB 00					printf_c <Erro na leitura do arquivo.>
						jmp      ExitFailure
 06BE				
					ErrorColumnCount:
 06BE  EB 01		   *	    jmp    @C0080
 06C0			   *@C0081:
			     1			.while (BYTE PTR [si] == ' ' )
 06C0  46		     1				inc si
 06C1			   *@C0080:
 06C1  80 3C 20		   *	    cmp    byte ptr [si], ' '
 06C4  74 FA		   *	    je     @C0081
			     1			.endw
						print_FilePosition
						printf_c < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
 06C6  80 3C 00		   *	    cmp    byte ptr [si], 000h
 06C9  74 3D		   *	    je     @C0083
						jmp      ExitFailure
				
					ErrorRowCount:
			     1			ifdifi <NonTerminalErrorBuffer>, <di>
 06CB  8D 3E 0211 R	     1				lea di, NonTerminalErrorBuffer
			     1			endif
			     1			for string, <@@parametros_nao_reconhecidos_ao_final_do_comando, ExplanationSeparator,   CommandBufferString>
			     1				if DEFINED(string)
			     1					strcpy string, di
			     1				else
			     1					strcpy_c <string>, di
			     1				endif
			     1			endm
			     3			IFDEF @@parametros_nao_reconhecidos_ao_final_do_comando
			     3				EXITM <-1> 
			     2				if DEFINED(@@parametros_nao_reconhecidos_ao_final_do_comando)
			     2					strcpy @@parametros_nao_reconhecidos_ao_final_do_comando, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A3     textequ <>
 = 			     4			??00A4 textequ <>
			     4			for       ??00A2, <ax>
			     4				push  ??00A2
			     4				??00A4 catstr <??00A2>, ??00A3, ??00A4
			     4				??00A3 catstr <, >
			     4			endm
 06CF  50		     5				push  ax
 = ax			     5				??00A4 catstr <ax>, ??00A3, ??00A4
 = , 			     5				??00A3 catstr <, >
 = <ax>			     4			??00A4 catstr OPEN_DELIMITER, ??00A4, CLOSE_DELIMITER
			     4			__pushRegs ??00A4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00A4
			     5			else
			     5				regStack catstr ??00A4, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <@@parametros_nao_reconhecidos_ao_final_do_comando>, <si>
 06D0  8D 36 0388 R	     3				lea si, @@parametros_nao_reconhecidos_ao_final_do_comando
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06D4			   *@C0085:
			     3			.repeat
 06D4  8A 04		     3				mov al,   [si]
 06D6  88 05		     3				mov [di], al
 06D8  46		     3				inc si
 06D9  47		     3				inc di
 06DA  0A C0		   *	    or	al, al
 06DC  75 F6		   *	    jne    @C0085
			     3			.until (al == 0)
 06DE  4E		     3			dec    si
 06DF  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00A6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00A6 eq 0
 = <ax>			     5				??00A7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00A7 substr regStack, 1, (??00A6 - 1)
			     5				regStack substr regStack, (??00A6 + 1)
			     5			endif
			     5			exitm ??00A7
			     4		%	for ??00A5, __popRegs(regStack) 
			     4				pop ??00A5
			     4			endm
 06E0  58		     5				pop ax
			     2				else
			     2					strcpy_c <@@parametros_nao_reconhecidos_ao_final_do_comando>, di
			     2				endif
			     3			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     2				if DEFINED(ExplanationSeparator)
			     2					strcpy ExplanationSeparator, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00A9     textequ <>
 = 			     4			??00AA textequ <>
			     4			for       ??00A8, <ax>
			     4				push  ??00A8
			     4				??00AA catstr <??00A8>, ??00A9, ??00AA
			     4				??00A9 catstr <, >
			     4			endm
 06E1  50		     5				push  ax
 = ax			     5				??00AA catstr <ax>, ??00A9, ??00AA
 = , 			     5				??00A9 catstr <, >
 = <ax>			     4			??00AA catstr OPEN_DELIMITER, ??00AA, CLOSE_DELIMITER
			     4			__pushRegs ??00AA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00AA
			     5			else
			     5				regStack catstr ??00AA, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <ExplanationSeparator>, <si>
 06E2  8D 36 03B8 R	     3				lea si, ExplanationSeparator
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06E6			   *@C0087:
			     3			.repeat
 06E6  8A 04		     3				mov al,   [si]
 06E8  88 05		     3				mov [di], al
 06EA  46		     3				inc si
 06EB  47		     3				inc di
 06EC  0A C0		   *	    or	al, al
 06EE  75 F6		   *	    jne    @C0087
			     3			.until (al == 0)
 06F0  4E		     3			dec    si
 06F1  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00AC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00AC eq 0
 = <ax>			     5				??00AD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00AD substr regStack, 1, (??00AC - 1)
			     5				regStack substr regStack, (??00AC + 1)
			     5			endif
			     5			exitm ??00AD
			     4		%	for ??00AB, __popRegs(regStack) 
			     4				pop ??00AB
			     4			endm
 06F2  58		     5				pop ax
			     2				else
			     2					strcpy_c <ExplanationSeparator>, di
			     2				endif
			     3			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     2				if DEFINED(CommandBufferString)
			     2					strcpy CommandBufferString, di
			     3			SaveRegs ax
			     4			local reg, comma, regpushed
 = 			     4			??00AF     textequ <>
 = 			     4			??00B0 textequ <>
			     4			for       ??00AE, <ax>
			     4				push  ??00AE
			     4				??00B0 catstr <??00AE>, ??00AF, ??00B0
			     4				??00AF catstr <, >
			     4			endm
 06F3  50		     5				push  ax
 = ax			     5				??00B0 catstr <ax>, ??00AF, ??00B0
 = , 			     5				??00AF catstr <, >
 = <ax>			     4			??00B0 catstr OPEN_DELIMITER, ??00B0, CLOSE_DELIMITER
			     4			__pushRegs ??00B0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <ax>			     5				regStack catstr ??00B0
			     5			else
			     5				regStack catstr ??00B0, REG_SET_DELIMITER, regStack
			     5			endif
			     3			ifdifi   <CommandBufferString>, <si>
 06F4  8D 36 010D R	     3				lea si, CommandBufferString
			     3			endif
			     3			ifdifi <di>, <di>
			     3				lea di, di
			     3			endif
 06F8			   *@C0089:
			     3			.repeat
 06F8  8A 04		     3				mov al,   [si]
 06FA  88 05		     3				mov [di], al
 06FC  46		     3				inc si
 06FD  47		     3				inc di
 06FE  0A C0		   *	    or	al, al
 0700  75 F6		   *	    jne    @C0089
			     3			.until (al == 0)
 0702  4E		     3			dec    si
 0703  4F		     3			dec    di
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??00B2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??00B2 eq 0
 = <ax>			     5				??00B3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??00B3 substr regStack, 1, (??00B2 - 1)
			     5				regStack substr regStack, (??00B2 + 1)
			     5			endif
			     5			exitm ??00B3
			     4		%	for ??00B1, __popRegs(regStack) 
			     4				pop ??00B1
			     4			endm
 0704  58		     5				pop ax
			     2				else
			     2					strcpy_c <CommandBufferString>, di
			     2				endif
						printf_c <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
 0705  E9 FEB4					print_TotalRowCol
						jmp      ExitFailure
 0708			   *@C0083:
 0708  F8			
					ErrorUnexpectedChar:
 0709  5D		   *	    pop    bp
 070A  5F		   *	    pop    di
 070B  5E		   *	    pop    si
 070C  8B E5		   *	    mov    sp, bp
 070E  5D		   *	    pop    bp
 070F  C3		   *	    ret    00000h
 0710						mov bl,                  [FileBuffer]
						mov [TheUnexpectedChar], bl
				
 0710						print_FilePosition
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< LINHA !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 0710  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < LINHA >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00B5     textequ <>
			     5			??00B6 textequ <>
			     5			for       ??00B4, <ax>
			     5				push  ??00B4
			     5				??00B6 catstr <??00B4>, ??00B5, ??00B6
			     5				??00B5 catstr <, >
 0714  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00B6 catstr <ax>, ??00B5, ??00B6
 = <ax>			     5				??00B5 catstr <, >
			     5			??00B6 catstr OPEN_DELIMITER, ??00B6, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00B6
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00B6
			     6			else
			     6				regStack catstr ??00B6, REG_SET_DELIMITER, regStack
			     4			endif
 0715  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0719			   *@C008B:
			     4			endif
 0719  8A 04		     4			.repeat
 071B  88 05		     4				mov al,   [si]
 071D  46		     4				mov [di], al
 071E  47		     4				inc si
 071F  0A C0		   *	    or	al, al
 0721  75 F6		   *	    jne    @C008B
			     4				inc di
 0723  4E		     4			.until (al == 0)
 0724  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00B8 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00B8 eq 0
 = 			     6				??00B9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00B9 substr regStack, 1, (??00B8 - 1)
			     6				regStack substr regStack, (??00B8 + 1)
			     6			endif
			     5			exitm ??00B9
			     5		%	for ??00B7, __popRegs(regStack) 
			     5				pop ??00B7
 0725  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0726  C6 05 20		     5			endm
 0729  47		     5				mov byte ptr [di], ' '
 072A  C6 05 22		     5				inc di
 072D  47		     5				mov byte ptr [di], '"'
 072E  C6 05 4D		     5				inc di
 0731  47		     5				mov byte ptr [di], 'M'
 0732  C6 05 55		     5				inc di
 0735  47		     5				mov byte ptr [di], 'U'
 0736  C6 05 4C		     5				inc di
 0739  47		     5				mov byte ptr [di], 'L'
 073A  C6 05 22		     5				inc di
 073D  47		     5				mov byte ptr [di], '"'
 073E  C6 05 20		     5				inc di
 0741  47		     5				mov byte ptr [di], ' '
 0742  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00BB     textequ <>
			     5			??00BC textequ <>
			     5			for       ??00BA, <ax>
			     5				push  ??00BA
			     5				??00BC catstr <??00BA>, ??00BB, ??00BC
			     5				??00BB catstr <, >
 0745  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00BC catstr <ax>, ??00BB, ??00BC
 = <ax>			     5				??00BB catstr <, >
			     5			??00BC catstr OPEN_DELIMITER, ??00BC, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00BC
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00BC
			     6			else
			     6				regStack catstr ??00BC, REG_SET_DELIMITER, regStack
			     4			endif
 0746  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 074A			   *@C008D:
			     4			endif
 074A  8A 04		     4			.repeat
 074C  88 05		     4				mov al,   [si]
 074E  46		     4				mov [di], al
 074F  47		     4				inc si
 0750  0A C0		   *	    or	al, al
 0752  75 F6		   *	    jne    @C008D
			     4				inc di
 0754  4E		     4			.until (al == 0)
 0755  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00BE instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00BE eq 0
 = 			     6				??00BF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00BF substr regStack, 1, (??00BE - 1)
			     6				regStack substr regStack, (??00BE + 1)
			     6			endif
			     5			exitm ??00BF
			     5		%	for ??00BD, __popRegs(regStack) 
			     5				pop ??00BD
 0756  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0757  C6 05 20		     5			endm
 075A  47		     5				mov byte ptr [di], ' '
 075B  C6 05 4C		     5				inc di
 075E  47		     5				mov byte ptr [di], 'L'
 075F  C6 05 49		     5				inc di
 0762  47		     5				mov byte ptr [di], 'I'
 0763  C6 05 4E		     5				inc di
 0766  47		     5				mov byte ptr [di], 'N'
 0767  C6 05 48		     5				inc di
 076A  47		     5				mov byte ptr [di], 'H'
 076B  C6 05 41		     5				inc di
 076E  47		     5				mov byte ptr [di], 'A'
 076F  C6 05 20		     5				inc di
 0772  47		     5				mov byte ptr [di], ' '
 0773  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C1     textequ <>
			     5			??00C2 textequ <>
			     5			for       ??00C0, <ax>
			     5				push  ??00C0
			     5				??00C2 catstr <??00C0>, ??00C1, ??00C2
			     5				??00C1 catstr <, >
 0776  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C2 catstr <ax>, ??00C1, ??00C2
 = <ax>			     5				??00C1 catstr <, >
			     5			??00C2 catstr OPEN_DELIMITER, ??00C2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C2
			     6			else
			     6				regStack catstr ??00C2, REG_SET_DELIMITER, regStack
			     4			endif
 0777  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 077B			   *@C008F:
			     4			endif
 077B  8A 04		     4			.repeat
 077D  88 05		     4				mov al,   [si]
 077F  46		     4				mov [di], al
 0780  47		     4				inc si
 0781  0A C0		   *	    or	al, al
 0783  75 F6		   *	    jne    @C008F
			     4				inc di
 0785  4E		     4			.until (al == 0)
 0786  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00C4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00C4 eq 0
 = 			     6				??00C5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00C5 substr regStack, 1, (??00C4 - 1)
			     6				regStack substr regStack, (??00C4 + 1)
			     6			endif
			     5			exitm ??00C5
			     5		%	for ??00C3, __popRegs(regStack) 
			     5				pop ??00C3
 0787  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0788  C6 05 20		     5			endm
 078B  47		     5				mov byte ptr [di], ' '
 078C  C6 05 50		     5				inc di
 078F  47		     5				mov byte ptr [di], 'P'
 0790  C6 05 52		     5				inc di
 0793  47		     5				mov byte ptr [di], 'R'
 0794  C6 05 49		     5				inc di
 0797  47		     5				mov byte ptr [di], 'I'
 0798  C6 05 4D		     5				inc di
 079B  47		     5				mov byte ptr [di], 'M'
 079C  C6 05 45		     5				inc di
 079F  47		     5				mov byte ptr [di], 'E'
 07A0  C6 05 49		     5				inc di
 07A3  47		     5				mov byte ptr [di], 'I'
 07A4  C6 05 52		     5				inc di
 07A7  47		     5				mov byte ptr [di], 'R'
 07A8  C6 05 4F		     5				inc di
 07AB  47		     5				mov byte ptr [di], 'O'
 07AC  C6 05 20		     5				inc di
 07AF  47		     5				mov byte ptr [di], ' '
 07B0  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00C7     textequ <>
			     5			??00C8 textequ <>
			     5			for       ??00C6, <ax>
			     5				push  ??00C6
			     5				??00C8 catstr <??00C6>, ??00C7, ??00C8
			     5				??00C7 catstr <, >
 07B3  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00C8 catstr <ax>, ??00C7, ??00C8
 = <ax>			     5				??00C7 catstr <, >
			     5			??00C8 catstr OPEN_DELIMITER, ??00C8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00C8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00C8
			     6			else
			     6				regStack catstr ??00C8, REG_SET_DELIMITER, regStack
			     4			endif
 07B4  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07B8			   *@C0091:
			     4			endif
 07B8  8A 04		     4			.repeat
 07BA  88 05		     4				mov al,   [si]
 07BC  46		     4				mov [di], al
 07BD  47		     4				inc si
 07BE  0A C0		   *	    or	al, al
 07C0  75 F6		   *	    jne    @C0091
			     4				inc di
 07C2  4E		     4			.until (al == 0)
 07C3  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00CA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00CA eq 0
 = 			     6				??00CB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00CB substr regStack, 1, (??00CA - 1)
			     6				regStack substr regStack, (??00CA + 1)
			     6			endif
			     5			exitm ??00CB
			     5		%	for ??00C9, __popRegs(regStack) 
			     5				pop ??00C9
 07C4  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00CD     textequ <>
			     5			??00CE textequ <>
			     5			for       ??00CC, <ax>
			     5				push  ??00CC
			     5				??00CE catstr <??00CC>, ??00CD, ??00CE
			     5				??00CD catstr <, >
 07C5  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00CE catstr <ax>, ??00CD, ??00CE
 = <ax>			     5				??00CD catstr <, >
			     5			??00CE catstr OPEN_DELIMITER, ??00CE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00CE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00CE
			     6			else
			     6				regStack catstr ??00CE, REG_SET_DELIMITER, regStack
			     4			endif
 07C6  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07CA			   *@C0093:
			     4			endif
 07CA  8A 04		     4			.repeat
 07CC  88 05		     4				mov al,   [si]
 07CE  46		     4				mov [di], al
 07CF  47		     4				inc si
 07D0  0A C0		   *	    or	al, al
 07D2  75 F6		   *	    jne    @C0093
			     4				inc di
 07D4  4E		     4			.until (al == 0)
 07D5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D0 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D0 eq 0
 = 			     6				??00D1     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D1 substr regStack, 1, (??00D0 - 1)
			     6				regStack substr regStack, (??00D0 + 1)
			     6			endif
			     5			exitm ??00D1
			     5		%	for ??00CF, __popRegs(regStack) 
			     5				pop ??00CF
 07D6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D3     textequ <>
			     5			??00D4 textequ <>
			     5			for       ??00D2, <ax>
			     5				push  ??00D2
			     5				??00D4 catstr <??00D2>, ??00D3, ??00D4
			     5				??00D3 catstr <, >
 07D7  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00D4 catstr <ax>, ??00D3, ??00D4
 = <ax>			     5				??00D3 catstr <, >
			     5			??00D4 catstr OPEN_DELIMITER, ??00D4, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00D4
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00D4
			     6			else
			     6				regStack catstr ??00D4, REG_SET_DELIMITER, regStack
			     4			endif
 07D8  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07DC			   *@C0095:
			     4			endif
 07DC  8A 04		     4			.repeat
 07DE  88 05		     4				mov al,   [si]
 07E0  46		     4				mov [di], al
 07E1  47		     4				inc si
 07E2  0A C0		   *	    or	al, al
 07E4  75 F6		   *	    jne    @C0095
			     4				inc di
 07E6  4E		     4			.until (al == 0)
 07E7  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00D6 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00D6 eq 0
 = 			     6				??00D7     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00D7 substr regStack, 1, (??00D6 - 1)
			     6				regStack substr regStack, (??00D6 + 1)
			     6			endif
			     5			exitm ??00D7
			     5		%	for ??00D5, __popRegs(regStack) 
			     5				pop ??00D5
 07E8  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 07E9  C3					printf_c < Erro: caracter inexperado: ">
 07EA						invoke   printf_s, addr TheUnexpectedChar
				
 07EA						jmp ExitFailure
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "MUL" !>, @espera, !< CONSTANTE !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 07EA  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "MUL" >, @espera, < CONSTANTE >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00D9     textequ <>
			     5			??00DA textequ <>
			     5			for       ??00D8, <ax>
			     5				push  ??00D8
			     5				??00DA catstr <??00D8>, ??00D9, ??00DA
			     5				??00D9 catstr <, >
 07EE  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00DA catstr <ax>, ??00D9, ??00DA
 = <ax>			     5				??00D9 catstr <, >
			     5			??00DA catstr OPEN_DELIMITER, ??00DA, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00DA
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00DA
			     6			else
			     6				regStack catstr ??00DA, REG_SET_DELIMITER, regStack
			     4			endif
 07EF  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 07F3			   *@C0097:
			     4			endif
 07F3  8A 04		     4			.repeat
 07F5  88 05		     4				mov al,   [si]
 07F7  46		     4				mov [di], al
 07F8  47		     4				inc si
 07F9  0A C0		   *	    or	al, al
 07FB  75 F6		   *	    jne    @C0097
			     4				inc di
 07FD  4E		     4			.until (al == 0)
 07FE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00DC instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00DC eq 0
 = 			     6				??00DD     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00DD substr regStack, 1, (??00DC - 1)
			     6				regStack substr regStack, (??00DC + 1)
			     6			endif
			     5			exitm ??00DD
			     5		%	for ??00DB, __popRegs(regStack) 
			     5				pop ??00DB
 07FF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "MUL"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "MUL" )
			     3					strcpy  "MUL" , di
			     3				else
			     4					strcpy_c < "MUL" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "MUL" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0800  C6 05 20		     5			endm
 0803  47		     5				mov byte ptr [di], ' '
 0804  C6 05 22		     5				inc di
 0807  47		     5				mov byte ptr [di], '"'
 0808  C6 05 4D		     5				inc di
 080B  47		     5				mov byte ptr [di], 'M'
 080C  C6 05 55		     5				inc di
 080F  47		     5				mov byte ptr [di], 'U'
 0810  C6 05 4C		     5				inc di
 0813  47		     5				mov byte ptr [di], 'L'
 0814  C6 05 22		     5				inc di
 0817  47		     5				mov byte ptr [di], '"'
 0818  C6 05 20		     5				inc di
 081B  47		     5				mov byte ptr [di], ' '
 081C  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00DF     textequ <>
			     5			??00E0 textequ <>
			     5			for       ??00DE, <ax>
			     5				push  ??00DE
			     5				??00E0 catstr <??00DE>, ??00DF, ??00E0
			     5				??00DF catstr <, >
 081F  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E0 catstr <ax>, ??00DF, ??00E0
 = <ax>			     5				??00DF catstr <, >
			     5			??00E0 catstr OPEN_DELIMITER, ??00E0, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E0
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E0
			     6			else
			     6				regStack catstr ??00E0, REG_SET_DELIMITER, regStack
			     4			endif
 0820  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0824			   *@C0099:
			     4			endif
 0824  8A 04		     4			.repeat
 0826  88 05		     4				mov al,   [si]
 0828  46		     4				mov [di], al
 0829  47		     4				inc si
 082A  0A C0		   *	    or	al, al
 082C  75 F6		   *	    jne    @C0099
			     4				inc di
 082E  4E		     4			.until (al == 0)
 082F  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E2 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E2 eq 0
 = 			     6				??00E3     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E3 substr regStack, 1, (??00E2 - 1)
			     6				regStack substr regStack, (??00E2 + 1)
			     6			endif
			     5			exitm ??00E3
			     5		%	for ??00E1, __popRegs(regStack) 
			     5				pop ??00E1
 0830  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF CONSTANTE
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( CONSTANTE )
			     3					strcpy  CONSTANTE , di
			     3				else
			     4					strcpy_c < CONSTANTE >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < CONSTANTE >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0831  C6 05 20		     5			endm
 0834  47		     5				mov byte ptr [di], ' '
 0835  C6 05 43		     5				inc di
 0838  47		     5				mov byte ptr [di], 'C'
 0839  C6 05 4F		     5				inc di
 083C  47		     5				mov byte ptr [di], 'O'
 083D  C6 05 4E		     5				inc di
 0840  47		     5				mov byte ptr [di], 'N'
 0841  C6 05 53		     5				inc di
 0844  47		     5				mov byte ptr [di], 'S'
 0845  C6 05 54		     5				inc di
 0848  47		     5				mov byte ptr [di], 'T'
 0849  C6 05 41		     5				inc di
 084C  47		     5				mov byte ptr [di], 'A'
 084D  C6 05 4E		     5				inc di
 0850  47		     5				mov byte ptr [di], 'N'
 0851  C6 05 54		     5				inc di
 0854  47		     5				mov byte ptr [di], 'T'
 0855  C6 05 45		     5				inc di
 0858  47		     5				mov byte ptr [di], 'E'
 0859  C6 05 20		     5				inc di
 085C  47		     5				mov byte ptr [di], ' '
 085D  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00E5     textequ <>
			     5			??00E6 textequ <>
			     5			for       ??00E4, <ax>
			     5				push  ??00E4
			     5				??00E6 catstr <??00E4>, ??00E5, ??00E6
			     5				??00E5 catstr <, >
 0860  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00E6 catstr <ax>, ??00E5, ??00E6
 = <ax>			     5				??00E5 catstr <, >
			     5			??00E6 catstr OPEN_DELIMITER, ??00E6, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00E6
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00E6
			     6			else
			     6				regStack catstr ??00E6, REG_SET_DELIMITER, regStack
			     4			endif
 0861  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0865			   *@C009B:
			     4			endif
 0865  8A 04		     4			.repeat
 0867  88 05		     4				mov al,   [si]
 0869  46		     4				mov [di], al
 086A  47		     4				inc si
 086B  0A C0		   *	    or	al, al
 086D  75 F6		   *	    jne    @C009B
			     4				inc di
 086F  4E		     4			.until (al == 0)
 0870  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00E8 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00E8 eq 0
 = 			     6				??00E9     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00E9 substr regStack, 1, (??00E8 - 1)
			     6				regStack substr regStack, (??00E8 + 1)
			     6			endif
			     5			exitm ??00E9
			     5		%	for ??00E7, __popRegs(regStack) 
			     5				pop ??00E7
 0871  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0872  C6 05 20		     5			endm
 0875  47		     5				mov byte ptr [di], ' '
 0876  C6 05 53		     5				inc di
 0879  47		     5				mov byte ptr [di], 'S'
 087A  C6 05 45		     5				inc di
 087D  47		     5				mov byte ptr [di], 'E'
 087E  C6 05 47		     5				inc di
 0881  47		     5				mov byte ptr [di], 'G'
 0882  C6 05 55		     5				inc di
 0885  47		     5				mov byte ptr [di], 'U'
 0886  C6 05 4E		     5				inc di
 0889  47		     5				mov byte ptr [di], 'N'
 088A  C6 05 44		     5				inc di
 088D  47		     5				mov byte ptr [di], 'D'
 088E  C6 05 4F		     5				inc di
 0891  47		     5				mov byte ptr [di], 'O'
 0892  C6 05 20		     5				inc di
 0895  47		     5				mov byte ptr [di], ' '
 0896  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00EB     textequ <>
			     5			??00EC textequ <>
			     5			for       ??00EA, <ax>
			     5				push  ??00EA
			     5				??00EC catstr <??00EA>, ??00EB, ??00EC
			     5				??00EB catstr <, >
 0899  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00EC catstr <ax>, ??00EB, ??00EC
 = <ax>			     5				??00EB catstr <, >
			     5			??00EC catstr OPEN_DELIMITER, ??00EC, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00EC
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00EC
			     6			else
			     6				regStack catstr ??00EC, REG_SET_DELIMITER, regStack
			     4			endif
 089A  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 089E			   *@C009D:
			     4			endif
 089E  8A 04		     4			.repeat
 08A0  88 05		     4				mov al,   [si]
 08A2  46		     4				mov [di], al
 08A3  47		     4				inc si
 08A4  0A C0		   *	    or	al, al
 08A6  75 F6		   *	    jne    @C009D
			     4				inc di
 08A8  4E		     4			.until (al == 0)
 08A9  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00EE instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00EE eq 0
 = 			     6				??00EF     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00EF substr regStack, 1, (??00EE - 1)
			     6				regStack substr regStack, (??00EE + 1)
			     6			endif
			     5			exitm ??00EF
			     5		%	for ??00ED, __popRegs(regStack) 
			     5				pop ??00ED
 08AA  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F1     textequ <>
			     5			??00F2 textequ <>
			     5			for       ??00F0, <ax>
			     5				push  ??00F0
			     5				??00F2 catstr <??00F0>, ??00F1, ??00F2
			     5				??00F1 catstr <, >
 08AB  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F2 catstr <ax>, ??00F1, ??00F2
 = <ax>			     5				??00F1 catstr <, >
			     5			??00F2 catstr OPEN_DELIMITER, ??00F2, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F2
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F2
			     6			else
			     6				regStack catstr ??00F2, REG_SET_DELIMITER, regStack
			     4			endif
 08AC  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08B0			   *@C009F:
			     4			endif
 08B0  8A 04		     4			.repeat
 08B2  88 05		     4				mov al,   [si]
 08B4  46		     4				mov [di], al
 08B5  47		     4				inc si
 08B6  0A C0		   *	    or	al, al
 08B8  75 F6		   *	    jne    @C009F
			     4				inc di
 08BA  4E		     4			.until (al == 0)
 08BB  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00F4 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00F4 eq 0
 = 			     6				??00F5     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00F5 substr regStack, 1, (??00F4 - 1)
			     6				regStack substr regStack, (??00F4 + 1)
			     6			endif
			     5			exitm ??00F5
			     5		%	for ??00F3, __popRegs(regStack) 
			     5				pop ??00F3
 08BC  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00F7     textequ <>
			     5			??00F8 textequ <>
			     5			for       ??00F6, <ax>
			     5				push  ??00F6
			     5				??00F8 catstr <??00F6>, ??00F7, ??00F8
			     5				??00F7 catstr <, >
 08BD  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00F8 catstr <ax>, ??00F7, ??00F8
 = <ax>			     5				??00F7 catstr <, >
			     5			??00F8 catstr OPEN_DELIMITER, ??00F8, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00F8
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00F8
			     6			else
			     6				regStack catstr ??00F8, REG_SET_DELIMITER, regStack
			     4			endif
 08BE  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08C2			   *@C00A1:
			     4			endif
 08C2  8A 04		     4			.repeat
 08C4  88 05		     4				mov al,   [si]
 08C6  46		     4				mov [di], al
 08C7  47		     4				inc si
 08C8  0A C0		   *	    or	al, al
 08CA  75 F6		   *	    jne    @C00A1
			     4				inc di
 08CC  4E		     4			.until (al == 0)
 08CD  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??00FA instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??00FA eq 0
 = 			     6				??00FB     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??00FB substr regStack, 1, (??00FA - 1)
			     6				regStack substr regStack, (??00FA + 1)
			     6			endif
			     5			exitm ??00FB
			     5		%	for ??00F9, __popRegs(regStack) 
			     5				pop ??00F9
 08CE  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 08CF  C3				ErrorInvalidN:
 08D0						print_FilePosition
						printf_c < Erro: N deve estar entre 2 e 7. N encontrado: >
 08D0						invoke   printf_u, N
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_DST !>, @como, !< PRIMEIRO !>, @parametro, ExplanationSeparator, CommandBufferString>
 08D0  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_DST >, @como, < PRIMEIRO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??00FD     textequ <>
			     5			??00FE textequ <>
			     5			for       ??00FC, <ax>
			     5				push  ??00FC
			     5				??00FE catstr <??00FC>, ??00FD, ??00FE
			     5				??00FD catstr <, >
 08D4  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??00FE catstr <ax>, ??00FD, ??00FE
 = <ax>			     5				??00FD catstr <, >
			     5			??00FE catstr OPEN_DELIMITER, ??00FE, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??00FE
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??00FE
			     6			else
			     6				regStack catstr ??00FE, REG_SET_DELIMITER, regStack
			     4			endif
 08D5  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 08D9			   *@C00A3:
			     4			endif
 08D9  8A 04		     4			.repeat
 08DB  88 05		     4				mov al,   [si]
 08DD  46		     4				mov [di], al
 08DE  47		     4				inc si
 08DF  0A C0		   *	    or	al, al
 08E1  75 F6		   *	    jne    @C00A3
			     4				inc di
 08E3  4E		     4			.until (al == 0)
 08E4  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0100 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0100 eq 0
 = 			     6				??0101     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0101 substr regStack, 1, (??0100 - 1)
			     6				regStack substr regStack, (??0100 + 1)
			     6			endif
			     5			exitm ??0101
			     5		%	for ??00FF, __popRegs(regStack) 
			     5				pop ??00FF
 08E5  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 08E6  C6 05 20		     5			endm
 08E9  47		     5				mov byte ptr [di], ' '
 08EA  C6 05 22		     5				inc di
 08ED  47		     5				mov byte ptr [di], '"'
 08EE  C6 05 41		     5				inc di
 08F1  47		     5				mov byte ptr [di], 'A'
 08F2  C6 05 44		     5				inc di
 08F5  47		     5				mov byte ptr [di], 'D'
 08F6  C6 05 44		     5				inc di
 08F9  47		     5				mov byte ptr [di], 'D'
 08FA  C6 05 22		     5				inc di
 08FD  47		     5				mov byte ptr [di], '"'
 08FE  C6 05 20		     5				inc di
 0901  47		     5				mov byte ptr [di], ' '
 0902  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0103     textequ <>
			     5			??0104 textequ <>
			     5			for       ??0102, <ax>
			     5				push  ??0102
			     5				??0104 catstr <??0102>, ??0103, ??0104
			     5				??0103 catstr <, >
 0905  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0104 catstr <ax>, ??0103, ??0104
 = <ax>			     5				??0103 catstr <, >
			     5			??0104 catstr OPEN_DELIMITER, ??0104, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0104
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0104
			     6			else
			     6				regStack catstr ??0104, REG_SET_DELIMITER, regStack
			     4			endif
 0906  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 090A			   *@C00A5:
			     4			endif
 090A  8A 04		     4			.repeat
 090C  88 05		     4				mov al,   [si]
 090E  46		     4				mov [di], al
 090F  47		     4				inc si
 0910  0A C0		   *	    or	al, al
 0912  75 F6		   *	    jne    @C00A5
			     4				inc di
 0914  4E		     4			.until (al == 0)
 0915  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0106 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0106 eq 0
 = 			     6				??0107     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0107 substr regStack, 1, (??0106 - 1)
			     6				regStack substr regStack, (??0106 + 1)
			     6			endif
			     5			exitm ??0107
			     5		%	for ??0105, __popRegs(regStack) 
			     5				pop ??0105
 0916  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0917  C6 05 20		     5			endm
 091A  47		     5				mov byte ptr [di], ' '
 091B  C6 05 4C		     5				inc di
 091E  47		     5				mov byte ptr [di], 'L'
 091F  C6 05 49		     5				inc di
 0922  47		     5				mov byte ptr [di], 'I'
 0923  C6 05 4E		     5				inc di
 0926  47		     5				mov byte ptr [di], 'N'
 0927  C6 05 48		     5				inc di
 092A  47		     5				mov byte ptr [di], 'H'
 092B  C6 05 41		     5				inc di
 092E  47		     5				mov byte ptr [di], 'A'
 092F  C6 05 5F		     5				inc di
 0932  47		     5				mov byte ptr [di], '_'
 0933  C6 05 44		     5				inc di
 0936  47		     5				mov byte ptr [di], 'D'
 0937  C6 05 53		     5				inc di
 093A  47		     5				mov byte ptr [di], 'S'
 093B  C6 05 54		     5				inc di
 093E  47		     5				mov byte ptr [di], 'T'
 093F  C6 05 20		     5				inc di
 0942  47		     5				mov byte ptr [di], ' '
 0943  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0109     textequ <>
			     5			??010A textequ <>
			     5			for       ??0108, <ax>
			     5				push  ??0108
			     5				??010A catstr <??0108>, ??0109, ??010A
			     5				??0109 catstr <, >
 0946  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??010A catstr <ax>, ??0109, ??010A
 = <ax>			     5				??0109 catstr <, >
			     5			??010A catstr OPEN_DELIMITER, ??010A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??010A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??010A
			     6			else
			     6				regStack catstr ??010A, REG_SET_DELIMITER, regStack
			     4			endif
 0947  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 094B			   *@C00A7:
			     4			endif
 094B  8A 04		     4			.repeat
 094D  88 05		     4				mov al,   [si]
 094F  46		     4				mov [di], al
 0950  47		     4				inc si
 0951  0A C0		   *	    or	al, al
 0953  75 F6		   *	    jne    @C00A7
			     4				inc di
 0955  4E		     4			.until (al == 0)
 0956  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??010C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??010C eq 0
 = 			     6				??010D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??010D substr regStack, 1, (??010C - 1)
			     6				regStack substr regStack, (??010C + 1)
			     6			endif
			     5			exitm ??010D
			     5		%	for ??010B, __popRegs(regStack) 
			     5				pop ??010B
 0957  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF PRIMEIRO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( PRIMEIRO )
			     3					strcpy  PRIMEIRO , di
			     3				else
			     4					strcpy_c < PRIMEIRO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < PRIMEIRO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0958  C6 05 20		     5			endm
 095B  47		     5				mov byte ptr [di], ' '
 095C  C6 05 50		     5				inc di
 095F  47		     5				mov byte ptr [di], 'P'
 0960  C6 05 52		     5				inc di
 0963  47		     5				mov byte ptr [di], 'R'
 0964  C6 05 49		     5				inc di
 0967  47		     5				mov byte ptr [di], 'I'
 0968  C6 05 4D		     5				inc di
 096B  47		     5				mov byte ptr [di], 'M'
 096C  C6 05 45		     5				inc di
 096F  47		     5				mov byte ptr [di], 'E'
 0970  C6 05 49		     5				inc di
 0973  47		     5				mov byte ptr [di], 'I'
 0974  C6 05 52		     5				inc di
 0977  47		     5				mov byte ptr [di], 'R'
 0978  C6 05 4F		     5				inc di
 097B  47		     5				mov byte ptr [di], 'O'
 097C  C6 05 20		     5				inc di
 097F  47		     5				mov byte ptr [di], ' '
 0980  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??010F     textequ <>
			     5			??0110 textequ <>
			     5			for       ??010E, <ax>
			     5				push  ??010E
			     5				??0110 catstr <??010E>, ??010F, ??0110
			     5				??010F catstr <, >
 0983  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0110 catstr <ax>, ??010F, ??0110
 = <ax>			     5				??010F catstr <, >
			     5			??0110 catstr OPEN_DELIMITER, ??0110, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0110
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0110
			     6			else
			     6				regStack catstr ??0110, REG_SET_DELIMITER, regStack
			     4			endif
 0984  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0988			   *@C00A9:
			     4			endif
 0988  8A 04		     4			.repeat
 098A  88 05		     4				mov al,   [si]
 098C  46		     4				mov [di], al
 098D  47		     4				inc si
 098E  0A C0		   *	    or	al, al
 0990  75 F6		   *	    jne    @C00A9
			     4				inc di
 0992  4E		     4			.until (al == 0)
 0993  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0112 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0112 eq 0
 = 			     6				??0113     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0113 substr regStack, 1, (??0112 - 1)
			     6				regStack substr regStack, (??0112 + 1)
			     6			endif
			     5			exitm ??0113
			     5		%	for ??0111, __popRegs(regStack) 
			     5				pop ??0111
 0994  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0115     textequ <>
			     5			??0116 textequ <>
			     5			for       ??0114, <ax>
			     5				push  ??0114
			     5				??0116 catstr <??0114>, ??0115, ??0116
			     5				??0115 catstr <, >
 0995  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0116 catstr <ax>, ??0115, ??0116
 = <ax>			     5				??0115 catstr <, >
			     5			??0116 catstr OPEN_DELIMITER, ??0116, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0116
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0116
			     6			else
			     6				regStack catstr ??0116, REG_SET_DELIMITER, regStack
			     4			endif
 0996  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 099A			   *@C00AB:
			     4			endif
 099A  8A 04		     4			.repeat
 099C  88 05		     4				mov al,   [si]
 099E  46		     4				mov [di], al
 099F  47		     4				inc si
 09A0  0A C0		   *	    or	al, al
 09A2  75 F6		   *	    jne    @C00AB
			     4				inc di
 09A4  4E		     4			.until (al == 0)
 09A5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0118 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0118 eq 0
 = 			     6				??0119     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0119 substr regStack, 1, (??0118 - 1)
			     6				regStack substr regStack, (??0118 + 1)
			     6			endif
			     5			exitm ??0119
			     5		%	for ??0117, __popRegs(regStack) 
			     5				pop ??0117
 09A6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??011B     textequ <>
			     5			??011C textequ <>
			     5			for       ??011A, <ax>
			     5				push  ??011A
			     5				??011C catstr <??011A>, ??011B, ??011C
			     5				??011B catstr <, >
 09A7  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??011C catstr <ax>, ??011B, ??011C
 = <ax>			     5				??011B catstr <, >
			     5			??011C catstr OPEN_DELIMITER, ??011C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??011C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??011C
			     6			else
			     6				regStack catstr ??011C, REG_SET_DELIMITER, regStack
			     4			endif
 09A8  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09AC			   *@C00AD:
			     4			endif
 09AC  8A 04		     4			.repeat
 09AE  88 05		     4				mov al,   [si]
 09B0  46		     4				mov [di], al
 09B1  47		     4				inc si
 09B2  0A C0		   *	    or	al, al
 09B4  75 F6		   *	    jne    @C00AD
			     4				inc di
 09B6  4E		     4			.until (al == 0)
 09B7  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??011E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??011E eq 0
 = 			     6				??011F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??011F substr regStack, 1, (??011E - 1)
			     6				regStack substr regStack, (??011E + 1)
			     6			endif
			     5			exitm ??011F
			     5		%	for ??011D, __popRegs(regStack) 
			     5				pop ??011D
 09B8  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 09B9  C3			
 09BA					ErrorInvalidCommand:
						printf_c <Unable to parse command: >
 09BA						invoke   printf_s, addr CommandBufferString
						jmp      ExitFailure
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@Comando, !< "ADD" !>, @espera, !< LINHA_ORG !>, @como, !< SEGUNDO !>, @parametro, ExplanationSeparator, CommandBufferString>
 09BA  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@Comando, < "ADD" >, @espera, < LINHA_ORG >, @como, < SEGUNDO >, @parametro, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @Comando
			     3				EXITM <-1> 
			     3				if DEFINED(@Comando)
			     4					strcpy @Comando, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0121     textequ <>
			     5			??0122 textequ <>
			     5			for       ??0120, <ax>
			     5				push  ??0120
			     5				??0122 catstr <??0120>, ??0121, ??0122
			     5				??0121 catstr <, >
 09BE  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0122 catstr <ax>, ??0121, ??0122
 = <ax>			     5				??0121 catstr <, >
			     5			??0122 catstr OPEN_DELIMITER, ??0122, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0122
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0122
			     6			else
			     6				regStack catstr ??0122, REG_SET_DELIMITER, regStack
			     4			endif
 09BF  8D 36 0310 R	     4			ifdifi   <@Comando>, <si>
			     4				lea si, @Comando
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09C3			   *@C00AF:
			     4			endif
 09C3  8A 04		     4			.repeat
 09C5  88 05		     4				mov al,   [si]
 09C7  46		     4				mov [di], al
 09C8  47		     4				inc si
 09C9  0A C0		   *	    or	al, al
 09CB  75 F6		   *	    jne    @C00AF
			     4				inc di
 09CD  4E		     4			.until (al == 0)
 09CE  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0124 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0124 eq 0
 = 			     6				??0125     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0125 substr regStack, 1, (??0124 - 1)
			     6				regStack substr regStack, (??0124 + 1)
			     6			endif
			     5			exitm ??0125
			     5		%	for ??0123, __popRegs(regStack) 
			     5				pop ??0123
 09CF  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@Comando>, di
			     4				endif
			     4			IFDEF "ADD"
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( "ADD" )
			     3					strcpy  "ADD" , di
			     3				else
			     4					strcpy_c < "ADD" >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < "ADD" >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 09D0  C6 05 20		     5			endm
 09D3  47		     5				mov byte ptr [di], ' '
 09D4  C6 05 22		     5				inc di
 09D7  47		     5				mov byte ptr [di], '"'
 09D8  C6 05 41		     5				inc di
 09DB  47		     5				mov byte ptr [di], 'A'
 09DC  C6 05 44		     5				inc di
 09DF  47		     5				mov byte ptr [di], 'D'
 09E0  C6 05 44		     5				inc di
 09E3  47		     5				mov byte ptr [di], 'D'
 09E4  C6 05 22		     5				inc di
 09E7  47		     5				mov byte ptr [di], '"'
 09E8  C6 05 20		     5				inc di
 09EB  47		     5				mov byte ptr [di], ' '
 09EC  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @espera
			     3				EXITM <-1> 
			     3				if DEFINED(@espera)
			     4					strcpy @espera, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0127     textequ <>
			     5			??0128 textequ <>
			     5			for       ??0126, <ax>
			     5				push  ??0126
			     5				??0128 catstr <??0126>, ??0127, ??0128
			     5				??0127 catstr <, >
 09EF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0128 catstr <ax>, ??0127, ??0128
 = <ax>			     5				??0127 catstr <, >
			     5			??0128 catstr OPEN_DELIMITER, ??0128, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0128
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0128
			     6			else
			     6				regStack catstr ??0128, REG_SET_DELIMITER, regStack
			     4			endif
 09F0  8D 36 0318 R	     4			ifdifi   <@espera>, <si>
			     4				lea si, @espera
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 09F4			   *@C00B1:
			     4			endif
 09F4  8A 04		     4			.repeat
 09F6  88 05		     4				mov al,   [si]
 09F8  46		     4				mov [di], al
 09F9  47		     4				inc si
 09FA  0A C0		   *	    or	al, al
 09FC  75 F6		   *	    jne    @C00B1
			     4				inc di
 09FE  4E		     4			.until (al == 0)
 09FF  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??012A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??012A eq 0
 = 			     6				??012B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??012B substr regStack, 1, (??012A - 1)
			     6				regStack substr regStack, (??012A + 1)
			     6			endif
			     5			exitm ??012B
			     5		%	for ??0129, __popRegs(regStack) 
			     5				pop ??0129
 0A00  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@espera>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A01  C6 05 20		     5			endm
 0A04  47		     5				mov byte ptr [di], ' '
 0A05  C6 05 4C		     5				inc di
 0A08  47		     5				mov byte ptr [di], 'L'
 0A09  C6 05 49		     5				inc di
 0A0C  47		     5				mov byte ptr [di], 'I'
 0A0D  C6 05 4E		     5				inc di
 0A10  47		     5				mov byte ptr [di], 'N'
 0A11  C6 05 48		     5				inc di
 0A14  47		     5				mov byte ptr [di], 'H'
 0A15  C6 05 41		     5				inc di
 0A18  47		     5				mov byte ptr [di], 'A'
 0A19  C6 05 5F		     5				inc di
 0A1C  47		     5				mov byte ptr [di], '_'
 0A1D  C6 05 4F		     5				inc di
 0A20  47		     5				mov byte ptr [di], 'O'
 0A21  C6 05 52		     5				inc di
 0A24  47		     5				mov byte ptr [di], 'R'
 0A25  C6 05 47		     5				inc di
 0A28  47		     5				mov byte ptr [di], 'G'
 0A29  C6 05 20		     5				inc di
 0A2C  47		     5				mov byte ptr [di], ' '
 0A2D  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @como
			     3				EXITM <-1> 
			     3				if DEFINED(@como)
			     4					strcpy @como, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??012D     textequ <>
			     5			??012E textequ <>
			     5			for       ??012C, <ax>
			     5				push  ??012C
			     5				??012E catstr <??012C>, ??012D, ??012E
			     5				??012D catstr <, >
 0A30  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??012E catstr <ax>, ??012D, ??012E
 = <ax>			     5				??012D catstr <, >
			     5			??012E catstr OPEN_DELIMITER, ??012E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??012E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??012E
			     6			else
			     6				regStack catstr ??012E, REG_SET_DELIMITER, regStack
			     4			endif
 0A31  8D 36 031F R	     4			ifdifi   <@como>, <si>
			     4				lea si, @como
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A35			   *@C00B3:
			     4			endif
 0A35  8A 04		     4			.repeat
 0A37  88 05		     4				mov al,   [si]
 0A39  46		     4				mov [di], al
 0A3A  47		     4				inc si
 0A3B  0A C0		   *	    or	al, al
 0A3D  75 F6		   *	    jne    @C00B3
			     4				inc di
 0A3F  4E		     4			.until (al == 0)
 0A40  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0130 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0130 eq 0
 = 			     6				??0131     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0131 substr regStack, 1, (??0130 - 1)
			     6				regStack substr regStack, (??0130 + 1)
			     6			endif
			     5			exitm ??0131
			     5		%	for ??012F, __popRegs(regStack) 
			     5				pop ??012F
 0A41  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@como>, di
			     4				endif
			     4			IFDEF SEGUNDO
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( SEGUNDO )
			     3					strcpy  SEGUNDO , di
			     3				else
			     4					strcpy_c < SEGUNDO >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < SEGUNDO >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0A42  C6 05 20		     5			endm
 0A45  47		     5				mov byte ptr [di], ' '
 0A46  C6 05 53		     5				inc di
 0A49  47		     5				mov byte ptr [di], 'S'
 0A4A  C6 05 45		     5				inc di
 0A4D  47		     5				mov byte ptr [di], 'E'
 0A4E  C6 05 47		     5				inc di
 0A51  47		     5				mov byte ptr [di], 'G'
 0A52  C6 05 55		     5				inc di
 0A55  47		     5				mov byte ptr [di], 'U'
 0A56  C6 05 4E		     5				inc di
 0A59  47		     5				mov byte ptr [di], 'N'
 0A5A  C6 05 44		     5				inc di
 0A5D  47		     5				mov byte ptr [di], 'D'
 0A5E  C6 05 4F		     5				inc di
 0A61  47		     5				mov byte ptr [di], 'O'
 0A62  C6 05 20		     5				inc di
 0A65  47		     5				mov byte ptr [di], ' '
 0A66  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@parametro)
			     4					strcpy @parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0133     textequ <>
			     5			??0134 textequ <>
			     5			for       ??0132, <ax>
			     5				push  ??0132
			     5				??0134 catstr <??0132>, ??0133, ??0134
			     5				??0133 catstr <, >
 0A69  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0134 catstr <ax>, ??0133, ??0134
 = <ax>			     5				??0133 catstr <, >
			     5			??0134 catstr OPEN_DELIMITER, ??0134, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0134
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0134
			     6			else
			     6				regStack catstr ??0134, REG_SET_DELIMITER, regStack
			     4			endif
 0A6A  8D 36 0324 R	     4			ifdifi   <@parametro>, <si>
			     4				lea si, @parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A6E			   *@C00B5:
			     4			endif
 0A6E  8A 04		     4			.repeat
 0A70  88 05		     4				mov al,   [si]
 0A72  46		     4				mov [di], al
 0A73  47		     4				inc si
 0A74  0A C0		   *	    or	al, al
 0A76  75 F6		   *	    jne    @C00B5
			     4				inc di
 0A78  4E		     4			.until (al == 0)
 0A79  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0136 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0136 eq 0
 = 			     6				??0137     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0137 substr regStack, 1, (??0136 - 1)
			     6				regStack substr regStack, (??0136 + 1)
			     6			endif
			     5			exitm ??0137
			     5		%	for ??0135, __popRegs(regStack) 
			     5				pop ??0135
 0A7A  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@parametro>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0139     textequ <>
			     5			??013A textequ <>
			     5			for       ??0138, <ax>
			     5				push  ??0138
			     5				??013A catstr <??0138>, ??0139, ??013A
			     5				??0139 catstr <, >
 0A7B  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??013A catstr <ax>, ??0139, ??013A
 = <ax>			     5				??0139 catstr <, >
			     5			??013A catstr OPEN_DELIMITER, ??013A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??013A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??013A
			     6			else
			     6				regStack catstr ??013A, REG_SET_DELIMITER, regStack
			     4			endif
 0A7C  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A80			   *@C00B7:
			     4			endif
 0A80  8A 04		     4			.repeat
 0A82  88 05		     4				mov al,   [si]
 0A84  46		     4				mov [di], al
 0A85  47		     4				inc si
 0A86  0A C0		   *	    or	al, al
 0A88  75 F6		   *	    jne    @C00B7
			     4				inc di
 0A8A  4E		     4			.until (al == 0)
 0A8B  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??013C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??013C eq 0
 = 			     6				??013D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??013D substr regStack, 1, (??013C - 1)
			     6				regStack substr regStack, (??013C + 1)
			     6			endif
			     5			exitm ??013D
			     5		%	for ??013B, __popRegs(regStack) 
			     5				pop ??013B
 0A8C  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??013F     textequ <>
			     5			??0140 textequ <>
			     5			for       ??013E, <ax>
			     5				push  ??013E
			     5				??0140 catstr <??013E>, ??013F, ??0140
			     5				??013F catstr <, >
 0A8D  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0140 catstr <ax>, ??013F, ??0140
 = <ax>			     5				??013F catstr <, >
			     5			??0140 catstr OPEN_DELIMITER, ??0140, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0140
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0140
			     6			else
			     6				regStack catstr ??0140, REG_SET_DELIMITER, regStack
			     4			endif
 0A8E  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0A92			   *@C00B9:
			     4			endif
 0A92  8A 04		     4			.repeat
 0A94  88 05		     4				mov al,   [si]
 0A96  46		     4				mov [di], al
 0A97  47		     4				inc si
 0A98  0A C0		   *	    or	al, al
 0A9A  75 F6		   *	    jne    @C00B9
			     4				inc di
 0A9C  4E		     4			.until (al == 0)
 0A9D  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0142 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0142 eq 0
 = 			     6				??0143     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0143 substr regStack, 1, (??0142 - 1)
			     6				regStack substr regStack, (??0142 + 1)
			     6			endif
			     5			exitm ??0143
			     5		%	for ??0141, __popRegs(regStack) 
			     5				pop ??0141
 0A9E  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0A9F  C3			
 0AA0				
				;====================================================================
 0AA0				; Reading Functions
				
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0AA0  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0145     textequ <>
			     5			??0146 textequ <>
			     5			for       ??0144, <ax>
			     5				push  ??0144
			     5				??0146 catstr <??0144>, ??0145, ??0146
			     5				??0145 catstr <, >
 0AA4  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0146 catstr <ax>, ??0145, ??0146
 = <ax>			     5				??0145 catstr <, >
			     5			??0146 catstr OPEN_DELIMITER, ??0146, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0146
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0146
			     6			else
			     6				regStack catstr ??0146, REG_SET_DELIMITER, regStack
			     4			endif
 0AA5  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AA9			   *@C00BB:
			     4			endif
 0AA9  8A 04		     4			.repeat
 0AAB  88 05		     4				mov al,   [si]
 0AAD  46		     4				mov [di], al
 0AAE  47		     4				inc si
 0AAF  0A C0		   *	    or	al, al
 0AB1  75 F6		   *	    jne    @C00BB
			     4				inc di
 0AB3  4E		     4			.until (al == 0)
 0AB4  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0148 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0148 eq 0
 = 			     6				??0149     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0149 substr regStack, 1, (??0148 - 1)
			     6				regStack substr regStack, (??0148 + 1)
			     6			endif
			     5			exitm ??0149
			     5		%	for ??0147, __popRegs(regStack) 
			     5				pop ??0147
 0AB5  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA )
			     3					strcpy  LINHA , di
			     3				else
			     4					strcpy_c < LINHA >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0AB6  C6 05 20		     5			endm
 0AB9  47		     5				mov byte ptr [di], ' '
 0ABA  C6 05 4C		     5				inc di
 0ABD  47		     5				mov byte ptr [di], 'L'
 0ABE  C6 05 49		     5				inc di
 0AC1  47		     5				mov byte ptr [di], 'I'
 0AC2  C6 05 4E		     5				inc di
 0AC5  47		     5				mov byte ptr [di], 'N'
 0AC6  C6 05 48		     5				inc di
 0AC9  47		     5				mov byte ptr [di], 'H'
 0ACA  C6 05 41		     5				inc di
 0ACD  47		     5				mov byte ptr [di], 'A'
 0ACE  C6 05 20		     5				inc di
 0AD1  47		     5				mov byte ptr [di], ' '
 0AD2  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??014B     textequ <>
			     5			??014C textequ <>
			     5			for       ??014A, <ax>
			     5				push  ??014A
			     5				??014C catstr <??014A>, ??014B, ??014C
			     5				??014B catstr <, >
 0AD5  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??014C catstr <ax>, ??014B, ??014C
 = <ax>			     5				??014B catstr <, >
			     5			??014C catstr OPEN_DELIMITER, ??014C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??014C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??014C
			     6			else
			     6				regStack catstr ??014C, REG_SET_DELIMITER, regStack
			     4			endif
 0AD6  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0ADA			   *@C00BD:
			     4			endif
 0ADA  8A 04		     4			.repeat
 0ADC  88 05		     4				mov al,   [si]
 0ADE  46		     4				mov [di], al
 0ADF  47		     4				inc si
 0AE0  0A C0		   *	    or	al, al
 0AE2  75 F6		   *	    jne    @C00BD
			     4				inc di
 0AE4  4E		     4			.until (al == 0)
 0AE5  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??014E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??014E eq 0
 = 			     6				??014F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??014F substr regStack, 1, (??014E - 1)
			     6				regStack substr regStack, (??014E + 1)
			     6			endif
			     5			exitm ??014F
			     5		%	for ??014D, __popRegs(regStack) 
			     5				pop ??014D
 0AE6  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0151     textequ <>
			     5			??0152 textequ <>
			     5			for       ??0150, <ax>
			     5				push  ??0150
			     5				??0152 catstr <??0150>, ??0151, ??0152
			     5				??0151 catstr <, >
 0AE7  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0152 catstr <ax>, ??0151, ??0152
 = <ax>			     5				??0151 catstr <, >
			     5			??0152 catstr OPEN_DELIMITER, ??0152, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0152
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0152
			     6			else
			     6				regStack catstr ??0152, REG_SET_DELIMITER, regStack
			     4			endif
 0AE8  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AEC			   *@C00BF:
			     4			endif
 0AEC  8A 04		     4			.repeat
 0AEE  88 05		     4				mov al,   [si]
 0AF0  46		     4				mov [di], al
 0AF1  47		     4				inc si
 0AF2  0A C0		   *	    or	al, al
 0AF4  75 F6		   *	    jne    @C00BF
			     4				inc di
 0AF6  4E		     4			.until (al == 0)
 0AF7  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0154 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0154 eq 0
 = 			     6				??0155     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0155 substr regStack, 1, (??0154 - 1)
			     6				regStack substr regStack, (??0154 + 1)
			     6			endif
			     5			exitm ??0155
			     5		%	for ??0153, __popRegs(regStack) 
			     5				pop ??0153
 0AF8  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0157     textequ <>
			     5			??0158 textequ <>
			     5			for       ??0156, <ax>
			     5				push  ??0156
			     5				??0158 catstr <??0156>, ??0157, ??0158
			     5				??0157 catstr <, >
 0AF9  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0158 catstr <ax>, ??0157, ??0158
 = <ax>			     5				??0157 catstr <, >
			     5			??0158 catstr OPEN_DELIMITER, ??0158, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0158
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0158
			     6			else
			     6				regStack catstr ??0158, REG_SET_DELIMITER, regStack
			     4			endif
 0AFA  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0AFE			   *@C00C1:
			     4			endif
 0AFE  8A 04		     4			.repeat
 0B00  88 05		     4				mov al,   [si]
 0B02  46		     4				mov [di], al
 0B03  47		     4				inc si
 0B04  0A C0		   *	    or	al, al
 0B06  75 F6		   *	    jne    @C00C1
			     4				inc di
 0B08  4E		     4			.until (al == 0)
 0B09  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??015A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??015A eq 0
 = 			     6				??015B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??015B substr regStack, 1, (??015A - 1)
			     6				regStack substr regStack, (??015A + 1)
			     6			endif
			     5			exitm ??015B
			     5		%	for ??0159, __popRegs(regStack) 
			     5				pop ??0159
 0B0A  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0B0B  C3				HandleCR macro
 0B0C						invoke PeekChar		mov    bh, PeekBuffer		.if    bh != LF			jmp ErrorUnexpectedChar		.endif	endm
					
 0B0C					ReadEmptyLines proc near uses RegsInvokeUses
						invoke ReadChar
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_DST !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0B0C  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_DST >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??015D     textequ <>
			     5			??015E textequ <>
			     5			for       ??015C, <ax>
			     5				push  ??015C
			     5				??015E catstr <??015C>, ??015D, ??015E
			     5				??015D catstr <, >
 0B10  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??015E catstr <ax>, ??015D, ??015E
 = <ax>			     5				??015D catstr <, >
			     5			??015E catstr OPEN_DELIMITER, ??015E, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??015E
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??015E
			     6			else
			     6				regStack catstr ??015E, REG_SET_DELIMITER, regStack
			     4			endif
 0B11  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B15			   *@C00C3:
			     4			endif
 0B15  8A 04		     4			.repeat
 0B17  88 05		     4				mov al,   [si]
 0B19  46		     4				mov [di], al
 0B1A  47		     4				inc si
 0B1B  0A C0		   *	    or	al, al
 0B1D  75 F6		   *	    jne    @C00C3
			     4				inc di
 0B1F  4E		     4			.until (al == 0)
 0B20  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0160 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0160 eq 0
 = 			     6				??0161     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0161 substr regStack, 1, (??0160 - 1)
			     6				regStack substr regStack, (??0160 + 1)
			     6			endif
			     5			exitm ??0161
			     5		%	for ??015F, __popRegs(regStack) 
			     5				pop ??015F
 0B21  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_DST
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_DST )
			     3					strcpy  LINHA_DST , di
			     3				else
			     4					strcpy_c < LINHA_DST >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_DST >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0B22  C6 05 20		     5			endm
 0B25  47		     5				mov byte ptr [di], ' '
 0B26  C6 05 4C		     5				inc di
 0B29  47		     5				mov byte ptr [di], 'L'
 0B2A  C6 05 49		     5				inc di
 0B2D  47		     5				mov byte ptr [di], 'I'
 0B2E  C6 05 4E		     5				inc di
 0B31  47		     5				mov byte ptr [di], 'N'
 0B32  C6 05 48		     5				inc di
 0B35  47		     5				mov byte ptr [di], 'H'
 0B36  C6 05 41		     5				inc di
 0B39  47		     5				mov byte ptr [di], 'A'
 0B3A  C6 05 5F		     5				inc di
 0B3D  47		     5				mov byte ptr [di], '_'
 0B3E  C6 05 44		     5				inc di
 0B41  47		     5				mov byte ptr [di], 'D'
 0B42  C6 05 53		     5				inc di
 0B45  47		     5				mov byte ptr [di], 'S'
 0B46  C6 05 54		     5				inc di
 0B49  47		     5				mov byte ptr [di], 'T'
 0B4A  C6 05 20		     5				inc di
 0B4D  47		     5				mov byte ptr [di], ' '
 0B4E  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0163     textequ <>
			     5			??0164 textequ <>
			     5			for       ??0162, <ax>
			     5				push  ??0162
			     5				??0164 catstr <??0162>, ??0163, ??0164
			     5				??0163 catstr <, >
 0B51  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0164 catstr <ax>, ??0163, ??0164
 = <ax>			     5				??0163 catstr <, >
			     5			??0164 catstr OPEN_DELIMITER, ??0164, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0164
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0164
			     6			else
			     6				regStack catstr ??0164, REG_SET_DELIMITER, regStack
			     4			endif
 0B52  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B56			   *@C00C5:
			     4			endif
 0B56  8A 04		     4			.repeat
 0B58  88 05		     4				mov al,   [si]
 0B5A  46		     4				mov [di], al
 0B5B  47		     4				inc si
 0B5C  0A C0		   *	    or	al, al
 0B5E  75 F6		   *	    jne    @C00C5
			     4				inc di
 0B60  4E		     4			.until (al == 0)
 0B61  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0166 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0166 eq 0
 = 			     6				??0167     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0167 substr regStack, 1, (??0166 - 1)
			     6				regStack substr regStack, (??0166 + 1)
			     6			endif
			     5			exitm ??0167
			     5		%	for ??0165, __popRegs(regStack) 
			     5				pop ??0165
 0B62  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0169     textequ <>
			     5			??016A textequ <>
			     5			for       ??0168, <ax>
			     5				push  ??0168
			     5				??016A catstr <??0168>, ??0169, ??016A
			     5				??0169 catstr <, >
 0B63  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??016A catstr <ax>, ??0169, ??016A
 = <ax>			     5				??0169 catstr <, >
			     5			??016A catstr OPEN_DELIMITER, ??016A, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??016A
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??016A
			     6			else
			     6				regStack catstr ??016A, REG_SET_DELIMITER, regStack
			     4			endif
 0B64  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B68			   *@C00C7:
			     4			endif
 0B68  8A 04		     4			.repeat
 0B6A  88 05		     4				mov al,   [si]
 0B6C  46		     4				mov [di], al
 0B6D  47		     4				inc si
 0B6E  0A C0		   *	    or	al, al
 0B70  75 F6		   *	    jne    @C00C7
			     4				inc di
 0B72  4E		     4			.until (al == 0)
 0B73  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??016C instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??016C eq 0
 = 			     6				??016D     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??016D substr regStack, 1, (??016C - 1)
			     6				regStack substr regStack, (??016C + 1)
			     6			endif
			     5			exitm ??016D
			     5		%	for ??016B, __popRegs(regStack) 
			     5				pop ??016B
 0B74  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??016F     textequ <>
			     5			??0170 textequ <>
			     5			for       ??016E, <ax>
			     5				push  ??016E
			     5				??0170 catstr <??016E>, ??016F, ??0170
			     5				??016F catstr <, >
 0B75  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0170 catstr <ax>, ??016F, ??0170
 = <ax>			     5				??016F catstr <, >
			     5			??0170 catstr OPEN_DELIMITER, ??0170, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0170
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0170
			     6			else
			     6				regStack catstr ??0170, REG_SET_DELIMITER, regStack
			     4			endif
 0B76  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B7A			   *@C00C9:
			     4			endif
 0B7A  8A 04		     4			.repeat
 0B7C  88 05		     4				mov al,   [si]
 0B7E  46		     4				mov [di], al
 0B7F  47		     4				inc si
 0B80  0A C0		   *	    or	al, al
 0B82  75 F6		   *	    jne    @C00C9
			     4				inc di
 0B84  4E		     4			.until (al == 0)
 0B85  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0172 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0172 eq 0
 = 			     6				??0173     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0173 substr regStack, 1, (??0172 - 1)
			     6				regStack substr regStack, (??0172 + 1)
			     6			endif
			     5			exitm ??0173
			     5		%	for ??0171, __popRegs(regStack) 
			     5				pop ??0171
 0B86  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0B87  C3					.while ax != 0
 0B88							mov bl, FileBuffer
				
 0B88							.if bl == LF
								inc FileLine
			     1			strcpy_all NonTerminalErrorBuffer, \
			     2			<@@parametro, !< LINHA_ORG !>, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
 0B88  8D 3E 0211 R	     2			ifdifi <NonTerminalErrorBuffer>, <di>
			     2				lea di, NonTerminalErrorBuffer
			     2			endif
			     2			for string, <@@parametro, < LINHA_ORG >, @deve_estar_entre_1_e_N, ExplanationSeparator, CommandBufferString>
			     2				if DEFINED(string)
			     2					strcpy string, di
			     2				else
			     2					strcpy_c <string>, di
			     2				endif
			     4			endm
			     4			IFDEF @@parametro
			     3				EXITM <-1> 
			     3				if DEFINED(@@parametro)
			     4					strcpy @@parametro, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0175     textequ <>
			     5			??0176 textequ <>
			     5			for       ??0174, <ax>
			     5				push  ??0174
			     5				??0176 catstr <??0174>, ??0175, ??0176
			     5				??0175 catstr <, >
 0B8C  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0176 catstr <ax>, ??0175, ??0176
 = <ax>			     5				??0175 catstr <, >
			     5			??0176 catstr OPEN_DELIMITER, ??0176, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0176
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0176
			     6			else
			     6				regStack catstr ??0176, REG_SET_DELIMITER, regStack
			     4			endif
 0B8D  8D 36 032E R	     4			ifdifi   <@@parametro>, <si>
			     4				lea si, @@parametro
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0B91			   *@C00CB:
			     4			endif
 0B91  8A 04		     4			.repeat
 0B93  88 05		     4				mov al,   [si]
 0B95  46		     4				mov [di], al
 0B96  47		     4				inc si
 0B97  0A C0		   *	    or	al, al
 0B99  75 F6		   *	    jne    @C00CB
			     4				inc di
 0B9B  4E		     4			.until (al == 0)
 0B9C  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0178 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0178 eq 0
 = 			     6				??0179     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0179 substr regStack, 1, (??0178 - 1)
			     6				regStack substr regStack, (??0178 + 1)
			     6			endif
			     5			exitm ??0179
			     5		%	for ??0177, __popRegs(regStack) 
			     5				pop ??0177
 0B9D  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@@parametro>, di
			     4				endif
			     4			IFDEF LINHA_ORG
			     4				EXITM <-1> 
			     4			ELSE
			     3				EXITM <0> 
			     3				if DEFINED( LINHA_ORG )
			     3					strcpy  LINHA_ORG , di
			     3				else
			     4					strcpy_c < LINHA_ORG >, di
			     4			ifdifi <di>, <di>
			     4				lea di, di
			     4			endif
			     4	
			     4			forc char, < LINHA_ORG >
			     4				mov byte ptr [di], '&char'
			     4				inc di
 0B9E  C6 05 20		     5			endm
 0BA1  47		     5				mov byte ptr [di], ' '
 0BA2  C6 05 4C		     5				inc di
 0BA5  47		     5				mov byte ptr [di], 'L'
 0BA6  C6 05 49		     5				inc di
 0BA9  47		     5				mov byte ptr [di], 'I'
 0BAA  C6 05 4E		     5				inc di
 0BAD  47		     5				mov byte ptr [di], 'N'
 0BAE  C6 05 48		     5				inc di
 0BB1  47		     5				mov byte ptr [di], 'H'
 0BB2  C6 05 41		     5				inc di
 0BB5  47		     5				mov byte ptr [di], 'A'
 0BB6  C6 05 5F		     5				inc di
 0BB9  47		     5				mov byte ptr [di], '_'
 0BBA  C6 05 4F		     5				inc di
 0BBD  47		     5				mov byte ptr [di], 'O'
 0BBE  C6 05 52		     5				inc di
 0BC1  47		     5				mov byte ptr [di], 'R'
 0BC2  C6 05 47		     5				inc di
 0BC5  47		     5				mov byte ptr [di], 'G'
 0BC6  C6 05 20		     5				inc di
 0BC9  47		     5				mov byte ptr [di], ' '
 0BCA  C6 05 00		     4				inc di
			     3			mov byte ptr [di], 0
			     4				endif
			     4			IFDEF @deve_estar_entre_1_e_N
			     3				EXITM <-1> 
			     3				if DEFINED(@deve_estar_entre_1_e_N)
			     4					strcpy @deve_estar_entre_1_e_N, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??017B     textequ <>
			     5			??017C textequ <>
			     5			for       ??017A, <ax>
			     5				push  ??017A
			     5				??017C catstr <??017A>, ??017B, ??017C
			     5				??017B catstr <, >
 0BCD  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??017C catstr <ax>, ??017B, ??017C
 = <ax>			     5				??017B catstr <, >
			     5			??017C catstr OPEN_DELIMITER, ??017C, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??017C
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??017C
			     6			else
			     6				regStack catstr ??017C, REG_SET_DELIMITER, regStack
			     4			endif
 0BCE  8D 36 0347 R	     4			ifdifi   <@deve_estar_entre_1_e_N>, <si>
			     4				lea si, @deve_estar_entre_1_e_N
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BD2			   *@C00CD:
			     4			endif
 0BD2  8A 04		     4			.repeat
 0BD4  88 05		     4				mov al,   [si]
 0BD6  46		     4				mov [di], al
 0BD7  47		     4				inc si
 0BD8  0A C0		   *	    or	al, al
 0BDA  75 F6		   *	    jne    @C00CD
			     4				inc di
 0BDC  4E		     4			.until (al == 0)
 0BDD  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??017E instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??017E eq 0
 = 			     6				??017F     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??017F substr regStack, 1, (??017E - 1)
			     6				regStack substr regStack, (??017E + 1)
			     6			endif
			     5			exitm ??017F
			     5		%	for ??017D, __popRegs(regStack) 
			     5				pop ??017D
 0BDE  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <@deve_estar_entre_1_e_N>, di
			     4				endif
			     4			IFDEF ExplanationSeparator
			     3				EXITM <-1> 
			     3				if DEFINED(ExplanationSeparator)
			     4					strcpy ExplanationSeparator, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0181     textequ <>
			     5			??0182 textequ <>
			     5			for       ??0180, <ax>
			     5				push  ??0180
			     5				??0182 catstr <??0180>, ??0181, ??0182
			     5				??0181 catstr <, >
 0BDF  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0182 catstr <ax>, ??0181, ??0182
 = <ax>			     5				??0181 catstr <, >
			     5			??0182 catstr OPEN_DELIMITER, ??0182, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0182
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0182
			     6			else
			     6				regStack catstr ??0182, REG_SET_DELIMITER, regStack
			     4			endif
 0BE0  8D 36 03B8 R	     4			ifdifi   <ExplanationSeparator>, <si>
			     4				lea si, ExplanationSeparator
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BE4			   *@C00CF:
			     4			endif
 0BE4  8A 04		     4			.repeat
 0BE6  88 05		     4				mov al,   [si]
 0BE8  46		     4				mov [di], al
 0BE9  47		     4				inc si
 0BEA  0A C0		   *	    or	al, al
 0BEC  75 F6		   *	    jne    @C00CF
			     4				inc di
 0BEE  4E		     4			.until (al == 0)
 0BEF  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??0184 instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??0184 eq 0
 = 			     6				??0185     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??0185 substr regStack, 1, (??0184 - 1)
			     6				regStack substr regStack, (??0184 + 1)
			     6			endif
			     5			exitm ??0185
			     5		%	for ??0183, __popRegs(regStack) 
			     5				pop ??0183
 0BF0  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <ExplanationSeparator>, di
			     4				endif
			     4			IFDEF CommandBufferString
			     3				EXITM <-1> 
			     3				if DEFINED(CommandBufferString)
			     4					strcpy CommandBufferString, di
			     5			SaveRegs ax
 = 			     5			local reg, comma, regpushed
 = 			     5			??0187     textequ <>
			     5			??0188 textequ <>
			     5			for       ??0186, <ax>
			     5				push  ??0186
			     5				??0188 catstr <??0186>, ??0187, ??0188
			     5				??0187 catstr <, >
 0BF1  50		     6			endm
 = ax			     6				push  ax
 = , 			     6				??0188 catstr <ax>, ??0187, ??0188
 = <ax>			     5				??0187 catstr <, >
			     5			??0188 catstr OPEN_DELIMITER, ??0188, CLOSE_DELIMITER
 = 0000			     6			__pushRegs ??0188
			     6			size_s sizestr regStack
 = <ax>			     6			if     size_s eq 0
			     6				regStack catstr ??0188
			     6			else
			     6				regStack catstr ??0188, REG_SET_DELIMITER, regStack
			     4			endif
 0BF2  8D 36 010D R	     4			ifdifi   <CommandBufferString>, <si>
			     4				lea si, CommandBufferString
			     4			endif
			     4			ifdifi <di>, <di>
			     4				lea di, di
 0BF6			   *@C00D1:
			     4			endif
 0BF6  8A 04		     4			.repeat
 0BF8  88 05		     4				mov al,   [si]
 0BFA  46		     4				mov [di], al
 0BFB  47		     4				inc si
 0BFC  0A C0		   *	    or	al, al
 0BFE  75 F6		   *	    jne    @C00D1
			     4				inc di
 0C00  4E		     4			.until (al == 0)
 0C01  4F		     4			dec    si
			     4			dec    di
			     5			RestoreRegs
			     6			local reg
 = 0000			     6			local regs_end, regs
			     6			??018A instr 1, regStack, REG_SET_DELIMITER
 = <ax>			     6			if    ??018A eq 0
 = 			     6				??018B     substr regStack, 1
			     6				regStack textequ <>
			     6			else
			     6				??018B substr regStack, 1, (??018A - 1)
			     6				regStack substr regStack, (??018A + 1)
			     6			endif
			     5			exitm ??018B
			     5		%	for ??0189, __popRegs(regStack) 
			     5				pop ??0189
 0C02  58		     6			endm
			     3				pop ax
			     3				else
			     3					strcpy_c <CommandBufferString>, di
			     1				endif
 0C03  C3							mov FileCol, 1
 0C04							.elseif bl == CR
								HandleCR
							.else
								jmp ErrorUnexpectedChar
							.endif
				
 0C04							invoke ReadChar
						.endw
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??018D     textequ <>
 = 			     2			??018E textequ <>
			     2			for       ??018C, <ax,dx>
			     2				push  ??018C
			     2				??018E catstr <??018C>, ??018D, ??018E
			     2				??018D catstr <, >
			     2			endm
 0C04  50		     3				push  ax
 = ax			     3				??018E catstr <ax>, ??018D, ??018E
 = , 			     3				??018D catstr <, >
 0C05  52		     3				push  dx
 = dx, ax		     3				??018E catstr <dx>, ??018D, ??018E
 = , 			     3				??018D catstr <, >
 = <dx, ax>		     2			??018E catstr OPEN_DELIMITER, ??018E, CLOSE_DELIMITER
			     2			__pushRegs ??018E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??018E
			     3			else
			     3				regStack catstr ??018E, REG_SET_DELIMITER, regStack
			     3			endif
 0C06  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na abertura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C08  B2 45		     2				mov dl, 'E'
 0C0A  CD 21		     2				int 21h
 0C0C  B2 72		     2				mov dl, 'r'
 0C0E  CD 21		     2				int 21h
 0C10  B2 72		     2				mov dl, 'r'
 0C12  CD 21		     2				int 21h
 0C14  B2 6F		     2				mov dl, 'o'
 0C16  CD 21		     2				int 21h
 0C18  B2 20		     2				mov dl, ' '
 0C1A  CD 21		     2				int 21h
 0C1C  B2 6E		     2				mov dl, 'n'
 0C1E  CD 21		     2				int 21h
 0C20  B2 61		     2				mov dl, 'a'
 0C22  CD 21		     2				int 21h
 0C24  B2 20		     2				mov dl, ' '
 0C26  CD 21		     2				int 21h
 0C28  B2 61		     2				mov dl, 'a'
 0C2A  CD 21		     2				int 21h
 0C2C  B2 62		     2				mov dl, 'b'
 0C2E  CD 21		     2				int 21h
 0C30  B2 65		     2				mov dl, 'e'
 0C32  CD 21		     2				int 21h
 0C34  B2 72		     2				mov dl, 'r'
 0C36  CD 21		     2				int 21h
 0C38  B2 74		     2				mov dl, 't'
 0C3A  CD 21		     2				int 21h
 0C3C  B2 75		     2				mov dl, 'u'
 0C3E  CD 21		     2				int 21h
 0C40  B2 72		     2				mov dl, 'r'
 0C42  CD 21		     2				int 21h
 0C44  B2 61		     2				mov dl, 'a'
 0C46  CD 21		     2				int 21h
 0C48  B2 20		     2				mov dl, ' '
 0C4A  CD 21		     2				int 21h
 0C4C  B2 64		     2				mov dl, 'd'
 0C4E  CD 21		     2				int 21h
 0C50  B2 6F		     2				mov dl, 'o'
 0C52  CD 21		     2				int 21h
 0C54  B2 20		     2				mov dl, ' '
 0C56  CD 21		     2				int 21h
 0C58  B2 61		     2				mov dl, 'a'
 0C5A  CD 21		     2				int 21h
 0C5C  B2 72		     2				mov dl, 'r'
 0C5E  CD 21		     2				int 21h
 0C60  B2 71		     2				mov dl, 'q'
 0C62  CD 21		     2				int 21h
 0C64  B2 75		     2				mov dl, 'u'
 0C66  CD 21		     2				int 21h
 0C68  B2 69		     2				mov dl, 'i'
 0C6A  CD 21		     2				int 21h
 0C6C  B2 76		     2				mov dl, 'v'
 0C6E  CD 21		     2				int 21h
 0C70  B2 6F		     2				mov dl, 'o'
 0C72  CD 21		     2				int 21h
 0C74  B2 2E		     2				mov dl, '.'
 0C76  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0190 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0190 eq 0
 = <dx, ax>		     3				??0191     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0191 substr regStack, 1, (??0190 - 1)
			     3				regStack substr regStack, (??0190 + 1)
			     3			endif
			     3			exitm ??0191
			     2		%	for ??018F, __popRegs(regStack) 
			     2				pop ??018F
			     2			endm
 0C78  5A		     3				pop dx
 0C79  58		     3				pop ax
 0C7A  E9 F6C3					ret
					ReadEmptyLines endp
 0C7D				
					OpenFile proc near
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??0193     textequ <>
 = 			     2			??0194 textequ <>
			     2			for       ??0192, <ax,dx>
			     2				push  ??0192
			     2				??0194 catstr <??0192>, ??0193, ??0194
			     2				??0193 catstr <, >
			     2			endm
 0C7D  50		     3				push  ax
 = ax			     3				??0194 catstr <ax>, ??0193, ??0194
 = , 			     3				??0193 catstr <, >
 0C7E  52		     3				push  dx
 = dx, ax		     3				??0194 catstr <dx>, ??0193, ??0194
 = , 			     3				??0193 catstr <, >
 = <dx, ax>		     2			??0194 catstr OPEN_DELIMITER, ??0194, CLOSE_DELIMITER
			     2			__pushRegs ??0194
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0194
			     3			else
			     3				regStack catstr ??0194, REG_SET_DELIMITER, regStack
			     3			endif
 0C7F  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro na leitura do arquivo.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0C81  B2 45		     2				mov dl, 'E'
 0C83  CD 21		     2				int 21h
 0C85  B2 72		     2				mov dl, 'r'
 0C87  CD 21		     2				int 21h
 0C89  B2 72		     2				mov dl, 'r'
 0C8B  CD 21		     2				int 21h
 0C8D  B2 6F		     2				mov dl, 'o'
 0C8F  CD 21		     2				int 21h
 0C91  B2 20		     2				mov dl, ' '
 0C93  CD 21		     2				int 21h
 0C95  B2 6E		     2				mov dl, 'n'
 0C97  CD 21		     2				int 21h
 0C99  B2 61		     2				mov dl, 'a'
 0C9B  CD 21		     2				int 21h
 0C9D  B2 20		     2				mov dl, ' '
 0C9F  CD 21		     2				int 21h
 0CA1  B2 6C		     2				mov dl, 'l'
 0CA3  CD 21		     2				int 21h
 0CA5  B2 65		     2				mov dl, 'e'
 0CA7  CD 21		     2				int 21h
 0CA9  B2 69		     2				mov dl, 'i'
 0CAB  CD 21		     2				int 21h
 0CAD  B2 74		     2				mov dl, 't'
 0CAF  CD 21		     2				int 21h
 0CB1  B2 75		     2				mov dl, 'u'
 0CB3  CD 21		     2				int 21h
 0CB5  B2 72		     2				mov dl, 'r'
 0CB7  CD 21		     2				int 21h
 0CB9  B2 61		     2				mov dl, 'a'
 0CBB  CD 21		     2				int 21h
 0CBD  B2 20		     2				mov dl, ' '
 0CBF  CD 21		     2				int 21h
 0CC1  B2 64		     2				mov dl, 'd'
 0CC3  CD 21		     2				int 21h
 0CC5  B2 6F		     2				mov dl, 'o'
 0CC7  CD 21		     2				int 21h
 0CC9  B2 20		     2				mov dl, ' '
 0CCB  CD 21		     2				int 21h
 0CCD  B2 61		     2				mov dl, 'a'
 0CCF  CD 21		     2				int 21h
 0CD1  B2 72		     2				mov dl, 'r'
 0CD3  CD 21		     2				int 21h
 0CD5  B2 71		     2				mov dl, 'q'
 0CD7  CD 21		     2				int 21h
 0CD9  B2 75		     2				mov dl, 'u'
 0CDB  CD 21		     2				int 21h
 0CDD  B2 69		     2				mov dl, 'i'
 0CDF  CD 21		     2				int 21h
 0CE1  B2 76		     2				mov dl, 'v'
 0CE3  CD 21		     2				int 21h
 0CE5  B2 6F		     2				mov dl, 'o'
 0CE7  CD 21		     2				int 21h
 0CE9  B2 2E		     2				mov dl, '.'
 0CEB  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0196 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0196 eq 0
 = <dx, ax>		     3				??0197     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0197 substr regStack, 1, (??0196 - 1)
			     3				regStack substr regStack, (??0196 + 1)
			     3			endif
			     3			exitm ??0197
			     2		%	for ??0195, __popRegs(regStack) 
			     2				pop ??0195
			     2			endm
 0CED  5A		     3				pop dx
 0CEE  58		     3				pop ax
 0CEF  E9 F64E					SaveRegs ax,         dx
						mov      al,         0
 0CF2						lea      dx,         FileName
						mov      ah,         3dh
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??0199     textequ <>
 = 			     4			??019A textequ <>
			     4			for       ??0198, <ax,dx>
			     4				push  ??0198
			     4				??019A catstr <??0198>, ??0199, ??019A
			     4				??0199 catstr <, >
			     4			endm
 0CF2  50		     5				push  ax
 = ax			     5				??019A catstr <ax>, ??0199, ??019A
 = , 			     5				??0199 catstr <, >
 0CF3  52		     5				push  dx
 = dx, ax		     5				??019A catstr <dx>, ??0199, ??019A
 = , 			     5				??0199 catstr <, >
 = <dx, ax>		     4			??019A catstr OPEN_DELIMITER, ??019A, CLOSE_DELIMITER
			     4			__pushRegs ??019A
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??019A
			     5			else
			     5				regStack catstr ??019A, REG_SET_DELIMITER, regStack
			     5			endif
 0CF4  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0CF6  B2 28		     4				mov dl, '('
 0CF8  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??019C instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??019C eq 0
 = <dx, ax>		     5				??019D     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??019D substr regStack, 1, (??019C - 1)
			     5				regStack substr regStack, (??019C + 1)
			     5			endif
			     5			exitm ??019D
			     4		%	for ??019B, __popRegs(regStack) 
			     4				pop ??019B
			     4			endm
 0CFA  5A		     5				pop dx
 0CFB  58		     5				pop ax
 0CFC  FF 36 03C1 R	   *	    push   FileLine
 0D00  E8 079F		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??019F     textequ <>
 = 			     4			??01A0 textequ <>
			     4			for       ??019E, <ax,dx>
			     4				push  ??019E
			     4				??01A0 catstr <??019E>, ??019F, ??01A0
			     4				??019F catstr <, >
			     4			endm
 0D03  50		     5				push  ax
 = ax			     5				??01A0 catstr <ax>, ??019F, ??01A0
 = , 			     5				??019F catstr <, >
 0D04  52		     5				push  dx
 = dx, ax		     5				??01A0 catstr <dx>, ??019F, ??01A0
 = , 			     5				??019F catstr <, >
 = <dx, ax>		     4			??01A0 catstr OPEN_DELIMITER, ??01A0, CLOSE_DELIMITER
			     4			__pushRegs ??01A0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01A0
			     5			else
			     5				regStack catstr ??01A0, REG_SET_DELIMITER, regStack
			     5			endif
 0D05  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D07  B2 3A		     4				mov dl, ':'
 0D09  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01A2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A2 eq 0
 = <dx, ax>		     5				??01A3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01A3 substr regStack, 1, (??01A2 - 1)
			     5				regStack substr regStack, (??01A2 + 1)
			     5			endif
			     5			exitm ??01A3
			     4		%	for ??01A1, __popRegs(regStack) 
			     4				pop ??01A1
			     4			endm
 0D0B  5A		     5				pop dx
 0D0C  58		     5				pop ax
 0D0D  FF 36 03BF R	   *	    push   FileCol
 0D11  E8 078E		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01A5     textequ <>
 = 			     4			??01A6 textequ <>
			     4			for       ??01A4, <ax,dx>
			     4				push  ??01A4
			     4				??01A6 catstr <??01A4>, ??01A5, ??01A6
			     4				??01A5 catstr <, >
			     4			endm
 0D14  50		     5				push  ax
 = ax			     5				??01A6 catstr <ax>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 0D15  52		     5				push  dx
 = dx, ax		     5				??01A6 catstr <dx>, ??01A5, ??01A6
 = , 			     5				??01A5 catstr <, >
 = <dx, ax>		     4			??01A6 catstr OPEN_DELIMITER, ??01A6, CLOSE_DELIMITER
			     4			__pushRegs ??01A6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01A6
			     5			else
			     5				regStack catstr ??01A6, REG_SET_DELIMITER, regStack
			     5			endif
 0D16  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0D18  B2 29		     4				mov dl, ')'
 0D1A  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01A8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01A8 eq 0
 = <dx, ax>		     5				??01A9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01A9 substr regStack, 1, (??01A8 - 1)
			     5				regStack substr regStack, (??01A8 + 1)
			     5			endif
			     5			exitm ??01A9
			     4		%	for ??01A7, __popRegs(regStack) 
			     4				pop ??01A7
			     4			endm
 0D1C  5A		     5				pop dx
 0D1D  58		     5				pop ax
						int      21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01AB     textequ <>
 = 			     2			??01AC textequ <>
			     2			for       ??01AA, <ax,dx>
			     2				push  ??01AA
			     2				??01AC catstr <??01AA>, ??01AB, ??01AC
			     2				??01AB catstr <, >
			     2			endm
 0D1E  50		     3				push  ax
 = ax			     3				??01AC catstr <ax>, ??01AB, ??01AC
 = , 			     3				??01AB catstr <, >
 0D1F  52		     3				push  dx
 = dx, ax		     3				??01AC catstr <dx>, ??01AB, ??01AC
 = , 			     3				??01AB catstr <, >
 = <dx, ax>		     2			??01AC catstr OPEN_DELIMITER, ??01AC, CLOSE_DELIMITER
			     2			__pushRegs ??01AC
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01AC
			     3			else
			     3				regStack catstr ??01AC, REG_SET_DELIMITER, regStack
			     3			endif
 0D20  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: a quantidade de colunas deve ser igual em todas as linhas.>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0D22  B2 20		     2				mov dl, ' '
 0D24  CD 21		     2				int 21h
 0D26  B2 45		     2				mov dl, 'E'
 0D28  CD 21		     2				int 21h
 0D2A  B2 72		     2				mov dl, 'r'
 0D2C  CD 21		     2				int 21h
 0D2E  B2 72		     2				mov dl, 'r'
 0D30  CD 21		     2				int 21h
 0D32  B2 6F		     2				mov dl, 'o'
 0D34  CD 21		     2				int 21h
 0D36  B2 3A		     2				mov dl, ':'
 0D38  CD 21		     2				int 21h
 0D3A  B2 20		     2				mov dl, ' '
 0D3C  CD 21		     2				int 21h
 0D3E  B2 61		     2				mov dl, 'a'
 0D40  CD 21		     2				int 21h
 0D42  B2 20		     2				mov dl, ' '
 0D44  CD 21		     2				int 21h
 0D46  B2 71		     2				mov dl, 'q'
 0D48  CD 21		     2				int 21h
 0D4A  B2 75		     2				mov dl, 'u'
 0D4C  CD 21		     2				int 21h
 0D4E  B2 61		     2				mov dl, 'a'
 0D50  CD 21		     2				int 21h
 0D52  B2 6E		     2				mov dl, 'n'
 0D54  CD 21		     2				int 21h
 0D56  B2 74		     2				mov dl, 't'
 0D58  CD 21		     2				int 21h
 0D5A  B2 69		     2				mov dl, 'i'
 0D5C  CD 21		     2				int 21h
 0D5E  B2 64		     2				mov dl, 'd'
 0D60  CD 21		     2				int 21h
 0D62  B2 61		     2				mov dl, 'a'
 0D64  CD 21		     2				int 21h
 0D66  B2 64		     2				mov dl, 'd'
 0D68  CD 21		     2				int 21h
 0D6A  B2 65		     2				mov dl, 'e'
 0D6C  CD 21		     2				int 21h
 0D6E  B2 20		     2				mov dl, ' '
 0D70  CD 21		     2				int 21h
 0D72  B2 64		     2				mov dl, 'd'
 0D74  CD 21		     2				int 21h
 0D76  B2 65		     2				mov dl, 'e'
 0D78  CD 21		     2				int 21h
 0D7A  B2 20		     2				mov dl, ' '
 0D7C  CD 21		     2				int 21h
 0D7E  B2 63		     2				mov dl, 'c'
 0D80  CD 21		     2				int 21h
 0D82  B2 6F		     2				mov dl, 'o'
 0D84  CD 21		     2				int 21h
 0D86  B2 6C		     2				mov dl, 'l'
 0D88  CD 21		     2				int 21h
 0D8A  B2 75		     2				mov dl, 'u'
 0D8C  CD 21		     2				int 21h
 0D8E  B2 6E		     2				mov dl, 'n'
 0D90  CD 21		     2				int 21h
 0D92  B2 61		     2				mov dl, 'a'
 0D94  CD 21		     2				int 21h
 0D96  B2 73		     2				mov dl, 's'
 0D98  CD 21		     2				int 21h
 0D9A  B2 20		     2				mov dl, ' '
 0D9C  CD 21		     2				int 21h
 0D9E  B2 64		     2				mov dl, 'd'
 0DA0  CD 21		     2				int 21h
 0DA2  B2 65		     2				mov dl, 'e'
 0DA4  CD 21		     2				int 21h
 0DA6  B2 76		     2				mov dl, 'v'
 0DA8  CD 21		     2				int 21h
 0DAA  B2 65		     2				mov dl, 'e'
 0DAC  CD 21		     2				int 21h
 0DAE  B2 20		     2				mov dl, ' '
 0DB0  CD 21		     2				int 21h
 0DB2  B2 73		     2				mov dl, 's'
 0DB4  CD 21		     2				int 21h
 0DB6  B2 65		     2				mov dl, 'e'
 0DB8  CD 21		     2				int 21h
 0DBA  B2 72		     2				mov dl, 'r'
 0DBC  CD 21		     2				int 21h
 0DBE  B2 20		     2				mov dl, ' '
 0DC0  CD 21		     2				int 21h
 0DC2  B2 69		     2				mov dl, 'i'
 0DC4  CD 21		     2				int 21h
 0DC6  B2 67		     2				mov dl, 'g'
 0DC8  CD 21		     2				int 21h
 0DCA  B2 75		     2				mov dl, 'u'
 0DCC  CD 21		     2				int 21h
 0DCE  B2 61		     2				mov dl, 'a'
 0DD0  CD 21		     2				int 21h
 0DD2  B2 6C		     2				mov dl, 'l'
 0DD4  CD 21		     2				int 21h
 0DD6  B2 20		     2				mov dl, ' '
 0DD8  CD 21		     2				int 21h
 0DDA  B2 65		     2				mov dl, 'e'
 0DDC  CD 21		     2				int 21h
 0DDE  B2 6D		     2				mov dl, 'm'
 0DE0  CD 21		     2				int 21h
 0DE2  B2 20		     2				mov dl, ' '
 0DE4  CD 21		     2				int 21h
 0DE6  B2 74		     2				mov dl, 't'
 0DE8  CD 21		     2				int 21h
 0DEA  B2 6F		     2				mov dl, 'o'
 0DEC  CD 21		     2				int 21h
 0DEE  B2 64		     2				mov dl, 'd'
 0DF0  CD 21		     2				int 21h
 0DF2  B2 61		     2				mov dl, 'a'
 0DF4  CD 21		     2				int 21h
 0DF6  B2 73		     2				mov dl, 's'
 0DF8  CD 21		     2				int 21h
 0DFA  B2 20		     2				mov dl, ' '
 0DFC  CD 21		     2				int 21h
 0DFE  B2 61		     2				mov dl, 'a'
 0E00  CD 21		     2				int 21h
 0E02  B2 73		     2				mov dl, 's'
 0E04  CD 21		     2				int 21h
 0E06  B2 20		     2				mov dl, ' '
 0E08  CD 21		     2				int 21h
 0E0A  B2 6C		     2				mov dl, 'l'
 0E0C  CD 21		     2				int 21h
 0E0E  B2 69		     2				mov dl, 'i'
 0E10  CD 21		     2				int 21h
 0E12  B2 6E		     2				mov dl, 'n'
 0E14  CD 21		     2				int 21h
 0E16  B2 68		     2				mov dl, 'h'
 0E18  CD 21		     2				int 21h
 0E1A  B2 61		     2				mov dl, 'a'
 0E1C  CD 21		     2				int 21h
 0E1E  B2 73		     2				mov dl, 's'
 0E20  CD 21		     2				int 21h
 0E22  B2 2E		     2				mov dl, '.'
 0E24  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01AE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01AE eq 0
 = <dx, ax>		     3				??01AF     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01AF substr regStack, 1, (??01AE - 1)
			     3				regStack substr regStack, (??01AE + 1)
			     3			endif
			     3			exitm ??01AF
			     2		%	for ??01AD, __popRegs(regStack) 
			     2				pop ??01AD
			     2			endm
 0E26  5A		     3				pop dx
 0E27  58		     3				pop ax
 0E28  E9 F515					.if (carry?)
							call ErrorOpen
 0E2B						.endif
						mov      FileHandle, ax
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01B1     textequ <>
 = 			     2			??01B2 textequ <>
			     2			for       ??01B0, <ax,dx>
			     2				push  ??01B0
			     2				??01B2 catstr <??01B0>, ??01B1, ??01B2
			     2				??01B1 catstr <, >
			     2			endm
 0E2B  50		     3				push  ax
 = ax			     3				??01B2 catstr <ax>, ??01B1, ??01B2
 = , 			     3				??01B1 catstr <, >
 0E2C  52		     3				push  dx
 = dx, ax		     3				??01B2 catstr <dx>, ??01B1, ??01B2
 = , 			     3				??01B1 catstr <, >
 = <dx, ax>		     2			??01B2 catstr OPEN_DELIMITER, ??01B2, CLOSE_DELIMITER
			     2			__pushRegs ??01B2
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01B2
			     3			else
			     3				regStack catstr ??01B2, REG_SET_DELIMITER, regStack
			     3			endif
 0E2D  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Erro: a quantidade de linhas deve ser 1 a menos que a quantidade de colunas. O encontrado foi: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 0E2F  B2 45		     2				mov dl, 'E'
 0E31  CD 21		     2				int 21h
 0E33  B2 72		     2				mov dl, 'r'
 0E35  CD 21		     2				int 21h
 0E37  B2 72		     2				mov dl, 'r'
 0E39  CD 21		     2				int 21h
 0E3B  B2 6F		     2				mov dl, 'o'
 0E3D  CD 21		     2				int 21h
 0E3F  B2 3A		     2				mov dl, ':'
 0E41  CD 21		     2				int 21h
 0E43  B2 20		     2				mov dl, ' '
 0E45  CD 21		     2				int 21h
 0E47  B2 61		     2				mov dl, 'a'
 0E49  CD 21		     2				int 21h
 0E4B  B2 20		     2				mov dl, ' '
 0E4D  CD 21		     2				int 21h
 0E4F  B2 71		     2				mov dl, 'q'
 0E51  CD 21		     2				int 21h
 0E53  B2 75		     2				mov dl, 'u'
 0E55  CD 21		     2				int 21h
 0E57  B2 61		     2				mov dl, 'a'
 0E59  CD 21		     2				int 21h
 0E5B  B2 6E		     2				mov dl, 'n'
 0E5D  CD 21		     2				int 21h
 0E5F  B2 74		     2				mov dl, 't'
 0E61  CD 21		     2				int 21h
 0E63  B2 69		     2				mov dl, 'i'
 0E65  CD 21		     2				int 21h
 0E67  B2 64		     2				mov dl, 'd'
 0E69  CD 21		     2				int 21h
 0E6B  B2 61		     2				mov dl, 'a'
 0E6D  CD 21		     2				int 21h
 0E6F  B2 64		     2				mov dl, 'd'
 0E71  CD 21		     2				int 21h
 0E73  B2 65		     2				mov dl, 'e'
 0E75  CD 21		     2				int 21h
 0E77  B2 20		     2				mov dl, ' '
 0E79  CD 21		     2				int 21h
 0E7B  B2 64		     2				mov dl, 'd'
 0E7D  CD 21		     2				int 21h
 0E7F  B2 65		     2				mov dl, 'e'
 0E81  CD 21		     2				int 21h
 0E83  B2 20		     2				mov dl, ' '
 0E85  CD 21		     2				int 21h
 0E87  B2 6C		     2				mov dl, 'l'
 0E89  CD 21		     2				int 21h
 0E8B  B2 69		     2				mov dl, 'i'
 0E8D  CD 21		     2				int 21h
 0E8F  B2 6E		     2				mov dl, 'n'
 0E91  CD 21		     2				int 21h
 0E93  B2 68		     2				mov dl, 'h'
 0E95  CD 21		     2				int 21h
 0E97  B2 61		     2				mov dl, 'a'
 0E99  CD 21		     2				int 21h
 0E9B  B2 73		     2				mov dl, 's'
 0E9D  CD 21		     2				int 21h
 0E9F  B2 20		     2				mov dl, ' '
 0EA1  CD 21		     2				int 21h
 0EA3  B2 64		     2				mov dl, 'd'
 0EA5  CD 21		     2				int 21h
 0EA7  B2 65		     2				mov dl, 'e'
 0EA9  CD 21		     2				int 21h
 0EAB  B2 76		     2				mov dl, 'v'
 0EAD  CD 21		     2				int 21h
 0EAF  B2 65		     2				mov dl, 'e'
 0EB1  CD 21		     2				int 21h
 0EB3  B2 20		     2				mov dl, ' '
 0EB5  CD 21		     2				int 21h
 0EB7  B2 73		     2				mov dl, 's'
 0EB9  CD 21		     2				int 21h
 0EBB  B2 65		     2				mov dl, 'e'
 0EBD  CD 21		     2				int 21h
 0EBF  B2 72		     2				mov dl, 'r'
 0EC1  CD 21		     2				int 21h
 0EC3  B2 20		     2				mov dl, ' '
 0EC5  CD 21		     2				int 21h
 0EC7  B2 31		     2				mov dl, '1'
 0EC9  CD 21		     2				int 21h
 0ECB  B2 20		     2				mov dl, ' '
 0ECD  CD 21		     2				int 21h
 0ECF  B2 61		     2				mov dl, 'a'
 0ED1  CD 21		     2				int 21h
 0ED3  B2 20		     2				mov dl, ' '
 0ED5  CD 21		     2				int 21h
 0ED7  B2 6D		     2				mov dl, 'm'
 0ED9  CD 21		     2				int 21h
 0EDB  B2 65		     2				mov dl, 'e'
 0EDD  CD 21		     2				int 21h
 0EDF  B2 6E		     2				mov dl, 'n'
 0EE1  CD 21		     2				int 21h
 0EE3  B2 6F		     2				mov dl, 'o'
 0EE5  CD 21		     2				int 21h
 0EE7  B2 73		     2				mov dl, 's'
 0EE9  CD 21		     2				int 21h
 0EEB  B2 20		     2				mov dl, ' '
 0EED  CD 21		     2				int 21h
 0EEF  B2 71		     2				mov dl, 'q'
 0EF1  CD 21		     2				int 21h
 0EF3  B2 75		     2				mov dl, 'u'
 0EF5  CD 21		     2				int 21h
 0EF7  B2 65		     2				mov dl, 'e'
 0EF9  CD 21		     2				int 21h
 0EFB  B2 20		     2				mov dl, ' '
 0EFD  CD 21		     2				int 21h
 0EFF  B2 61		     2				mov dl, 'a'
 0F01  CD 21		     2				int 21h
 0F03  B2 20		     2				mov dl, ' '
 0F05  CD 21		     2				int 21h
 0F07  B2 71		     2				mov dl, 'q'
 0F09  CD 21		     2				int 21h
 0F0B  B2 75		     2				mov dl, 'u'
 0F0D  CD 21		     2				int 21h
 0F0F  B2 61		     2				mov dl, 'a'
 0F11  CD 21		     2				int 21h
 0F13  B2 6E		     2				mov dl, 'n'
 0F15  CD 21		     2				int 21h
 0F17  B2 74		     2				mov dl, 't'
 0F19  CD 21		     2				int 21h
 0F1B  B2 69		     2				mov dl, 'i'
 0F1D  CD 21		     2				int 21h
 0F1F  B2 64		     2				mov dl, 'd'
 0F21  CD 21		     2				int 21h
 0F23  B2 61		     2				mov dl, 'a'
 0F25  CD 21		     2				int 21h
 0F27  B2 64		     2				mov dl, 'd'
 0F29  CD 21		     2				int 21h
 0F2B  B2 65		     2				mov dl, 'e'
 0F2D  CD 21		     2				int 21h
 0F2F  B2 20		     2				mov dl, ' '
 0F31  CD 21		     2				int 21h
 0F33  B2 64		     2				mov dl, 'd'
 0F35  CD 21		     2				int 21h
 0F37  B2 65		     2				mov dl, 'e'
 0F39  CD 21		     2				int 21h
 0F3B  B2 20		     2				mov dl, ' '
 0F3D  CD 21		     2				int 21h
 0F3F  B2 63		     2				mov dl, 'c'
 0F41  CD 21		     2				int 21h
 0F43  B2 6F		     2				mov dl, 'o'
 0F45  CD 21		     2				int 21h
 0F47  B2 6C		     2				mov dl, 'l'
 0F49  CD 21		     2				int 21h
 0F4B  B2 75		     2				mov dl, 'u'
 0F4D  CD 21		     2				int 21h
 0F4F  B2 6E		     2				mov dl, 'n'
 0F51  CD 21		     2				int 21h
 0F53  B2 61		     2				mov dl, 'a'
 0F55  CD 21		     2				int 21h
 0F57  B2 73		     2				mov dl, 's'
 0F59  CD 21		     2				int 21h
 0F5B  B2 2E		     2				mov dl, '.'
 0F5D  CD 21		     2				int 21h
 0F5F  B2 20		     2				mov dl, ' '
 0F61  CD 21		     2				int 21h
 0F63  B2 4F		     2				mov dl, 'O'
 0F65  CD 21		     2				int 21h
 0F67  B2 20		     2				mov dl, ' '
 0F69  CD 21		     2				int 21h
 0F6B  B2 65		     2				mov dl, 'e'
 0F6D  CD 21		     2				int 21h
 0F6F  B2 6E		     2				mov dl, 'n'
 0F71  CD 21		     2				int 21h
 0F73  B2 63		     2				mov dl, 'c'
 0F75  CD 21		     2				int 21h
 0F77  B2 6F		     2				mov dl, 'o'
 0F79  CD 21		     2				int 21h
 0F7B  B2 6E		     2				mov dl, 'n'
 0F7D  CD 21		     2				int 21h
 0F7F  B2 74		     2				mov dl, 't'
 0F81  CD 21		     2				int 21h
 0F83  B2 72		     2				mov dl, 'r'
 0F85  CD 21		     2				int 21h
 0F87  B2 61		     2				mov dl, 'a'
 0F89  CD 21		     2				int 21h
 0F8B  B2 64		     2				mov dl, 'd'
 0F8D  CD 21		     2				int 21h
 0F8F  B2 6F		     2				mov dl, 'o'
 0F91  CD 21		     2				int 21h
 0F93  B2 20		     2				mov dl, ' '
 0F95  CD 21		     2				int 21h
 0F97  B2 66		     2				mov dl, 'f'
 0F99  CD 21		     2				int 21h
 0F9B  B2 6F		     2				mov dl, 'o'
 0F9D  CD 21		     2				int 21h
 0F9F  B2 69		     2				mov dl, 'i'
 0FA1  CD 21		     2				int 21h
 0FA3  B2 3A		     2				mov dl, ':'
 0FA5  CD 21		     2				int 21h
 0FA7  B2 20		     2				mov dl, ' '
 0FA9  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01B4 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01B4 eq 0
 = <dx, ax>		     3				??01B5     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01B5 substr regStack, 1, (??01B4 - 1)
			     3				regStack substr regStack, (??01B4 + 1)
			     3			endif
			     3			exitm ??01B5
			     2		%	for ??01B3, __popRegs(regStack) 
			     2				pop ??01B3
			     2			endm
 0FAB  5A		     3				pop dx
 0FAC  58		     3				pop ax
						mov      FileIsOpen, 1
			     1			print_Pair TotalRow, TotalCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01B7     textequ <>
 = 			     4			??01B8 textequ <>
			     4			for       ??01B6, <ax,dx>
			     4				push  ??01B6
			     4				??01B8 catstr <??01B6>, ??01B7, ??01B8
			     4				??01B7 catstr <, >
			     4			endm
 0FAD  50		     5				push  ax
 = ax			     5				??01B8 catstr <ax>, ??01B7, ??01B8
 = , 			     5				??01B7 catstr <, >
 0FAE  52		     5				push  dx
 = dx, ax		     5				??01B8 catstr <dx>, ??01B7, ??01B8
 = , 			     5				??01B7 catstr <, >
 = <dx, ax>		     4			??01B8 catstr OPEN_DELIMITER, ??01B8, CLOSE_DELIMITER
			     4			__pushRegs ??01B8
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01B8
			     5			else
			     5				regStack catstr ??01B8, REG_SET_DELIMITER, regStack
			     5			endif
 0FAF  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FB1  B2 28		     4				mov dl, '('
 0FB3  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01BA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01BA eq 0
 = <dx, ax>		     5				??01BB     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01BB substr regStack, 1, (??01BA - 1)
			     5				regStack substr regStack, (??01BA + 1)
			     5			endif
			     5			exitm ??01BB
			     4		%	for ??01B9, __popRegs(regStack) 
			     4				pop ??01B9
			     4			endm
 0FB5  5A		     5				pop dx
 0FB6  58		     5				pop ax
 0FB7  A0 03C5 R	   *	    mov    al, TotalRow
 0FBA  32 E4		   *	    xor    ah, ah
 0FBC  50		   *	    push   ax
 0FBD  E8 04E2		   *	    call   printf_u
			     2			invoke   printf_u, TotalRow
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01BD     textequ <>
 = 			     4			??01BE textequ <>
			     4			for       ??01BC, <ax,dx>
			     4				push  ??01BC
			     4				??01BE catstr <??01BC>, ??01BD, ??01BE
			     4				??01BD catstr <, >
			     4			endm
 0FC0  50		     5				push  ax
 = ax			     5				??01BE catstr <ax>, ??01BD, ??01BE
 = , 			     5				??01BD catstr <, >
 0FC1  52		     5				push  dx
 = dx, ax		     5				??01BE catstr <dx>, ??01BD, ??01BE
 = , 			     5				??01BD catstr <, >
 = <dx, ax>		     4			??01BE catstr OPEN_DELIMITER, ??01BE, CLOSE_DELIMITER
			     4			__pushRegs ??01BE
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01BE
			     5			else
			     5				regStack catstr ??01BE, REG_SET_DELIMITER, regStack
			     5			endif
 0FC2  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FC4  B2 3A		     4				mov dl, ':'
 0FC6  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01C0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C0 eq 0
 = <dx, ax>		     5				??01C1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01C1 substr regStack, 1, (??01C0 - 1)
			     5				regStack substr regStack, (??01C0 + 1)
			     5			endif
			     5			exitm ??01C1
			     4		%	for ??01BF, __popRegs(regStack) 
			     4				pop ??01BF
			     4			endm
 0FC8  5A		     5				pop dx
 0FC9  58		     5				pop ax
 0FCA  A0 03C6 R	   *	    mov    al, TotalCol
 0FCD  32 E4		   *	    xor    ah, ah
 0FCF  50		   *	    push   ax
 0FD0  E8 04CF		   *	    call   printf_u
			     2			invoke   printf_u, TotalCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C3     textequ <>
 = 			     4			??01C4 textequ <>
			     4			for       ??01C2, <ax,dx>
			     4				push  ??01C2
			     4				??01C4 catstr <??01C2>, ??01C3, ??01C4
			     4				??01C3 catstr <, >
			     4			endm
 0FD3  50		     5				push  ax
 = ax			     5				??01C4 catstr <ax>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 0FD4  52		     5				push  dx
 = dx, ax		     5				??01C4 catstr <dx>, ??01C3, ??01C4
 = , 			     5				??01C3 catstr <, >
 = <dx, ax>		     4			??01C4 catstr OPEN_DELIMITER, ??01C4, CLOSE_DELIMITER
			     4			__pushRegs ??01C4
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01C4
			     5			else
			     5				regStack catstr ??01C4, REG_SET_DELIMITER, regStack
			     5			endif
 0FD5  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FD7  B2 29		     4				mov dl, ')'
 0FD9  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01C6 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01C6 eq 0
 = <dx, ax>		     5				??01C7     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01C7 substr regStack, 1, (??01C6 - 1)
			     5				regStack substr regStack, (??01C6 + 1)
			     5			endif
			     5			exitm ??01C7
			     4		%	for ??01C5, __popRegs(regStack) 
			     4				pop ??01C5
			     4			endm
 0FDB  5A		     5				pop dx
 0FDC  58		     5				pop ax
 0FDD  E9 F360					RestoreRegs
						ret
 0FE0					OpenFile endp
 0FE0  8A 1E 000D R		
 0FE4  88 1E 03BC R			ReadChar proc near uses RegsReturningOnAX
						invoke ReadCharTo, addr FileBuffer
						inc    FileCol
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01C9     textequ <>
 = 			     4			??01CA textequ <>
			     4			for       ??01C8, <ax,dx>
			     4				push  ??01C8
			     4				??01CA catstr <??01C8>, ??01C9, ??01CA
			     4				??01C9 catstr <, >
			     4			endm
 0FE8  50		     5				push  ax
 = ax			     5				??01CA catstr <ax>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 0FE9  52		     5				push  dx
 = dx, ax		     5				??01CA catstr <dx>, ??01C9, ??01CA
 = , 			     5				??01C9 catstr <, >
 = <dx, ax>		     4			??01CA catstr OPEN_DELIMITER, ??01CA, CLOSE_DELIMITER
			     4			__pushRegs ??01CA
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01CA
			     5			else
			     5				regStack catstr ??01CA, REG_SET_DELIMITER, regStack
			     5			endif
 0FEA  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FEC  B2 28		     4				mov dl, '('
 0FEE  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01CC instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01CC eq 0
 = <dx, ax>		     5				??01CD     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01CD substr regStack, 1, (??01CC - 1)
			     5				regStack substr regStack, (??01CC + 1)
			     5			endif
			     5			exitm ??01CD
			     4		%	for ??01CB, __popRegs(regStack) 
			     4				pop ??01CB
			     4			endm
 0FF0  5A		     5				pop dx
 0FF1  58		     5				pop ax
 0FF2  FF 36 03C1 R	   *	    push   FileLine
 0FF6  E8 04A9		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01CF     textequ <>
 = 			     4			??01D0 textequ <>
			     4			for       ??01CE, <ax,dx>
			     4				push  ??01CE
			     4				??01D0 catstr <??01CE>, ??01CF, ??01D0
			     4				??01CF catstr <, >
			     4			endm
 0FF9  50		     5				push  ax
 = ax			     5				??01D0 catstr <ax>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 0FFA  52		     5				push  dx
 = dx, ax		     5				??01D0 catstr <dx>, ??01CF, ??01D0
 = , 			     5				??01CF catstr <, >
 = <dx, ax>		     4			??01D0 catstr OPEN_DELIMITER, ??01D0, CLOSE_DELIMITER
			     4			__pushRegs ??01D0
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D0
			     5			else
			     5				regStack catstr ??01D0, REG_SET_DELIMITER, regStack
			     5			endif
 0FFB  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 0FFD  B2 3A		     4				mov dl, ':'
 0FFF  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D2 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D2 eq 0
 = <dx, ax>		     5				??01D3     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D3 substr regStack, 1, (??01D2 - 1)
			     5				regStack substr regStack, (??01D2 + 1)
			     5			endif
			     5			exitm ??01D3
			     4		%	for ??01D1, __popRegs(regStack) 
			     4				pop ??01D1
			     4			endm
 1001  5A		     5				pop dx
 1002  58		     5				pop ax
 1003  FF 36 03BF R	   *	    push   FileCol
 1007  E8 0498		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01D5     textequ <>
 = 			     4			??01D6 textequ <>
			     4			for       ??01D4, <ax,dx>
			     4				push  ??01D4
			     4				??01D6 catstr <??01D4>, ??01D5, ??01D6
			     4				??01D5 catstr <, >
			     4			endm
 100A  50		     5				push  ax
 = ax			     5				??01D6 catstr <ax>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 100B  52		     5				push  dx
 = dx, ax		     5				??01D6 catstr <dx>, ??01D5, ??01D6
 = , 			     5				??01D5 catstr <, >
 = <dx, ax>		     4			??01D6 catstr OPEN_DELIMITER, ??01D6, CLOSE_DELIMITER
			     4			__pushRegs ??01D6
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01D6
			     5			else
			     5				regStack catstr ??01D6, REG_SET_DELIMITER, regStack
			     5			endif
 100C  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 100E  B2 29		     4				mov dl, ')'
 1010  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01D8 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01D8 eq 0
 = <dx, ax>		     5				??01D9     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01D9 substr regStack, 1, (??01D8 - 1)
			     5				regStack substr regStack, (??01D8 + 1)
			     5			endif
			     5			exitm ??01D9
			     4		%	for ??01D7, __popRegs(regStack) 
			     4				pop ??01D7
			     4			endm
 1012  5A		     5				pop dx
 1013  58		     5				pop ax
						ret
					ReadChar endp
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01DB     textequ <>
 = 			     2			??01DC textequ <>
			     2			for       ??01DA, <ax,dx>
			     2				push  ??01DA
			     2				??01DC catstr <??01DA>, ??01DB, ??01DC
			     2				??01DB catstr <, >
			     2			endm
 1014  50		     3				push  ax
 = ax			     3				??01DC catstr <ax>, ??01DB, ??01DC
 = , 			     3				??01DB catstr <, >
 1015  52		     3				push  dx
 = dx, ax		     3				??01DC catstr <dx>, ??01DB, ??01DC
 = , 			     3				??01DB catstr <, >
 = <dx, ax>		     2			??01DC catstr OPEN_DELIMITER, ??01DC, CLOSE_DELIMITER
			     2			__pushRegs ??01DC
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01DC
			     3			else
			     3				regStack catstr ??01DC, REG_SET_DELIMITER, regStack
			     3			endif
 1016  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: caracter inexperado: ">>
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 1018  B2 20		     2				mov dl, ' '
 101A  CD 21		     2				int 21h
 101C  B2 45		     2				mov dl, 'E'
 101E  CD 21		     2				int 21h
 1020  B2 72		     2				mov dl, 'r'
 1022  CD 21		     2				int 21h
 1024  B2 72		     2				mov dl, 'r'
 1026  CD 21		     2				int 21h
 1028  B2 6F		     2				mov dl, 'o'
 102A  CD 21		     2				int 21h
 102C  B2 3A		     2				mov dl, ':'
 102E  CD 21		     2				int 21h
 1030  B2 20		     2				mov dl, ' '
 1032  CD 21		     2				int 21h
 1034  B2 63		     2				mov dl, 'c'
 1036  CD 21		     2				int 21h
 1038  B2 61		     2				mov dl, 'a'
 103A  CD 21		     2				int 21h
 103C  B2 72		     2				mov dl, 'r'
 103E  CD 21		     2				int 21h
 1040  B2 61		     2				mov dl, 'a'
 1042  CD 21		     2				int 21h
 1044  B2 63		     2				mov dl, 'c'
 1046  CD 21		     2				int 21h
 1048  B2 74		     2				mov dl, 't'
 104A  CD 21		     2				int 21h
 104C  B2 65		     2				mov dl, 'e'
 104E  CD 21		     2				int 21h
 1050  B2 72		     2				mov dl, 'r'
 1052  CD 21		     2				int 21h
 1054  B2 20		     2				mov dl, ' '
 1056  CD 21		     2				int 21h
 1058  B2 69		     2				mov dl, 'i'
 105A  CD 21		     2				int 21h
 105C  B2 6E		     2				mov dl, 'n'
 105E  CD 21		     2				int 21h
 1060  B2 65		     2				mov dl, 'e'
 1062  CD 21		     2				int 21h
 1064  B2 78		     2				mov dl, 'x'
 1066  CD 21		     2				int 21h
 1068  B2 70		     2				mov dl, 'p'
 106A  CD 21		     2				int 21h
 106C  B2 65		     2				mov dl, 'e'
 106E  CD 21		     2				int 21h
 1070  B2 72		     2				mov dl, 'r'
 1072  CD 21		     2				int 21h
 1074  B2 61		     2				mov dl, 'a'
 1076  CD 21		     2				int 21h
 1078  B2 64		     2				mov dl, 'd'
 107A  CD 21		     2				int 21h
 107C  B2 6F		     2				mov dl, 'o'
 107E  CD 21		     2				int 21h
 1080  B2 3A		     2				mov dl, ':'
 1082  CD 21		     2				int 21h
 1084  B2 20		     2				mov dl, ' '
 1086  CD 21		     2				int 21h
 1088  B2 22		     2				mov dl, '"'
 108A  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01DE instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01DE eq 0
 = <dx, ax>		     3				??01DF     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01DF substr regStack, 1, (??01DE - 1)
			     3				regStack substr regStack, (??01DE + 1)
			     3			endif
			     3			exitm ??01DF
			     2		%	for ??01DD, __popRegs(regStack) 
			     2				pop ??01DD
			     2			endm
 108C  5A		     3				pop dx
 108D  58		     3				pop ax
				
 108E  8D 06 03BC R	   *	    lea    ax, TheUnexpectedChar
 1092  50		   *	    push   ax
 1093  E8 03EA		   *	    call   printf_s
					ReadCharTo proc near uses RegsReturningOnAX, Buffer:ptr byte
 1096  E9 F2A7					mov dx, Buffer
						mov bx, FileHandle
 1099						mov ah, 3Fh
						mov cx, 1
			     1			print_Pair FileLine, FileCol
			     2			printf_c <(>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01E1     textequ <>
 = 			     4			??01E2 textequ <>
			     4			for       ??01E0, <ax,dx>
			     4				push  ??01E0
			     4				??01E2 catstr <??01E0>, ??01E1, ??01E2
			     4				??01E1 catstr <, >
			     4			endm
 1099  50		     5				push  ax
 = ax			     5				??01E2 catstr <ax>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 109A  52		     5				push  dx
 = dx, ax		     5				??01E2 catstr <dx>, ??01E1, ??01E2
 = , 			     5				??01E1 catstr <, >
 = <dx, ax>		     4			??01E2 catstr OPEN_DELIMITER, ??01E2, CLOSE_DELIMITER
			     4			__pushRegs ??01E2
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01E2
			     5			else
			     5				regStack catstr ??01E2, REG_SET_DELIMITER, regStack
			     5			endif
 109B  B4 02		     3			mov      ah,   02h
			     3			forc     char, <(>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 109D  B2 28		     4				mov dl, '('
 109F  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01E4 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01E4 eq 0
 = <dx, ax>		     5				??01E5     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01E5 substr regStack, 1, (??01E4 - 1)
			     5				regStack substr regStack, (??01E4 + 1)
			     5			endif
			     5			exitm ??01E5
			     4		%	for ??01E3, __popRegs(regStack) 
			     4				pop ??01E3
			     4			endm
 10A1  5A		     5				pop dx
 10A2  58		     5				pop ax
 10A3  FF 36 03C1 R	   *	    push   FileLine
 10A7  E8 03F8		   *	    call   printf_u
			     2			invoke   printf_u, FileLine
			     2			printf_c <:>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01E7     textequ <>
 = 			     4			??01E8 textequ <>
			     4			for       ??01E6, <ax,dx>
			     4				push  ??01E6
			     4				??01E8 catstr <??01E6>, ??01E7, ??01E8
			     4				??01E7 catstr <, >
			     4			endm
 10AA  50		     5				push  ax
 = ax			     5				??01E8 catstr <ax>, ??01E7, ??01E8
 = , 			     5				??01E7 catstr <, >
 10AB  52		     5				push  dx
 = dx, ax		     5				??01E8 catstr <dx>, ??01E7, ??01E8
 = , 			     5				??01E7 catstr <, >
 = <dx, ax>		     4			??01E8 catstr OPEN_DELIMITER, ??01E8, CLOSE_DELIMITER
			     4			__pushRegs ??01E8
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01E8
			     5			else
			     5				regStack catstr ??01E8, REG_SET_DELIMITER, regStack
			     5			endif
 10AC  B4 02		     3			mov      ah,   02h
			     3			forc     char, <:>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10AE  B2 3A		     4				mov dl, ':'
 10B0  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01EA instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01EA eq 0
 = <dx, ax>		     5				??01EB     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01EB substr regStack, 1, (??01EA - 1)
			     5				regStack substr regStack, (??01EA + 1)
			     5			endif
			     5			exitm ??01EB
			     4		%	for ??01E9, __popRegs(regStack) 
			     4				pop ??01E9
			     4			endm
 10B2  5A		     5				pop dx
 10B3  58		     5				pop ax
 10B4  FF 36 03BF R	   *	    push   FileCol
 10B8  E8 03E7		   *	    call   printf_u
			     2			invoke   printf_u, FileCol
			     2			printf_c <)>
			     3			SaveRegs ax,   dx
			     4			local reg, comma, regpushed
 = 			     4			??01ED     textequ <>
 = 			     4			??01EE textequ <>
			     4			for       ??01EC, <ax,dx>
			     4				push  ??01EC
			     4				??01EE catstr <??01EC>, ??01ED, ??01EE
			     4				??01ED catstr <, >
			     4			endm
 10BB  50		     5				push  ax
 = ax			     5				??01EE catstr <ax>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 10BC  52		     5				push  dx
 = dx, ax		     5				??01EE catstr <dx>, ??01ED, ??01EE
 = , 			     5				??01ED catstr <, >
 = <dx, ax>		     4			??01EE catstr OPEN_DELIMITER, ??01EE, CLOSE_DELIMITER
			     4			__pushRegs ??01EE
 = 0000			     5			size_s sizestr regStack
			     5			if     size_s eq 0
 = <dx, ax>		     5				regStack catstr ??01EE
			     5			else
			     5				regStack catstr ??01EE, REG_SET_DELIMITER, regStack
			     5			endif
 10BD  B4 02		     3			mov      ah,   02h
			     3			forc     char, <)>
			     3				mov dl, '&char'
			     3				int 21h
			     3			endm
 10BF  B2 29		     4				mov dl, ')'
 10C1  CD 21		     4				int 21h
			     3			RestoreRegs
			     4			local reg
			     5			local regs_end, regs
 = 0000			     5			??01F0 instr 1, regStack, REG_SET_DELIMITER
			     5			if    ??01F0 eq 0
 = <dx, ax>		     5				??01F1     substr regStack, 1
 = 			     5				regStack textequ <>
			     5			else
			     5				??01F1 substr regStack, 1, (??01F0 - 1)
			     5				regStack substr regStack, (??01F0 + 1)
			     5			endif
			     5			exitm ??01F1
			     4		%	for ??01EF, __popRegs(regStack) 
			     4				pop ??01EF
			     4			endm
 10C3  5A		     5				pop dx
 10C4  58		     5				pop ax
						int 21h
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01F3     textequ <>
 = 			     2			??01F4 textequ <>
			     2			for       ??01F2, <ax,dx>
			     2				push  ??01F2
			     2				??01F4 catstr <??01F2>, ??01F3, ??01F4
			     2				??01F3 catstr <, >
			     2			endm
 10C5  50		     3				push  ax
 = ax			     3				??01F4 catstr <ax>, ??01F3, ??01F4
 = , 			     3				??01F3 catstr <, >
 10C6  52		     3				push  dx
 = dx, ax		     3				??01F4 catstr <dx>, ??01F3, ??01F4
 = , 			     3				??01F3 catstr <, >
 = <dx, ax>		     2			??01F4 catstr OPEN_DELIMITER, ??01F4, CLOSE_DELIMITER
			     2			__pushRegs ??01F4
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01F4
			     3			else
			     3				regStack catstr ??01F4, REG_SET_DELIMITER, regStack
			     3			endif
 10C7  B4 02		     1			mov      ah,   02h
			     1			forc     char, < Erro: N deve estar entre 2 e 7. N encontrado: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 10C9  B2 20		     2				mov dl, ' '
 10CB  CD 21		     2				int 21h
 10CD  B2 45		     2				mov dl, 'E'
 10CF  CD 21		     2				int 21h
 10D1  B2 72		     2				mov dl, 'r'
 10D3  CD 21		     2				int 21h
 10D5  B2 72		     2				mov dl, 'r'
 10D7  CD 21		     2				int 21h
 10D9  B2 6F		     2				mov dl, 'o'
 10DB  CD 21		     2				int 21h
 10DD  B2 3A		     2				mov dl, ':'
 10DF  CD 21		     2				int 21h
 10E1  B2 20		     2				mov dl, ' '
 10E3  CD 21		     2				int 21h
 10E5  B2 4E		     2				mov dl, 'N'
 10E7  CD 21		     2				int 21h
 10E9  B2 20		     2				mov dl, ' '
 10EB  CD 21		     2				int 21h
 10ED  B2 64		     2				mov dl, 'd'
 10EF  CD 21		     2				int 21h
 10F1  B2 65		     2				mov dl, 'e'
 10F3  CD 21		     2				int 21h
 10F5  B2 76		     2				mov dl, 'v'
 10F7  CD 21		     2				int 21h
 10F9  B2 65		     2				mov dl, 'e'
 10FB  CD 21		     2				int 21h
 10FD  B2 20		     2				mov dl, ' '
 10FF  CD 21		     2				int 21h
 1101  B2 65		     2				mov dl, 'e'
 1103  CD 21		     2				int 21h
 1105  B2 73		     2				mov dl, 's'
 1107  CD 21		     2				int 21h
 1109  B2 74		     2				mov dl, 't'
 110B  CD 21		     2				int 21h
 110D  B2 61		     2				mov dl, 'a'
 110F  CD 21		     2				int 21h
 1111  B2 72		     2				mov dl, 'r'
 1113  CD 21		     2				int 21h
 1115  B2 20		     2				mov dl, ' '
 1117  CD 21		     2				int 21h
 1119  B2 65		     2				mov dl, 'e'
 111B  CD 21		     2				int 21h
 111D  B2 6E		     2				mov dl, 'n'
 111F  CD 21		     2				int 21h
 1121  B2 74		     2				mov dl, 't'
 1123  CD 21		     2				int 21h
 1125  B2 72		     2				mov dl, 'r'
 1127  CD 21		     2				int 21h
 1129  B2 65		     2				mov dl, 'e'
 112B  CD 21		     2				int 21h
 112D  B2 20		     2				mov dl, ' '
 112F  CD 21		     2				int 21h
 1131  B2 32		     2				mov dl, '2'
 1133  CD 21		     2				int 21h
 1135  B2 20		     2				mov dl, ' '
 1137  CD 21		     2				int 21h
 1139  B2 65		     2				mov dl, 'e'
 113B  CD 21		     2				int 21h
 113D  B2 20		     2				mov dl, ' '
 113F  CD 21		     2				int 21h
 1141  B2 37		     2				mov dl, '7'
 1143  CD 21		     2				int 21h
 1145  B2 2E		     2				mov dl, '.'
 1147  CD 21		     2				int 21h
 1149  B2 20		     2				mov dl, ' '
 114B  CD 21		     2				int 21h
 114D  B2 4E		     2				mov dl, 'N'
 114F  CD 21		     2				int 21h
 1151  B2 20		     2				mov dl, ' '
 1153  CD 21		     2				int 21h
 1155  B2 65		     2				mov dl, 'e'
 1157  CD 21		     2				int 21h
 1159  B2 6E		     2				mov dl, 'n'
 115B  CD 21		     2				int 21h
 115D  B2 63		     2				mov dl, 'c'
 115F  CD 21		     2				int 21h
 1161  B2 6F		     2				mov dl, 'o'
 1163  CD 21		     2				int 21h
 1165  B2 6E		     2				mov dl, 'n'
 1167  CD 21		     2				int 21h
 1169  B2 74		     2				mov dl, 't'
 116B  CD 21		     2				int 21h
 116D  B2 72		     2				mov dl, 'r'
 116F  CD 21		     2				int 21h
 1171  B2 61		     2				mov dl, 'a'
 1173  CD 21		     2				int 21h
 1175  B2 64		     2				mov dl, 'd'
 1177  CD 21		     2				int 21h
 1179  B2 6F		     2				mov dl, 'o'
 117B  CD 21		     2				int 21h
 117D  B2 3A		     2				mov dl, ':'
 117F  CD 21		     2				int 21h
 1181  B2 20		     2				mov dl, ' '
 1183  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01F6 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01F6 eq 0
 = <dx, ax>		     3				??01F7     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01F7 substr regStack, 1, (??01F6 - 1)
			     3				regStack substr regStack, (??01F6 + 1)
			     3			endif
			     3			exitm ??01F7
			     2		%	for ??01F5, __popRegs(regStack) 
			     2				pop ??01F5
			     2			endm
 1185  5A		     3				pop dx
 1186  58		     3				pop ax
						.if (carry?)
 1187  A0 03C7 R	   *	    mov    al, N
 118A  32 E4		   *	    xor    ah, ah
 118C  50		   *	    push   ax
 118D  E8 0312		   *	    call   printf_u
 1190  E9 F1AD						call ErrorRead
						.endif
 1193				
						; EOF
			     1			SaveRegs ax,   dx
			     2			local reg, comma, regpushed
 = 			     2			??01F9     textequ <>
 = 			     2			??01FA textequ <>
			     2			for       ??01F8, <ax,dx>
			     2				push  ??01F8
			     2				??01FA catstr <??01F8>, ??01F9, ??01FA
			     2				??01F9 catstr <, >
			     2			endm
 1193  50		     3				push  ax
 = ax			     3				??01FA catstr <ax>, ??01F9, ??01FA
 = , 			     3				??01F9 catstr <, >
 1194  52		     3				push  dx
 = dx, ax		     3				??01FA catstr <dx>, ??01F9, ??01FA
 = , 			     3				??01F9 catstr <, >
 = <dx, ax>		     2			??01FA catstr OPEN_DELIMITER, ??01FA, CLOSE_DELIMITER
			     2			__pushRegs ??01FA
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??01FA
			     3			else
			     3				regStack catstr ??01FA, REG_SET_DELIMITER, regStack
			     3			endif
 1195  B4 02		     1			mov      ah,   02h
			     1			forc     char, <Unable to parse command: >
			     1				mov dl, '&char'
			     1				int 21h
			     1			endm
 1197  B2 55		     2				mov dl, 'U'
 1199  CD 21		     2				int 21h
 119B  B2 6E		     2				mov dl, 'n'
 119D  CD 21		     2				int 21h
 119F  B2 61		     2				mov dl, 'a'
 11A1  CD 21		     2				int 21h
 11A3  B2 62		     2				mov dl, 'b'
 11A5  CD 21		     2				int 21h
 11A7  B2 6C		     2				mov dl, 'l'
 11A9  CD 21		     2				int 21h
 11AB  B2 65		     2				mov dl, 'e'
 11AD  CD 21		     2				int 21h
 11AF  B2 20		     2				mov dl, ' '
 11B1  CD 21		     2				int 21h
 11B3  B2 74		     2				mov dl, 't'
 11B5  CD 21		     2				int 21h
 11B7  B2 6F		     2				mov dl, 'o'
 11B9  CD 21		     2				int 21h
 11BB  B2 20		     2				mov dl, ' '
 11BD  CD 21		     2				int 21h
 11BF  B2 70		     2				mov dl, 'p'
 11C1  CD 21		     2				int 21h
 11C3  B2 61		     2				mov dl, 'a'
 11C5  CD 21		     2				int 21h
 11C7  B2 72		     2				mov dl, 'r'
 11C9  CD 21		     2				int 21h
 11CB  B2 73		     2				mov dl, 's'
 11CD  CD 21		     2				int 21h
 11CF  B2 65		     2				mov dl, 'e'
 11D1  CD 21		     2				int 21h
 11D3  B2 20		     2				mov dl, ' '
 11D5  CD 21		     2				int 21h
 11D7  B2 63		     2				mov dl, 'c'
 11D9  CD 21		     2				int 21h
 11DB  B2 6F		     2				mov dl, 'o'
 11DD  CD 21		     2				int 21h
 11DF  B2 6D		     2				mov dl, 'm'
 11E1  CD 21		     2				int 21h
 11E3  B2 6D		     2				mov dl, 'm'
 11E5  CD 21		     2				int 21h
 11E7  B2 61		     2				mov dl, 'a'
 11E9  CD 21		     2				int 21h
 11EB  B2 6E		     2				mov dl, 'n'
 11ED  CD 21		     2				int 21h
 11EF  B2 64		     2				mov dl, 'd'
 11F1  CD 21		     2				int 21h
 11F3  B2 3A		     2				mov dl, ':'
 11F5  CD 21		     2				int 21h
 11F7  B2 20		     2				mov dl, ' '
 11F9  CD 21		     2				int 21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??01FC instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??01FC eq 0
 = <dx, ax>		     3				??01FD     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??01FD substr regStack, 1, (??01FC - 1)
			     3				regStack substr regStack, (??01FC + 1)
			     3			endif
			     3			exitm ??01FD
			     2		%	for ??01FB, __popRegs(regStack) 
			     2				pop ??01FB
			     2			endm
 11FB  5A		     3				pop dx
 11FC  58		     3				pop ax
						.if ax == 0
 11FD  8D 06 010D R	   *	    lea    ax, CommandBufferString
 1201  50		   *	    push   ax
 1202  E8 027B		   *	    call   printf_s
 1205  E9 F138						mov bx,           dx
							mov byte ptr[bx], 0
						.endif
				
						ret
					ReadCharTo endp
				
					MoveBack proc near uses RegsInvokeUses
						; Move back by one byte
						mov bx, FileHandle
				
						mov ah, 42h
						mov cx, 0FFFFh ; Means dx is negative
						mov dx, -1
 1208						mov al, 1
 1208  50		   *	    push   ax
 1209  53		   *	    push   bx
 120A  51		   *	    push   cx
 120B  52		   *	    push   dx
 120C  55		   *	    push   bp
						int 21h
 120D  E8 0059		   *	    call   ReadChar
						.if (carry?)
 1210  EB 31		   *	    jmp    @C00D3
 1212			   *@C00D4:
 1212  8A 1E 000D R					call ErrorRead
						.endif
						ret
 1216  80 FB 0A		   *	    cmp    bl, LF
 1219  75 0C		   *	    jne    @C00D5
 121B  FF 06 03C1 R			MoveBack endp
 121F  C7 06 03BF R 0001	
					PeekChar proc near uses RegsReturningOnAX
 1225  EB 19		   *	    jmp    @C00D7
 1227			   *@C00D5:
 1227  80 FB 0D		   *	    cmp    bl, CR
 122A  75 11		   *	    jne    @C00D8
						invoke ReadCharTo, addr PeekBuffer
			     1			invoke PeekChar
 122C  E8 009A		   *	    call   PeekChar
 122F  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 1233  80 FF 0A		   *	    cmp    bh, LF
 1236  74 08		   *	    je     @C00DA
 1238  E9 FDA5		     1				jmp ErrorUnexpectedChar
			     1			.endif
						invoke MoveBack
 123B  EB 03		   *	    jmp    @C00DC
 123D			   *@C00D8:
 123D  E9 FDA0					ret
					PeekChar endp
				
					ReadNum proc near uses RegsInvokeUses, result:ptr word
 1240			   *@C00DC:
 1240			   *@C00D7:
 1240			   *@C00DA:
 1240  E8 0026		   *	    call   ReadChar
						invoke ReadChar
 1243			   *@C00D3:
 1243  0B C0		   *	    or	ax, ax
 1245  75 CB		   *	    jne    @C00D4
						mov    ax, 0
 1247  5D		   *	    pop    bp
 1248  5A		   *	    pop    dx
 1249  59		   *	    pop    cx
 124A  5B		   *	    pop    bx
 124B  58		   *	    pop    ax
 124C  C3		   *	    ret    00000h
 124D						mov    bx, 0
						mov    cx, 10
 124D						mov    bl, FileBuffer
						.while ((bl <= '9') && (bl >= '0'))
			     1			local reg, comma, regpushed
 = 			     1			??01FF     textequ <>
 = 			     1			??0200 textequ <>
			     1			for       ??01FE, <ax,dx>
			     1				push  ??01FE
			     1				??0200 catstr <??01FE>, ??01FF, ??0200
			     1				??01FF catstr <, >
			     1			endm
 124D  50		     2				push  ax
 = ax			     2				??0200 catstr <ax>, ??01FF, ??0200
 = , 			     2				??01FF catstr <, >
 124E  52		     2				push  dx
 = dx, ax		     2				??0200 catstr <dx>, ??01FF, ??0200
 = , 			     2				??01FF catstr <, >
 = <dx, ax>		     1			??0200 catstr OPEN_DELIMITER, ??0200, CLOSE_DELIMITER
			     1			__pushRegs ??0200
 = 0000			     2			size_s sizestr regStack
			     2			if     size_s eq 0
 = <dx, ax>		     2				regStack catstr ??0200
			     2			else
			     2				regStack catstr ??0200, REG_SET_DELIMITER, regStack
			     2			endif
 124F  B0 00						mul cx
 1251  8D 16 0005 R		
 1255  B4 3D						sub bl, '0'
 1257  CD 21						add ax, bx
				
 1259  73 03		   *	    jae    @C00DE
 125B  E8 F9A6						push   ax
							invoke ReadChar
 125E			   *@C00DE:
 125E  A3 0071 R					pop    ax
 1261  C6 06 0073 R 01					mov    bl, FileBuffer
						.endw
			     1			local reg
			     2			local regs_end, regs
 = 0000			     2			??0202 instr 1, regStack, REG_SET_DELIMITER
			     2			if    ??0202 eq 0
 = <dx, ax>		     2				??0203     substr regStack, 1
 = 			     2				regStack textequ <>
			     2			else
			     2				??0203 substr regStack, 1, (??0202 - 1)
			     2				regStack substr regStack, (??0202 + 1)
			     2			endif
			     2			exitm ??0203
			     1		%	for ??0201, __popRegs(regStack) 
			     1				pop ??0201
			     1			endm
 1266  5A		     2				pop dx
 1267  58		     2				pop ax
 1268  C3					invoke MoveBack
 1269				
						mov bx,           result
 1269						mov word ptr[bx], ax
 1269  53		   *	    push   bx
 126A  51		   *	    push   cx
 126B  52		   *	    push   dx
 126C  55		   *	    push   bp
						ret
 126D  8D 06 000D R	   *	    lea    ax, FileBuffer
 1271  50		   *	    push   ax
 1272  E8 0009		   *	    call   ReadCharTo
 1275  FF 06 03BF R			ReadNum endp
				
 1279  5D		   *	    pop    bp
 127A  5A		   *	    pop    dx
 127B  59		   *	    pop    cx
 127C  5B		   *	    pop    bx
 127D  C3		   *	    ret    00000h
 127E					ReadMatrix proc near uses ax bx cx dx bp
						invoke OpenFile
 127E						ReadMatrixLoop:
 127E  55		   *	    push   bp
 127F  8B EC		   *	    mov    bp, sp
 1281  53		   *	    push   bx
 1282  51		   *	    push   cx
 1283  52		   *	    push   dx
 1284  55		   *	    push   bp
 1285  8B 56 04						invoke ReadChar
 1288  8B 1E 0071 R					.if    ax == 0  ; EOF
 128C  B4 3F							mov al,       TotalCol
 128E  B9 0001							inc al                 ; TotalCol starts at 0
 1291  CD 21							mov NPlusOne, al
								dec al                 ; ax = N
 1293  73 03		   *	    jae    @C00E0
 1295  E8 F9E5							mov N,        al       ; TotalCol starts at 0
								dec al
 1298			   *@C00E0:
								.if (TotalRow != al)
									jmp ErrorRowCount
								.elseif (al < 2 ) || (al > 7)
 1298  0B C0		   *	    or	ax, ax
 129A  75 05		   *	    jne    @C00E2
 129C  8B DA								jmp ErrorInvalidN
 129E  C6 07 00							.endif
								jmp EndReading
 12A1			   *@C00E2:
							.endif
				
 12A1  5D		   *	    pop    bp
 12A2  5A		   *	    pop    dx
 12A3  59		   *	    pop    cx
 12A4  5B		   *	    pop    bx
 12A5  5D		   *	    pop    bp
 12A6  C2 0002		   *	    ret    00002h
 12A9							mov bl, FileBuffer
				
 12A9							.if bl == 3Bh
								inc Col
 12A9  50		   *	    push   ax
 12AA  53		   *	    push   bx
 12AB  51		   *	    push   cx
 12AC  52		   *	    push   dx
 12AD  55		   *	    push   bp
 12AE  8B 1E 0071 R					.elseif bl == LF
								inc FileLine
 12B2  B4 42							mov FileCol, 1
 12B4  B9 FFFF							;====================================================================
 12B7  BA FFFF							; On a new line, the number of columns should always be the same
 12BA  B0 01							mov al,      Col
 12BC  CD 21							.if Row == 0
									mov TotalCol, al
 12BE  73 03		   *	    jae    @C00E4
 12C0  E8 F9BA							.elseif TotalCol != al
									jmp ErrorColumnCount
 12C3			   *@C00E4:
								.endif
 12C3  5D		   *	    pop    bp
 12C4  5A		   *	    pop    dx
 12C5  59		   *	    pop    cx
 12C6  5B		   *	    pop    bx
 12C7  58		   *	    pop    ax
 12C8  C3		   *	    ret    00000h
 12C9								;====================================================================
								; If next line is empty, all next lines should be empty
 12C9								invoke PeekChar
 12C9  53		   *	    push   bx
 12CA  51		   *	    push   cx
 12CB  52		   *	    push   dx
 12CC  55		   *	    push   bp
								mov    bh, PeekBuffer
 12CD  8D 06 03BB R	   *	    lea    ax, PeekBuffer
 12D1  50		   *	    push   ax
 12D2  E8 FFA9		   *	    call   ReadCharTo
								.if    bh == LF || bh == CR
 12D5  E8 FFD1		   *	    call   MoveBack
									invoke ReadEmptyLines
 12D8  5D		   *	    pop    bp
 12D9  5A		   *	    pop    dx
 12DA  59		   *	    pop    cx
 12DB  5B		   *	    pop    bx
 12DC  C3		   *	    ret    00000h
 12DD								;====================================================================
								; Otherwise, next line must have data
 12DD								.else
 12DD  55		   *	    push   bp
 12DE  8B EC		   *	    mov    bp, sp
 12E0  50		   *	    push   ax
 12E1  53		   *	    push   bx
 12E2  51		   *	    push   cx
 12E3  52		   *	    push   dx
 12E4  55		   *	    push   bp
									inc Row
 12E5  E8 FF81		   *	    call   ReadChar
 12E8  B8 0000								inc TotalRow
 12EB  BB 0000								mov Col, 0
 12EE  B9 000A							.endif
 12F1  8A 1E 000D R					.elseif bl == CR
							; accept CR only before LF
 12F5  EB 10		   *	    jmp    @C00E6
 12F7			   *@C00E7:
 12F7  F7 E1							HandleCR
							.elseif (bl == '-')
 12F9  80 EB 30							CurrentIndexToBx
 12FC  03 C3							invoke ReadNum, bx
								neg    sword ptr [bx]
 12FE  50						.elseif (bl <= '9') && (bl >= '0')
								invoke MoveBack
 12FF  E8 FF67		   *	    call   ReadChar
 1302  58							CurrentIndexToBx
 1303  8A 1E 000D R						invoke ReadNum, bx
							.else
 1307			   *@C00E6:
 1307  80 FB 39		   *	    cmp    bl, '9'
 130A  77 05		   *	    ja     @C00E8
 130C  80 FB 30		   *	    cmp    bl, '0'
 130F  73 E6		   *	    jae    @C00E7
 1311			   *@C00E8:
								jmp ErrorUnexpectedChar
 1311  E8 FF95		   *	    call   MoveBack
							.endif
 1314  8B 5E 04						jmp ReadMatrixLoop
 1317  89 07					EndReading:
							CloseFileHandle
 1319  5D		   *	    pop    bp
 131A  5A		   *	    pop    dx
 131B  59		   *	    pop    cx
 131C  5B		   *	    pop    bx
 131D  58		   *	    pop    ax
 131E  5D		   *	    pop    bp
 131F  C2 0002		   *	    ret    00002h
 1322						ret
					ReadMatrix endp
 1322				
 1322  50		   *	    push   ax
 1323  53		   *	    push   bx
 1324  51		   *	    push   cx
 1325  52		   *	    push   dx
 1326  55		   *	    push   bp
				;====================================================================
 1327  E8 FF23		   *	    call   OpenFile
 132A				; Printf
				
 132A  E8 FF3C		   *	    call   ReadChar
					PrintMatrix proc near uses RegsInvokeUses
 132D  0B C0		   *	    or	ax, ax
 132F  75 28		   *	    jne    @C00EA
 1331  A0 03C6 R				mov      bx, offset Matrix
 1334  FE C0					mov      dx, 8
 1336  A2 03C8 R				mov      cx, 0             ; High has row, Low has column
 1339  FE C8					.ForRow:                   ; for (row = 0; row < N; row++)
 133B  A2 03C7 R					cmp ch, N      ; row < N
 133E  FE C8						jge .EndForRow
				
 1340  38 06 03C5 R	   *	    cmp    TotalRow, al
 1344  74 05		   *	    je     @C00EC
 1346  E9 FAE2						mov      cl, 0 ; col = 0
							.ForCol:       ; for (col = 0; col < NPlusOne; col++)
 1349  EB 0B		   *	    jmp    @C00EE
 134B			   *@C00EC:
 134B  3C 02		   *	    cmp    al, 002h
 134D  72 04		   *	    jb     @C00F0
 134F  3C 07		   *	    cmp    al, 007h
 1351  76 03		   *	    jbe    @C00EF
 1353			   *@C00F0:
 1353  E9 FD43							cmp cl, NPlusOne ; col < NPlusOne
								jge .EndForCol
 1356			   *@C00EF:
 1356			   *@C00EE:
 1356  E9 00CC			
								mov ax, sword ptr [bx]
 1359			   *@C00EA:
								invoke printf_d_padded, ax, dx
 1359  8A 1E 000D R		
								add bx, 2 ; size in bytes of a sword
				
 135D  80 FB 3B		   *	    cmp    bl, 03Bh
 1360  75 07		   *	    jne    @C00F2
 1362  FE 06 03C4 R						inc cl      ; col ++
								jmp .ForCol
 1366  E9 00B9		   *	    jmp    @C00F4
 1369			   *@C00F2:
 1369  80 FB 0A		   *	    cmp    bl, LF
 136C  75 47		   *	    jne    @C00F5
 136E  FF 06 03C1 R					.EndForCol:
 1372  C7 06 03BF R 0001				putc CR
							putc LF
				
 1378  A0 03C4 R					inc ch      ; row++
							jmp .ForRow
 137B  80 3E 03C3 R 00	   *	    cmp    Row, 000h
 1380  75 05		   *	    jne    @C00F7
 1382  A2 03C6 R				.EndForRow:
						ret
 1385  EB 09		   *	    jmp    @C00F9
 1387			   *@C00F7:
 1387  38 06 03C6 R	   *	    cmp    TotalCol, al
 138B  74 03		   *	    je     @C00FA
 138D  E9 F962				PrintMatrix endp
				
					printf_s proc near uses RegsInvokeUses, string:ptr byte
						mov    bx, string
						.while byte ptr [bx] != 0
 1390			   *@C00FA:
 1390			   *@C00F9:
 1390  E8 FF36		   *	    call   PeekChar
 1393  8A 3E 03BB R					mov ah, 2
							mov dl, [bx]
 1397  80 FF 0A		   *	    cmp    bh, LF
 139A  74 05		   *	    je     @C00FD
 139C  80 FF 0D		   *	    cmp    bh, CR
 139F  75 05		   *	    jne    @C00FC
 13A1			   *@C00FD:
							int 21H
 13A1  E8 FE64		   *	    call   ReadEmptyLines
							inc bx
						.endw
						ret
 13A4  EB 7C		   *	    jmp    @C00FF
 13A6			   *@C00FC:
 13A6  FE 06 03C3 R			printf_s endp
 13AA  FE 06 03C5 R		
 13AE  C6 06 03C4 R 00			printf_u proc near uses RegsInvokeUses, number:word
						local  buf[6]:byte
						invoke string_from_word, addr buf, number
 13B3  EB 6D		   *	    jmp    @C0100
 13B5			   *@C00F5:
 13B5  80 FB 0D		   *	    cmp    bl, CR
 13B8  75 11		   *	    jne    @C0101
						invoke printf_s, addr buf
						ret
			     1			invoke PeekChar
 13BA  E8 FF0C		   *	    call   PeekChar
 13BD  8A 3E 03BB R	     1			mov    bh, PeekBuffer
			     1			.if    bh != LF
 13C1  80 FF 0A		   *	    cmp    bh, LF
 13C4  74 5C		   *	    je     @C0103
 13C6  E9 FC17		     1				jmp ErrorUnexpectedChar
			     1			.endif
					printf_u endp
 13C9  EB 57		   *	    jmp    @C0105
 13CB			   *@C0101:
 13CB  80 FB 2D		   *	    cmp    bl, '-'
 13CE  75 22		   *	    jne    @C0106
				
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??0205     textequ <>
 = 			     2			??0206 textequ <>
			     2			for       ??0204, <ax>
			     2				push  ??0204
			     2				??0206 catstr <??0204>, ??0205, ??0206
			     2				??0205 catstr <, >
			     2			endm
 13D0  50		     3				push  ax
 = ax			     3				??0206 catstr <ax>, ??0205, ??0206
 = , 			     3				??0205 catstr <, >
 = <ax>			     2			??0206 catstr OPEN_DELIMITER, ??0206, CLOSE_DELIMITER
			     2			__pushRegs ??0206
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??0206
			     3			else
			     3				regStack catstr ??0206, REG_SET_DELIMITER, regStack
			     3			endif
 13D1  A0 03C6 R	     1			mov      al, TotalCol
 13D4  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 13D6  8A 1E 03C3 R	     1			mov bl, Row
 13DA  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 13DE  F6 E3		     1			mul bl
 13E0  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 13E2  D1 E0		     1			shl ax, 1
 13E4  05 03C9 R	     1			add ax, offset Matrix
			     1	
 13E7  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0208 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0208 eq 0
 = <ax>			     3				??0209     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0209 substr regStack, 1, (??0208 - 1)
			     3				regStack substr regStack, (??0208 + 1)
			     3			endif
			     3			exitm ??0209
			     2		%	for ??0207, __popRegs(regStack) 
			     2				pop ??0207
			     2			endm
 13E9  58		     3				pop ax
					printf_d proc near uses RegsInvokeUses, number:sword
 13EA  53		   *	    push   bx
 13EB  E8 FEEF		   *	    call   ReadNum
 13EE  F7 1F					local  buf[7]:byte
						invoke string_from_sword, addr buf, number
 13F0  EB 30		   *	    jmp    @C0108
 13F2			   *@C0106:
 13F2  80 FB 39		   *	    cmp    bl, '9'
 13F5  77 28		   *	    ja     @C0109
 13F7  80 FB 30		   *	    cmp    bl, '0'
 13FA  72 23		   *	    jb     @C0109
						invoke printf_s, addr buf
 13FC  E8 FEAA		   *	    call   MoveBack
						ret
			     1			; returns in bx
			     1			SaveRegs ax
			     2			local reg, comma, regpushed
 = 			     2			??020B     textequ <>
 = 			     2			??020C textequ <>
			     2			for       ??020A, <ax>
			     2				push  ??020A
			     2				??020C catstr <??020A>, ??020B, ??020C
			     2				??020B catstr <, >
			     2			endm
 13FF  50		     3				push  ax
 = ax			     3				??020C catstr <ax>, ??020B, ??020C
 = , 			     3				??020B catstr <, >
 = <ax>			     2			??020C catstr OPEN_DELIMITER, ??020C, CLOSE_DELIMITER
			     2			__pushRegs ??020C
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <ax>			     3				regStack catstr ??020C
			     3			else
			     3				regStack catstr ??020C, REG_SET_DELIMITER, regStack
			     3			endif
 1400  A0 03C6 R	     1			mov      al, TotalCol
 1403  FE C0		     1			inc      al           ; TotalCol starts at 0
			     1	
 1405  8A 1E 03C3 R	     1			mov bl, Row
 1409  8A 3E 03C4 R	     1			mov bh, Col
			     1	
 140D  F6 E3		     1			mul bl
 140F  02 C7		     1			add al, bh
			     1	
			     1			; got index, find position in array
			     1	
 1411  D1 E0		     1			shl ax, 1
 1413  05 03C9 R	     1			add ax, offset Matrix
			     1	
 1416  8B D8		     1			mov bx, ax
			     1	
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??020E instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??020E eq 0
 = <ax>			     3				??020F     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??020F substr regStack, 1, (??020E - 1)
			     3				regStack substr regStack, (??020E + 1)
			     3			endif
			     3			exitm ??020F
			     2		%	for ??020D, __popRegs(regStack) 
			     2				pop ??020D
			     2			endm
 1418  58		     3				pop ax
					printf_d endp
 1419  53		   *	    push   bx
 141A  E8 FEC0		   *	    call   ReadNum
					
 141D  EB 03		   *	    jmp    @C010C
 141F			   *@C0109:
 141F  E9 FBBE				printf_d_padded proc near uses RegsInvokeUses, number:sword, padTo:sword
						local  buf[7]:byte
 1422			   *@C010C:
 1422			   *@C0108:
 1422			   *@C0105:
 1422			   *@C0100:
 1422			   *@C00F4:
 1422			   *@C00FF:
 1422			   *@C0103:
 1422  E9 FF05					invoke string_from_sword, addr buf, number
 1425						; string_from_sword gives length on AX
						mov    cx, padTo
 1425  B4 3E		     1			mov ah, 3eh
 1427  8B 1E 0071 R	     1			mov bx, FileHandle
 142B  CD 21		     1			int 21h
			     1			
 142D  C6 06 0073 R 00	     1			mov FileIsOpen, 0 ; 0 means it is now closed
						sub    cx, ax
 1432  5D		   *	    pop    bp
 1433  5A		   *	    pop    dx
 1434  59		   *	    pop    cx
 1435  5B		   *	    pop    bx
 1436  58		   *	    pop    ax
 1437  C3		   *	    ret    00000h
 1438						.WHILE (sword ptr cx > 0)
							putc SPACE
							dec  cx
						.ENDW
						invoke printf_s, addr buf
 1438						ret
 1438  50		   *	    push   ax
 1439  53		   *	    push   bx
 143A  51		   *	    push   cx
 143B  52		   *	    push   dx
 143C  55		   *	    push   bp
 143D  BB 03C9 R			printf_d_padded endp
 1440  BA 0008			
 1443  B9 0000				; length of string goes to ax (including sign)
 1446					string_from_sword proc near uses RegsReturningOnAX, string:ptr byte, number:sword
 1446  3A 2E 03C7 R				mov dx, number
 144A  7D 2E					mov bx, string
						mov cx, 0
 144C  B1 00					.if (sword ptr dx < 0)
 144E							mov byte ptr[bx], '-'
 144E  3A 0E 03C8 R					inc bx
 1452  7D 0E						inc cx
							neg dx
 1454  8B 07					.endif
						invoke string_from_word, bx, dx
 1456  52		   *	    push   dx
 1457  50		   *	    push   ax
 1458  E8 0095		   *	    call   printf_d_padded
						add ax, cx
 145B  83 C3 02					ret
					string_from_sword endp
 145E  FE C1			
 1460  EB EC				; length of string goes to ax
 1462					string_from_word proc near uses RegsReturningOnAX si, string:ptr byte, number:word
						local value:word, divisor:word, first:byte
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0211     textequ <>
 = 			     2			??0212 textequ <>
			     2			for       ??0210, <ax,dx>
			     2				push  ??0210
			     2				??0212 catstr <??0210>, ??0211, ??0212
			     2				??0211 catstr <, >
			     2			endm
 1462  50		     3				push  ax
 = ax			     3				??0212 catstr <ax>, ??0211, ??0212
 = , 			     3				??0211 catstr <, >
 1463  52		     3				push  dx
 = dx, ax		     3				??0212 catstr <dx>, ??0211, ??0212
 = , 			     3				??0211 catstr <, >
 = <dx, ax>		     2			??0212 catstr OPEN_DELIMITER, ??0212, CLOSE_DELIMITER
			     2			__pushRegs ??0212
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0212
			     3			else
			     3				regStack catstr ??0212, REG_SET_DELIMITER, regStack
			     3			endif
 1464  B4 02		     1			mov      ah, 02h
 1466  B2 0D		     1			mov      dl, CR
 1468  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0214 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0214 eq 0
 = <dx, ax>		     3				??0215     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0215 substr regStack, 1, (??0214 - 1)
			     3				regStack substr regStack, (??0214 + 1)
			     3			endif
			     3			exitm ??0215
			     2		%	for ??0213, __popRegs(regStack) 
			     2				pop ??0213
			     2			endm
 146A  5A		     3				pop dx
 146B  58		     3				pop ax
				
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??0217     textequ <>
 = 			     2			??0218 textequ <>
			     2			for       ??0216, <ax,dx>
			     2				push  ??0216
			     2				??0218 catstr <??0216>, ??0217, ??0218
			     2				??0217 catstr <, >
			     2			endm
 146C  50		     3				push  ax
 = ax			     3				??0218 catstr <ax>, ??0217, ??0218
 = , 			     3				??0217 catstr <, >
 146D  52		     3				push  dx
 = dx, ax		     3				??0218 catstr <dx>, ??0217, ??0218
 = , 			     3				??0217 catstr <, >
 = <dx, ax>		     2			??0218 catstr OPEN_DELIMITER, ??0218, CLOSE_DELIMITER
			     2			__pushRegs ??0218
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??0218
			     3			else
			     3				regStack catstr ??0218, REG_SET_DELIMITER, regStack
			     3			endif
 146E  B4 02		     1			mov      ah, 02h
 1470  B2 0A		     1			mov      dl, LF
 1472  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??021A instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??021A eq 0
 = <dx, ax>		     3				??021B     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??021B substr regStack, 1, (??021A - 1)
			     3				regStack substr regStack, (??021A + 1)
			     3			endif
			     3			exitm ??021B
			     2		%	for ??0219, __popRegs(regStack) 
			     2				pop ??0219
			     2			endm
 1474  5A		     3				pop dx
 1475  58		     3				pop ax
						mov divisor, 10000
 1476  FE C5					mov first,   1     ; anything not 0 is true
 1478  EB CC			
 147A						mov ax,    number
						mov value, ax
 147A  5D		   *	    pop    bp
 147B  5A		   *	    pop    dx
 147C  59		   *	    pop    cx
 147D  5B		   *	    pop    bx
 147E  58		   *	    pop    ax
 147F  C3		   *	    ret    00000h
 1480				
						mov bx, string
 1480						mov cx, 5
 1480  55		   *	    push   bp
 1481  8B EC		   *	    mov    bp, sp
 1483  50		   *	    push   ax
 1484  53		   *	    push   bx
 1485  51		   *	    push   cx
 1486  52		   *	    push   dx
 1487  55		   *	    push   bp
 1488  8B 5E 04					.repeat
							mov dx,    0
 148B  EB 07		   *	    jmp    @C010D
 148D			   *@C010E:
 148D  B4 02						mov ax,    value
 148F  8A 17						div divisor
 1491  CD 21						mov value, dx
 1493  43			
							.if (ax != 0) || (!first) ; no zeroes on the left
 1494			   *@C010D:
 1494  80 3F 00		   *	    cmp    byte ptr [bx], 000h
 1497  75 F4		   *	    jne    @C010E
								add al,            '0'
 1499  5D		   *	    pop    bp
 149A  5A		   *	    pop    dx
 149B  59		   *	    pop    cx
 149C  5B		   *	    pop    bx
 149D  58		   *	    pop    ax
 149E  5D		   *	    pop    bp
 149F  C2 0002		   *	    ret    00002h
 14A2								mov byte ptr [bx], al
								inc bx
 14A2								mov first,         0
							.endif
 14A2  55		   *	    push   bp
 14A3  8B EC		   *	    mov    bp, sp
 14A5  83 C4 FA		   *	    add    sp, 0FFFAh
 14A8  50		   *	    push   ax
 14A9  53		   *	    push   bx
 14AA  51		   *	    push   cx
 14AB  52		   *	    push   dx
 14AC  55		   *	    push   bp
				
 14AD  FF 76 04		   *	    push   word  ptr ss:[bp]+00004h
 14B0  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14B3  50		   *	    push   ax
 14B4  E8 00A2		   *	    call   string_from_word
							mov dx,      0
 14B7  8D 46 FA		   *	    lea    ax, byte  ptr ss:[bp]+0FAh
 14BA  50		   *	    push   ax
 14BB  E8 FFC2		   *	    call   printf_s
							mov ax,      divisor
 14BE  5D		   *	    pop    bp
 14BF  5A		   *	    pop    dx
 14C0  59		   *	    pop    cx
 14C1  5B		   *	    pop    bx
 14C2  58		   *	    pop    ax
 14C3  8B E5		   *	    mov    sp, bp
 14C5  5D		   *	    pop    bp
 14C6  C2 0002		   *	    ret    00002h
 14C9							mov si,      10
							div si
 14C9							mov divisor, ax
				
 14C9  55		   *	    push   bp
 14CA  8B EC		   *	    mov    bp, sp
 14CC  83 C4 F8		   *	    add    sp, 0FFF8h
 14CF  50		   *	    push   ax
 14D0  53		   *	    push   bx
 14D1  51		   *	    push   cx
 14D2  52		   *	    push   dx
 14D3  55		   *	    push   bp
						.untilcxz
 14D4  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 14D7  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14DA  50		   *	    push   ax
 14DB  E8 0050		   *	    call   string_from_sword
				
 14DE  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 14E1  50		   *	    push   ax
 14E2  E8 FF9B		   *	    call   printf_s
						.if (first)
 14E5  5D		   *	    pop    bp
 14E6  5A		   *	    pop    dx
 14E7  59		   *	    pop    cx
 14E8  5B		   *	    pop    bx
 14E9  58		   *	    pop    ax
 14EA  8B E5		   *	    mov    sp, bp
 14EC  5D		   *	    pop    bp
 14ED  C2 0002		   *	    ret    00002h
 14F0							mov byte ptr [bx], '0'
							inc bx
 14F0						.endif
				
 14F0  55		   *	    push   bp
 14F1  8B EC		   *	    mov    bp, sp
 14F3  83 C4 F8		   *	    add    sp, 0FFF8h
 14F6  50		   *	    push   ax
 14F7  53		   *	    push   bx
 14F8  51		   *	    push   cx
 14F9  52		   *	    push   dx
 14FA  55		   *	    push   bp
						mov cx, string
 14FB  FF 76 04		   *	    push   sword  ptr ss:[bp]+00004h
 14FE  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 1501  50		   *	    push   ax
 1502  E8 0029		   *	    call   string_from_sword
						mov ax, bx
 1505  8B 4E 06					sub ax, cx     ; ax = bx - string = len
 1508  2B C8			
						mov byte ptr [bx], 0
 150A  EB 0B		   *	    jmp    @C0110
 150C			   *@C0111:
						ret
			     1			SaveRegs ax, dx
			     2			local reg, comma, regpushed
 = 			     2			??021D     textequ <>
 = 			     2			??021E textequ <>
			     2			for       ??021C, <ax,dx>
			     2				push  ??021C
			     2				??021E catstr <??021C>, ??021D, ??021E
			     2				??021D catstr <, >
			     2			endm
 150C  50		     3				push  ax
 = ax			     3				??021E catstr <ax>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 150D  52		     3				push  dx
 = dx, ax		     3				??021E catstr <dx>, ??021D, ??021E
 = , 			     3				??021D catstr <, >
 = <dx, ax>		     2			??021E catstr OPEN_DELIMITER, ??021E, CLOSE_DELIMITER
			     2			__pushRegs ??021E
 = 0000			     3			size_s sizestr regStack
			     3			if     size_s eq 0
 = <dx, ax>		     3				regStack catstr ??021E
			     3			else
			     3				regStack catstr ??021E, REG_SET_DELIMITER, regStack
			     3			endif
 150E  B4 02		     1			mov      ah, 02h
 1510  B2 20		     1			mov      dl, SPACE
 1512  CD 21		     1			int      21h
			     1			RestoreRegs
			     2			local reg
			     3			local regs_end, regs
 = 0000			     3			??0220 instr 1, regStack, REG_SET_DELIMITER
			     3			if    ??0220 eq 0
 = <dx, ax>		     3				??0221     substr regStack, 1
 = 			     3				regStack textequ <>
			     3			else
			     3				??0221 substr regStack, 1, (??0220 - 1)
			     3				regStack substr regStack, (??0220 + 1)
			     3			endif
			     3			exitm ??0221
			     2		%	for ??021F, __popRegs(regStack) 
			     2				pop ??021F
			     2			endm
 1514  5A		     3				pop dx
 1515  58		     3				pop ax
 1516  49				string_from_word endp
				
 1517			   *@C0110:
 1517  83 F9 00		   *	    cmp    sword ptr cx, 000h
 151A  7F F0		   *	    jg     @C0111
				;--------------------------------------------------------------------
 151C  8D 46 F9		   *	    lea    ax, byte  ptr ss:[bp]+0F9h
 151F  50		   *	    push   ax
 1520  E8 FF5D		   *	    call   printf_s
				end
 1523  5D		   *	    pop    bp
 1524  5A		   *	    pop    dx
 1525  59		   *	    pop    cx
 1526  5B		   *	    pop    bx
 1527  58		   *	    pop    ax
 1528  8B E5		   *	    mov    sp, bp
 152A  5D		   *	    pop    bp
 152B  C2 0004		   *	    ret    00004h
 152E
 152E
 152E  55		   *	    push   bp
 152F  8B EC		   *	    mov    bp, sp
 1531  53		   *	    push   bx
 1532  51		   *	    push   cx
 1533  52		   *	    push   dx
 1534  55		   *	    push   bp
 1535  8B 56 06
 1538  8B 5E 04
 153B  B9 0000
 153E  83 FA 00		   *	    cmp    sword ptr dx, 000h
 1541  7D 07		   *	    jge    @C0113
 1543  C6 07 2D
 1546  43
 1547  41
 1548  F7 DA
 154A			   *@C0113:
 154A  52		   *	    push   dx
 154B  53		   *	    push   bx
 154C  E8 000A		   *	    call   string_from_word
 154F  03 C1
 1551  5D		   *	    pop    bp
 1552  5A		   *	    pop    dx
 1553  59		   *	    pop    cx
 1554  5B		   *	    pop    bx
 1555  5D		   *	    pop    bp
 1556  C2 0004		   *	    ret    00004h
 1559
 1559
 1559  55		   *	    push   bp
 155A  8B EC		   *	    mov    bp, sp
 155C  83 C4 FA		   *	    add    sp, 0FFFAh
 155F  53		   *	    push   bx
 1560  51		   *	    push   cx
 1561  52		   *	    push   dx
 1562  55		   *	    push   bp
 1563  56		   *	    push   si
 1564  C7 46 FC 2710
 1569  C6 46 FB 01
 156D  8B 46 06
 1570  89 46 FE
 1573  8B 5E 04
 1576  B9 0005
 1579			   *@C0115:
 1579  BA 0000
 157C  8B 46 FE
 157F  F7 76 FC
 1582  89 56 FE
 1585  0B C0		   *	    or	ax, ax
 1587  75 06		   *	    jne    @C0117
 1589  80 7E FB 00	   *	    cmp    first, 000h
 158D  75 09		   *	    jne    @C0116
 158F			   *@C0117:
 158F  04 30
 1591  88 07
 1593  43
 1594  C6 46 FB 00
 1598			   *@C0116:
 1598  BA 0000
 159B  8B 46 FC
 159E  BE 000A
 15A1  F7 F6
 15A3  89 46 FC
 15A6  E2 D1		   *	    loop   @C0115
 15A8  80 7E FB 00	   *	    cmp    first, 000h
 15AC  74 04		   *	    je     @C0119
 15AE  C6 07 30
 15B1  43
 15B2			   *@C0119:
 15B2  8B 4E 04
 15B5  8B C3
 15B7  2B C1
 15B9  C6 07 00
 15BC  5E		   *	    pop    si
 15BD  5D		   *	    pop    bp
 15BE  5A		   *	    pop    dx
 15BF  59		   *	    pop    cx
 15C0  5B		   *	    pop    bx
 15C1  8B E5		   *	    mov    sp, bp
 15C3  5D		   *	    pop    bp
 15C4  C2 0004		   *	    ret    00004h
 15C7
Microsoft (R) Macro Assembler Version 6.11		    12/15/25 09:29:17
main.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CloseFileHandle  . . . . . . . .	Proc
CurrentIndexToBx . . . . . . . .	Proc
DEFINED  . . . . . . . . . . . .	Func
ErrorCantOpenNorCreate . . . . .	Proc
ErrorCommandExpectsNumber  . . .	Proc
ErrorNumberOutOfBounds . . . . .	Proc
HandleCR . . . . . . . . . . . .	Proc
RestoreRegs  . . . . . . . . . .	Proc
SaveRegs . . . . . . . . . . . .	Proc
SkipSpacesInSI . . . . . . . . .	Proc
StartsWith . . . . . . . . . . .	Proc
WriteToFile  . . . . . . . . . .	Proc
__popRegs  . . . . . . . . . . .	Func
__pushRegs . . . . . . . . . . .	Proc
jumpIfSIComparesTo . . . . . . .	Proc
print_FilePosition . . . . . . .	Proc
print_Pair . . . . . . . . . . .	Proc
print_TotalRowCol  . . . . . . .	Proc
printf_c . . . . . . . . . . . .	Proc
putc . . . . . . . . . . . . . .	Proc
skipAndRead  . . . . . . . . . .	Proc
strcpy_all . . . . . . . . . . .	Proc
strcpy_c . . . . . . . . . . . .	Proc
strcpy . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 042B	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0400	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 15C7	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ADDMatrix  . . . . . . . . . . .	P Near	 019A	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  ADDMatrix@Loop . . . . . . . .	L Near	 01D4	  _TEXT	
DIVMatrix  . . . . . . . . . . .	P Near	 0162	  _TEXT	Length= 0038 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  DIVMatrix@Loop . . . . . . . .	L Near	 0184	  _TEXT	
ExitAndClose . . . . . . . . . .	P Near	 0345	  _TEXT	Length= 0019 Public STDCALL
ExitFailure  . . . . . . . . . .	P Near	 0340	  _TEXT	Length= 0005 Public STDCALL
ExitSuccess  . . . . . . . . . .	P Near	 033B	  _TEXT	Length= 0005 Public STDCALL
MULMatrix  . . . . . . . . . . .	P Near	 012B	  _TEXT	Length= 0037 Public STDCALL
  LINHA  . . . . . . . . . . . .	Byte	 bp + 0004
  CONSTANTE  . . . . . . . . . .	Word	 bp + 0006
  MULMatrix@Loop . . . . . . . .	L Near	 014D	  _TEXT	
Main@ADD . . . . . . . . . . . .	P Near	 008B	  _TEXT	Length= 0020 Public STDCALL
Main@MUL . . . . . . . . . . . .	P Near	 00AB	  _TEXT	Length= 001C Public STDCALL
Main@UNDO  . . . . . . . . . . .	P Near	 00C7	  _TEXT	Length= 0117 Public STDCALL
Main@WRITE . . . . . . . . . . .	P Near	 0126	  _TEXT	Length= 0005 Public STDCALL
MoveBack . . . . . . . . . . . .	P Near	 12A9	  _TEXT	Length= 0020 Public STDCALL
OpenFile . . . . . . . . . . . .	P Near	 124D	  _TEXT	Length= 001C Public STDCALL
ParseCommand@CONSTANTE_AUSENTE .	P Near	 07EA	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_AUSENTE . . .	P Near	 0710	  _TEXT	Length= 00DA Public STDCALL
ParseCommand@LINHA_DST_AUSENTE .	P Near	 08D0	  _TEXT	Length= 00EA Public STDCALL
ParseCommand@LINHA_DST_INVALIDA 	P Near	 0B0C	  _TEXT	Length= 007C Public STDCALL
ParseCommand@LINHA_INVALIDA  . .	P Near	 0AA0	  _TEXT	Length= 006C Public STDCALL
ParseCommand@LINHA_ORG_AUSENTE .	P Near	 09BA	  _TEXT	Length= 00E6 Public STDCALL
ParseCommand@LINHA_ORG_INVALIDA 	P Near	 0B88	  _TEXT	Length= 007C Public STDCALL
ParseCommand . . . . . . . . . .	P Near	 03EB	  _TEXT	Length= 0325 Public STDCALL
  a  . . . . . . . . . . . . . .	Word	 bp - 0002
  ??004A . . . . . . . . . . . .	L Near	 0422	  _TEXT	
  ??004B . . . . . . . . . . . .	L Near	 0425	  _TEXT	
  ??0054 . . . . . . . . . . . .	L Near	 0455	  _TEXT	
  ??0055 . . . . . . . . . . . .	L Near	 0458	  _TEXT	
  ??005E . . . . . . . . . . . .	L Near	 0491	  _TEXT	
  ??005F . . . . . . . . . . . .	L Near	 0494	  _TEXT	
  ??0068 . . . . . . . . . . . .	L Near	 04D6	  _TEXT	
  ??0069 . . . . . . . . . . . .	L Near	 04D9	  _TEXT	
  ??0072 . . . . . . . . . . . .	L Near	 0512	  _TEXT	
  ??0073 . . . . . . . . . . . .	L Near	 0515	  _TEXT	
  ??007C . . . . . . . . . . . .	L Near	 054E	  _TEXT	
  ??007D . . . . . . . . . . . .	L Near	 0551	  _TEXT	
  ParseCommand@error . . . . . .	L Near	 05BC	  _TEXT	
  ParseCommand@MUL . . . . . . .	L Near	 05C4	  _TEXT	
  ParseCommand@ADD . . . . . . .	L Near	 0623	  _TEXT	
  ParseCommand@UNDO  . . . . . .	L Near	 06A0	  _TEXT	
  ParseCommand@WRITE . . . . . .	L Near	 06A5	  _TEXT	
  ParseCommand@EXIT  . . . . . .	L Near	 06BC	  _TEXT	
  ParseCommand@success . . . . .	L Near	 06BE	  _TEXT	
PeekChar . . . . . . . . . . . .	P Near	 12C9	  _TEXT	Length= 0014 Public STDCALL
PrintMatrix  . . . . . . . . . .	P Near	 1438	  _TEXT	Length= 0048 Public STDCALL
  .ForRow  . . . . . . . . . . .	L Near	 1446	  _TEXT	
  .ForCol  . . . . . . . . . . .	L Near	 144E	  _TEXT	
  .EndForCol . . . . . . . . . .	L Near	 1462	  _TEXT	
  .EndForRow . . . . . . . . . .	L Near	 147A	  _TEXT	
ReadCharTo . . . . . . . . . . .	P Near	 127E	  _TEXT	Length= 002B Public STDCALL
  Buffer . . . . . . . . . . . .	Word	 bp + 0004
ReadChar . . . . . . . . . . . .	P Near	 1269	  _TEXT	Length= 0015 Public STDCALL
ReadCommand  . . . . . . . . . .	P Near	 035E	  _TEXT	Length= 002F Public STDCALL
ReadEmptyLines . . . . . . . . .	P Near	 1208	  _TEXT	Length= 0045 Public STDCALL
ReadMatrix . . . . . . . . . . .	P Near	 1322	  _TEXT	Length= 011E Public STDCALL
  ReadMatrixLoop . . . . . . . .	L Near	 132A	  _TEXT	
  EndReading . . . . . . . . . .	L Near	 1425	  _TEXT	
ReadNumFromString  . . . . . . .	P Near	 038D	  _TEXT	Length= 005E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  result . . . . . . . . . . . .	Word	 bp + 0006
ReadNum  . . . . . . . . . . . .	P Near	 12DD	  _TEXT	Length= 0045 Public STDCALL
  result . . . . . . . . . . . .	Word	 bp + 0004
SUBMatrix  . . . . . . . . . . .	P Near	 01ED	  _TEXT	Length= 0053 Public STDCALL
  LINHA_DST  . . . . . . . . . .	Byte	 bp + 0004
  LINHA_ORG  . . . . . . . . . .	Byte	 bp + 0006
  SUBMatrix@Loop . . . . . . . .	L Near	 0227	  _TEXT	
WRITEMatrix  . . . . . . . . . .	P Near	 0240	  _TEXT	Length= 00FB Public STDCALL
  NOME . . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
  handle . . . . . . . . . . . .	Word	 bp - 000A
  create_file  . . . . . . . . .	L Near	 025C	  _TEXT	
  file_opened  . . . . . . . . .	L Near	 0268	  _TEXT	
  WRITEMatrix@ForRow . . . . . .	L Near	 02C8	  _TEXT	
  WRITEMatrix@ForCol . . . . . .	L Near	 02D2	  _TEXT	
  WRITEMatrix@EndForCol  . . . .	L Near	 0315	  _TEXT	
  WRITEMatrix@EndForRow  . . . .	L Near	 032D	  _TEXT	
printf_d_padded  . . . . . . . .	P Near	 14F0	  _TEXT	Length= 003E Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  padTo  . . . . . . . . . . . .	Word	 bp + 0006
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_d . . . . . . . . . . . .	P Near	 14C9	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0007
printf_s . . . . . . . . . . . .	P Near	 1480	  _TEXT	Length= 0022 Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
printf_u . . . . . . . . . . . .	P Near	 14A2	  _TEXT	Length= 0027 Public STDCALL
  number . . . . . . . . . . . .	Word	 bp + 0004
  buf  . . . . . . . . . . . . .	Byte	 bp - 0006
string_from_sword  . . . . . . .	P Near	 152E	  _TEXT	Length= 002B Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
string_from_word . . . . . . . .	P Near	 1559	  _TEXT	Length= 006E Public STDCALL
  string . . . . . . . . . . . .	Word	 bp + 0004
  number . . . . . . . . . . . .	Word	 bp + 0006
  value  . . . . . . . . . . . .	Word	 bp - 0002
  divisor  . . . . . . . . . . .	Word	 bp - 0004
  first  . . . . . . . . . . . .	Byte	 bp - 0005


Symbols:

                N a m e                 Type     Value    Attr

??0001 . . . . . . . . . . . . .	Text   	 , 
??0002 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0004 . . . . . . . . . . . . .	Number	 0000h	 
??0005 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0007 . . . . . . . . . . . . .	Text   	 , 
??0008 . . . . . . . . . . . . .	Text   	 <dx, ax>
??000A . . . . . . . . . . . . .	Number	 0000h	 
??000B . . . . . . . . . . . . .	Text   	 <dx, ax>
??000D . . . . . . . . . . . . .	Text   	 , 
??000E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0010 . . . . . . . . . . . . .	Number	 0000h	 
??0011 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0013 . . . . . . . . . . . . .	Text   	 , 
??0014 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0016 . . . . . . . . . . . . .	Number	 0000h	 
??0017 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0019 . . . . . . . . . . . . .	Text   	 , 
??001A . . . . . . . . . . . . .	Text   	 <ax>
??001C . . . . . . . . . . . . .	Number	 0000h	 
??001D . . . . . . . . . . . . .	Text   	 <ax>
??001F . . . . . . . . . . . . .	Text   	 , 
??0020 . . . . . . . . . . . . .	Text   	 <ax>
??0022 . . . . . . . . . . . . .	Number	 0000h	 
??0023 . . . . . . . . . . . . .	Text   	 <ax>
??0025 . . . . . . . . . . . . .	Text   	 , 
??0026 . . . . . . . . . . . . .	Text   	 <ax>
??0028 . . . . . . . . . . . . .	Number	 0000h	 
??0029 . . . . . . . . . . . . .	Text   	 <ax>
??002B . . . . . . . . . . . . .	Text   	 , 
??002C . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??002E . . . . . . . . . . . . .	Number	 0000h	 
??002F . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0031 . . . . . . . . . . . . .	Text   	 , 
??0032 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0034 . . . . . . . . . . . . .	Number	 0000h	 
??0035 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??0037 . . . . . . . . . . . . .	Text   	 , 
??0038 . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003A . . . . . . . . . . . . .	Number	 0000h	 
??003B . . . . . . . . . . . . .	Text   	 <dx, cx, bx>
??003D . . . . . . . . . . . . .	Text   	 , 
??003E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0040 . . . . . . . . . . . . .	Number	 0000h	 
??0041 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0043 . . . . . . . . . . . . .	Text   	 , 
??0044 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0046 . . . . . . . . . . . . .	Number	 0000h	 
??0047 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0048 . . . . . . . . . . . . .	Number	 0003h	 
??004D . . . . . . . . . . . . .	Text   	 , 
??004E . . . . . . . . . . . . .	Text   	 <bx, ax>
??0050 . . . . . . . . . . . . .	Number	 0000h	 
??0051 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0052 . . . . . . . . . . . . .	Number	 0003h	 
??0057 . . . . . . . . . . . . .	Text   	 , 
??0058 . . . . . . . . . . . . .	Text   	 <bx, ax>
??005A . . . . . . . . . . . . .	Number	 0000h	 
??005B . . . . . . . . . . . . .	Text   	 <bx, ax>
??005C . . . . . . . . . . . . .	Number	 0004h	 
??0061 . . . . . . . . . . . . .	Text   	 , 
??0062 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0064 . . . . . . . . . . . . .	Number	 0000h	 
??0065 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0066 . . . . . . . . . . . . .	Number	 0005h	 
??006B . . . . . . . . . . . . .	Text   	 , 
??006C . . . . . . . . . . . . .	Text   	 <bx, ax>
??006E . . . . . . . . . . . . .	Number	 0000h	 
??006F . . . . . . . . . . . . .	Text   	 <bx, ax>
??0070 . . . . . . . . . . . . .	Number	 0004h	 
??0075 . . . . . . . . . . . . .	Text   	 , 
??0076 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0078 . . . . . . . . . . . . .	Number	 0000h	 
??0079 . . . . . . . . . . . . .	Text   	 <bx, ax>
??007A . . . . . . . . . . . . .	Number	 0004h	 
??007F . . . . . . . . . . . . .	Text   	 , 
??0080 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0082 . . . . . . . . . . . . .	Number	 0000h	 
??0083 . . . . . . . . . . . . .	Text   	 <bx, ax>
??0085 . . . . . . . . . . . . .	Text   	 , 
??0086 . . . . . . . . . . . . .	Text   	 <ax>
??0088 . . . . . . . . . . . . .	Number	 0000h	 
??0089 . . . . . . . . . . . . .	Text   	 <ax>
??008B . . . . . . . . . . . . .	Text   	 , 
??008C . . . . . . . . . . . . .	Text   	 <ax>
??008E . . . . . . . . . . . . .	Number	 0000h	 
??008F . . . . . . . . . . . . .	Text   	 <ax>
??0091 . . . . . . . . . . . . .	Text   	 , 
??0092 . . . . . . . . . . . . .	Text   	 <ax>
??0094 . . . . . . . . . . . . .	Number	 0000h	 
??0095 . . . . . . . . . . . . .	Text   	 <ax>
??0097 . . . . . . . . . . . . .	Text   	 , 
??0098 . . . . . . . . . . . . .	Text   	 <ax>
??009A . . . . . . . . . . . . .	Number	 0000h	 
??009B . . . . . . . . . . . . .	Text   	 <ax>
??009D . . . . . . . . . . . . .	Text   	 , 
??009E . . . . . . . . . . . . .	Text   	 <ax>
??00A0 . . . . . . . . . . . . .	Number	 0000h	 
??00A1 . . . . . . . . . . . . .	Text   	 <ax>
??00A3 . . . . . . . . . . . . .	Text   	 , 
??00A4 . . . . . . . . . . . . .	Text   	 <ax>
??00A6 . . . . . . . . . . . . .	Number	 0000h	 
??00A7 . . . . . . . . . . . . .	Text   	 <ax>
??00A9 . . . . . . . . . . . . .	Text   	 , 
??00AA . . . . . . . . . . . . .	Text   	 <ax>
??00AC . . . . . . . . . . . . .	Number	 0000h	 
??00AD . . . . . . . . . . . . .	Text   	 <ax>
??00AF . . . . . . . . . . . . .	Text   	 , 
??00B0 . . . . . . . . . . . . .	Text   	 <ax>
??00B2 . . . . . . . . . . . . .	Number	 0000h	 
??00B3 . . . . . . . . . . . . .	Text   	 <ax>
??00B5 . . . . . . . . . . . . .	Text   	 , 
??00B6 . . . . . . . . . . . . .	Text   	 <ax>
??00B8 . . . . . . . . . . . . .	Number	 0000h	 
??00B9 . . . . . . . . . . . . .	Text   	 <ax>
??00BB . . . . . . . . . . . . .	Text   	 , 
??00BC . . . . . . . . . . . . .	Text   	 <ax>
??00BE . . . . . . . . . . . . .	Number	 0000h	 
??00BF . . . . . . . . . . . . .	Text   	 <ax>
??00C1 . . . . . . . . . . . . .	Text   	 , 
??00C2 . . . . . . . . . . . . .	Text   	 <ax>
??00C4 . . . . . . . . . . . . .	Number	 0000h	 
??00C5 . . . . . . . . . . . . .	Text   	 <ax>
??00C7 . . . . . . . . . . . . .	Text   	 , 
??00C8 . . . . . . . . . . . . .	Text   	 <ax>
??00CA . . . . . . . . . . . . .	Number	 0000h	 
??00CB . . . . . . . . . . . . .	Text   	 <ax>
??00CD . . . . . . . . . . . . .	Text   	 , 
??00CE . . . . . . . . . . . . .	Text   	 <ax>
??00D0 . . . . . . . . . . . . .	Number	 0000h	 
??00D1 . . . . . . . . . . . . .	Text   	 <ax>
??00D3 . . . . . . . . . . . . .	Text   	 , 
??00D4 . . . . . . . . . . . . .	Text   	 <ax>
??00D6 . . . . . . . . . . . . .	Number	 0000h	 
??00D7 . . . . . . . . . . . . .	Text   	 <ax>
??00D9 . . . . . . . . . . . . .	Text   	 , 
??00DA . . . . . . . . . . . . .	Text   	 <ax>
??00DC . . . . . . . . . . . . .	Number	 0000h	 
??00DD . . . . . . . . . . . . .	Text   	 <ax>
??00DF . . . . . . . . . . . . .	Text   	 , 
??00E0 . . . . . . . . . . . . .	Text   	 <ax>
??00E2 . . . . . . . . . . . . .	Number	 0000h	 
??00E3 . . . . . . . . . . . . .	Text   	 <ax>
??00E5 . . . . . . . . . . . . .	Text   	 , 
??00E6 . . . . . . . . . . . . .	Text   	 <ax>
??00E8 . . . . . . . . . . . . .	Number	 0000h	 
??00E9 . . . . . . . . . . . . .	Text   	 <ax>
??00EB . . . . . . . . . . . . .	Text   	 , 
??00EC . . . . . . . . . . . . .	Text   	 <ax>
??00EE . . . . . . . . . . . . .	Number	 0000h	 
??00EF . . . . . . . . . . . . .	Text   	 <ax>
??00F1 . . . . . . . . . . . . .	Text   	 , 
??00F2 . . . . . . . . . . . . .	Text   	 <ax>
??00F4 . . . . . . . . . . . . .	Number	 0000h	 
??00F5 . . . . . . . . . . . . .	Text   	 <ax>
??00F7 . . . . . . . . . . . . .	Text   	 , 
??00F8 . . . . . . . . . . . . .	Text   	 <ax>
??00FA . . . . . . . . . . . . .	Number	 0000h	 
??00FB . . . . . . . . . . . . .	Text   	 <ax>
??00FD . . . . . . . . . . . . .	Text   	 , 
??00FE . . . . . . . . . . . . .	Text   	 <ax>
??0100 . . . . . . . . . . . . .	Number	 0000h	 
??0101 . . . . . . . . . . . . .	Text   	 <ax>
??0103 . . . . . . . . . . . . .	Text   	 , 
??0104 . . . . . . . . . . . . .	Text   	 <ax>
??0106 . . . . . . . . . . . . .	Number	 0000h	 
??0107 . . . . . . . . . . . . .	Text   	 <ax>
??0109 . . . . . . . . . . . . .	Text   	 , 
??010A . . . . . . . . . . . . .	Text   	 <ax>
??010C . . . . . . . . . . . . .	Number	 0000h	 
??010D . . . . . . . . . . . . .	Text   	 <ax>
??010F . . . . . . . . . . . . .	Text   	 , 
??0110 . . . . . . . . . . . . .	Text   	 <ax>
??0112 . . . . . . . . . . . . .	Number	 0000h	 
??0113 . . . . . . . . . . . . .	Text   	 <ax>
??0115 . . . . . . . . . . . . .	Text   	 , 
??0116 . . . . . . . . . . . . .	Text   	 <ax>
??0118 . . . . . . . . . . . . .	Number	 0000h	 
??0119 . . . . . . . . . . . . .	Text   	 <ax>
??011B . . . . . . . . . . . . .	Text   	 , 
??011C . . . . . . . . . . . . .	Text   	 <ax>
??011E . . . . . . . . . . . . .	Number	 0000h	 
??011F . . . . . . . . . . . . .	Text   	 <ax>
??0121 . . . . . . . . . . . . .	Text   	 , 
??0122 . . . . . . . . . . . . .	Text   	 <ax>
??0124 . . . . . . . . . . . . .	Number	 0000h	 
??0125 . . . . . . . . . . . . .	Text   	 <ax>
??0127 . . . . . . . . . . . . .	Text   	 , 
??0128 . . . . . . . . . . . . .	Text   	 <ax>
??012A . . . . . . . . . . . . .	Number	 0000h	 
??012B . . . . . . . . . . . . .	Text   	 <ax>
??012D . . . . . . . . . . . . .	Text   	 , 
??012E . . . . . . . . . . . . .	Text   	 <ax>
??0130 . . . . . . . . . . . . .	Number	 0000h	 
??0131 . . . . . . . . . . . . .	Text   	 <ax>
??0133 . . . . . . . . . . . . .	Text   	 , 
??0134 . . . . . . . . . . . . .	Text   	 <ax>
??0136 . . . . . . . . . . . . .	Number	 0000h	 
??0137 . . . . . . . . . . . . .	Text   	 <ax>
??0139 . . . . . . . . . . . . .	Text   	 , 
??013A . . . . . . . . . . . . .	Text   	 <ax>
??013C . . . . . . . . . . . . .	Number	 0000h	 
??013D . . . . . . . . . . . . .	Text   	 <ax>
??013F . . . . . . . . . . . . .	Text   	 , 
??0140 . . . . . . . . . . . . .	Text   	 <ax>
??0142 . . . . . . . . . . . . .	Number	 0000h	 
??0143 . . . . . . . . . . . . .	Text   	 <ax>
??0145 . . . . . . . . . . . . .	Text   	 , 
??0146 . . . . . . . . . . . . .	Text   	 <ax>
??0148 . . . . . . . . . . . . .	Number	 0000h	 
??0149 . . . . . . . . . . . . .	Text   	 <ax>
??014B . . . . . . . . . . . . .	Text   	 , 
??014C . . . . . . . . . . . . .	Text   	 <ax>
??014E . . . . . . . . . . . . .	Number	 0000h	 
??014F . . . . . . . . . . . . .	Text   	 <ax>
??0151 . . . . . . . . . . . . .	Text   	 , 
??0152 . . . . . . . . . . . . .	Text   	 <ax>
??0154 . . . . . . . . . . . . .	Number	 0000h	 
??0155 . . . . . . . . . . . . .	Text   	 <ax>
??0157 . . . . . . . . . . . . .	Text   	 , 
??0158 . . . . . . . . . . . . .	Text   	 <ax>
??015A . . . . . . . . . . . . .	Number	 0000h	 
??015B . . . . . . . . . . . . .	Text   	 <ax>
??015D . . . . . . . . . . . . .	Text   	 , 
??015E . . . . . . . . . . . . .	Text   	 <ax>
??0160 . . . . . . . . . . . . .	Number	 0000h	 
??0161 . . . . . . . . . . . . .	Text   	 <ax>
??0163 . . . . . . . . . . . . .	Text   	 , 
??0164 . . . . . . . . . . . . .	Text   	 <ax>
??0166 . . . . . . . . . . . . .	Number	 0000h	 
??0167 . . . . . . . . . . . . .	Text   	 <ax>
??0169 . . . . . . . . . . . . .	Text   	 , 
??016A . . . . . . . . . . . . .	Text   	 <ax>
??016C . . . . . . . . . . . . .	Number	 0000h	 
??016D . . . . . . . . . . . . .	Text   	 <ax>
??016F . . . . . . . . . . . . .	Text   	 , 
??0170 . . . . . . . . . . . . .	Text   	 <ax>
??0172 . . . . . . . . . . . . .	Number	 0000h	 
??0173 . . . . . . . . . . . . .	Text   	 <ax>
??0175 . . . . . . . . . . . . .	Text   	 , 
??0176 . . . . . . . . . . . . .	Text   	 <ax>
??0178 . . . . . . . . . . . . .	Number	 0000h	 
??0179 . . . . . . . . . . . . .	Text   	 <ax>
??017B . . . . . . . . . . . . .	Text   	 , 
??017C . . . . . . . . . . . . .	Text   	 <ax>
??017E . . . . . . . . . . . . .	Number	 0000h	 
??017F . . . . . . . . . . . . .	Text   	 <ax>
??0181 . . . . . . . . . . . . .	Text   	 , 
??0182 . . . . . . . . . . . . .	Text   	 <ax>
??0184 . . . . . . . . . . . . .	Number	 0000h	 
??0185 . . . . . . . . . . . . .	Text   	 <ax>
??0187 . . . . . . . . . . . . .	Text   	 , 
??0188 . . . . . . . . . . . . .	Text   	 <ax>
??018A . . . . . . . . . . . . .	Number	 0000h	 
??018B . . . . . . . . . . . . .	Text   	 <ax>
??018D . . . . . . . . . . . . .	Text   	 , 
??018E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0190 . . . . . . . . . . . . .	Number	 0000h	 
??0191 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0193 . . . . . . . . . . . . .	Text   	 , 
??0194 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0196 . . . . . . . . . . . . .	Number	 0000h	 
??0197 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0199 . . . . . . . . . . . . .	Text   	 , 
??019A . . . . . . . . . . . . .	Text   	 <dx, ax>
??019C . . . . . . . . . . . . .	Number	 0000h	 
??019D . . . . . . . . . . . . .	Text   	 <dx, ax>
??019F . . . . . . . . . . . . .	Text   	 , 
??01A0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A2 . . . . . . . . . . . . .	Number	 0000h	 
??01A3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A5 . . . . . . . . . . . . .	Text   	 , 
??01A6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01A8 . . . . . . . . . . . . .	Number	 0000h	 
??01A9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AB . . . . . . . . . . . . .	Text   	 , 
??01AC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01AE . . . . . . . . . . . . .	Number	 0000h	 
??01AF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B1 . . . . . . . . . . . . .	Text   	 , 
??01B2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B4 . . . . . . . . . . . . .	Number	 0000h	 
??01B5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01B7 . . . . . . . . . . . . .	Text   	 , 
??01B8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BA . . . . . . . . . . . . .	Number	 0000h	 
??01BB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01BD . . . . . . . . . . . . .	Text   	 , 
??01BE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C0 . . . . . . . . . . . . .	Number	 0000h	 
??01C1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C3 . . . . . . . . . . . . .	Text   	 , 
??01C4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C6 . . . . . . . . . . . . .	Number	 0000h	 
??01C7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01C9 . . . . . . . . . . . . .	Text   	 , 
??01CA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CC . . . . . . . . . . . . .	Number	 0000h	 
??01CD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01CF . . . . . . . . . . . . .	Text   	 , 
??01D0 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D2 . . . . . . . . . . . . .	Number	 0000h	 
??01D3 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D5 . . . . . . . . . . . . .	Text   	 , 
??01D6 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01D8 . . . . . . . . . . . . .	Number	 0000h	 
??01D9 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DB . . . . . . . . . . . . .	Text   	 , 
??01DC . . . . . . . . . . . . .	Text   	 <dx, ax>
??01DE . . . . . . . . . . . . .	Number	 0000h	 
??01DF . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E1 . . . . . . . . . . . . .	Text   	 , 
??01E2 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E4 . . . . . . . . . . . . .	Number	 0000h	 
??01E5 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01E7 . . . . . . . . . . . . .	Text   	 , 
??01E8 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01EA . . . . . . . . . . . . .	Number	 0000h	 
??01EB . . . . . . . . . . . . .	Text   	 <dx, ax>
??01ED . . . . . . . . . . . . .	Text   	 , 
??01EE . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F0 . . . . . . . . . . . . .	Number	 0000h	 
??01F1 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F3 . . . . . . . . . . . . .	Text   	 , 
??01F4 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F6 . . . . . . . . . . . . .	Number	 0000h	 
??01F7 . . . . . . . . . . . . .	Text   	 <dx, ax>
??01F9 . . . . . . . . . . . . .	Text   	 , 
??01FA . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FC . . . . . . . . . . . . .	Number	 0000h	 
??01FD . . . . . . . . . . . . .	Text   	 <dx, ax>
??01FF . . . . . . . . . . . . .	Text   	 , 
??0200 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0202 . . . . . . . . . . . . .	Number	 0000h	 
??0203 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0205 . . . . . . . . . . . . .	Text   	 , 
??0206 . . . . . . . . . . . . .	Text   	 <ax>
??0208 . . . . . . . . . . . . .	Number	 0000h	 
??0209 . . . . . . . . . . . . .	Text   	 <ax>
??020B . . . . . . . . . . . . .	Text   	 , 
??020C . . . . . . . . . . . . .	Text   	 <ax>
??020E . . . . . . . . . . . . .	Number	 0000h	 
??020F . . . . . . . . . . . . .	Text   	 <ax>
??0211 . . . . . . . . . . . . .	Text   	 , 
??0212 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0214 . . . . . . . . . . . . .	Number	 0000h	 
??0215 . . . . . . . . . . . . .	Text   	 <dx, ax>
??0217 . . . . . . . . . . . . .	Text   	 , 
??0218 . . . . . . . . . . . . .	Text   	 <dx, ax>
??021A . . . . . . . . . . . . .	Number	 0000h	 
??021B . . . . . . . . . . . . .	Text   	 <dx, ax>
??021D . . . . . . . . . . . . .	Text   	 , 
??021E . . . . . . . . . . . . .	Text   	 <dx, ax>
??0220 . . . . . . . . . . . . .	Number	 0000h	 
??0221 . . . . . . . . . . . . .	Text   	 <dx, ax>
@@nao_foi_possivel_abrir_ou_criar_o_arquivo  Byte     035E     _DATA	
@@parametros_nao_reconhecidos_ao_final_do_comando  Byte	    0388     _DATA	
@@parametro  . . . . . . . . . .	Byte	 032E	  _DATA	
@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@Comando . . . . . . . . . . . .	Byte	 0310	  _DATA	
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0003h	 
@MainLoopEnd . . . . . . . . . .	L Near	 0075	  _TEXT	
@Model . . . . . . . . . . . . .	Number	 0002h	 
@SkipPrint . . . . . . . . . . .	L Near	 001D	  _TEXT	
@Startup . . . . . . . . . . . .	L Near	 0000	  _TEXT	
@ValidCommand  . . . . . . . . .	L Near	 004A	  _TEXT	
@Validate  . . . . . . . . . . .	L Near	 0020	  _TEXT	
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@como  . . . . . . . . . . . . .	Byte	 031F	  _DATA	
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@desconhecido  . . . . . . . . .	Byte	 0338	  _DATA	
@deve_estar_entre_1_e_N  . . . .	Byte	 0347	  _DATA	
@espera  . . . . . . . . . . . .	Byte	 0318	  _DATA	
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@parametro . . . . . . . . . . .	Byte	 0324	  _DATA	
@space . . . . . . . . . . . . .	Byte	 0345	  _DATA	
@stack . . . . . . . . . . . . .	Text   	 DGROUP
@whiletrue . . . . . . . . . . .	L Near	 001A	  _TEXT	
BuffSize . . . . . . . . . . . .	Number	 0064h	 
CLOSE_DELIMITER  . . . . . . . .	Text   	 >
CMD_ADD  . . . . . . . . . . . .	Number	 0003h	 
CMD_DIV  . . . . . . . . . . . .	Number	 0002h	 
CMD_MUL  . . . . . . . . . . . .	Number	 0001h	 
CMD_NONE . . . . . . . . . . . .	Number	 0000h	 
CMD_SUB  . . . . . . . . . . . .	Number	 0004h	 
CMD_UNDO . . . . . . . . . . . .	Number	 0005h	 
CMD_WRITE  . . . . . . . . . . .	Number	 0006h	 
COLON_SPACE  . . . . . . . . . .	Byte	 03B8	  _DATA	
COLUMN_SEP . . . . . . . . . . .	Byte	 0000	  _DATA	
COL_SEPARATOR  . . . . . . . . .	Text   	 SEMI
CRLF . . . . . . . . . . . . . .	Byte	 0002	  _DATA	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
Col  . . . . . . . . . . . . . .	Byte	 03C4	  _DATA	
CommandBufferLength  . . . . . .	Byte	 010C	  _DATA	
CommandBufferString  . . . . . .	Byte	 010D	  _DATA	
CommandBuffer  . . . . . . . . .	Byte	 010B	  _DATA	
ErrorColumnCount . . . . . . . .	L Near	 0CF2	  _TEXT	
ErrorInvalidCommand  . . . . . .	L Near	 1193	  _TEXT	
ErrorInvalidN  . . . . . . . . .	L Near	 1099	  _TEXT	
ErrorOpen  . . . . . . . . . . .	L Near	 0C04	  _TEXT	
ErrorRead  . . . . . . . . . . .	L Near	 0C7D	  _TEXT	
ErrorRowCount  . . . . . . . . .	L Near	 0E2B	  _TEXT	
ErrorUnexpectedChar  . . . . . .	L Near	 0FE0	  _TEXT	
ExplanationSeparator . . . . . .	Text   	 COLON_SPACE
FileBuffer . . . . . . . . . . .	Byte	 000D	  _DATA	
FileCol  . . . . . . . . . . . .	Word	 03BF	  _DATA	
FileHandle . . . . . . . . . . .	Word	 0071	  _DATA	
FileIsOpen . . . . . . . . . . .	Byte	 0073	  _DATA	
FileLine . . . . . . . . . . . .	Word	 03C1	  _DATA	
FileNameBuffer . . . . . . . . .	Byte	 0074	  _DATA	
FileName . . . . . . . . . . . .	Byte	 0005	  _DATA	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LastCommand@a  . . . . . . . . .	Word	 020C	  _DATA	
LastCommand@b  . . . . . . . . .	Word	 020E	  _DATA	
LastCommand@exists . . . . . . .	Byte	 0210	  _DATA	
LastCommand  . . . . . . . . . .	Byte	 020B	  _DATA	
Matrix . . . . . . . . . . . . .	Word	 03C9	  _DATA	
NPlusOne . . . . . . . . . . . .	Byte	 03C8	  _DATA	
NonTerminalErrorBuffer . . . . .	Byte	 0211	  _DATA	
N  . . . . . . . . . . . . . . .	Byte	 03C7	  _DATA	
OPEN_DELIMITER . . . . . . . . .	Text   	 <
PeekBuffer . . . . . . . . . . .	Byte	 03BB	  _DATA	
QUOT . . . . . . . . . . . . . .	Number	 0022h	 
REG_SET_DELIMITER  . . . . . . .	Text   	 |
RegsInvokeUses . . . . . . . . .	Text   	 ax bx cx dx bp
RegsReturningOnAX  . . . . . . .	Text   	 bx cx dx bp
RegsReturningOnBX  . . . . . . .	Text   	 ax cx dx bp
Row  . . . . . . . . . . . . . .	Byte	 03C3	  _DATA	
SEMI . . . . . . . . . . . . . .	Number	 003Bh	 
SPACE  . . . . . . . . . . . . .	Number	 0020h	 
TheUnexpectedChar  . . . . . . .	Byte	 03BC	  _DATA	
TotalCol . . . . . . . . . . . .	Byte	 03C6	  _DATA	
TotalRow . . . . . . . . . . . .	Byte	 03C5	  _DATA	
caractere  . . . . . . . . . . .	Byte	 010A	  _DATA	
regStack . . . . . . . . . . . .	Text   	 
size_s . . . . . . . . . . . . .	Number	 0000h	 

	   0 Warnings
	   0 Errors
